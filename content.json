{"pages":[{"title":"","text":"About Me **平淡无奇的前端攻城狮。** 偏爱美好的设计，注重用户体验。 遵循简洁的代码规范，拥有良好的代码习惯。 #Mac 重度用户 #ES6 &amp;&amp; Typescript &amp;&amp; Coffeescript #React &amp;&amp; Redux #Git &amp;&amp; Github #Nodejs 入坑中 #Webpack &amp;&amp; Gulp &amp;&amp; Parcel #WebGL 会一点点点 #Scss #Less #Jade [更多的在这里](https://github.com/kyriejoshua/my-frontend-stack) **0. 对一切事物充满好奇心。** **1. 凡事怎么能不折腾。 ** **2. Geeeeek 一点，再 Geeeeek 一点。** **3. 能用键盘搞定的事，绝不动鼠标。** 欢迎交流 -- kj2046@outlook.com github: https://github.com/kyriejoshua","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ES6 简单特性尝鲜-1","text":"ES6的出现，无疑是对现有的ES5的一次巨大冲击。某种程度上，部分人觉得这是给开发人员带来的巨大惊喜。它保证现有的基础之外，增加了很多好用的语法糖，使得对后端转入的javascript更为友好。尽管有些人在ES5上还未站稳脚跟——譬如我，但已经迫不及待地想去尝试ES6。 尽管在我的工作曾写过coffeescript,typescipt，但我始终觉得基础的才是实用的。让我们抛开那些多样的Javascript超集不谈，回归到js本身来。 1.Block-Scoped Constructs Let and Const (构造let和const及块作用域) 在我刚开始学习js的时候，我的老师教导在js中声明变量，一定要用var声明。否则这些可能原本应当属于你的孩子，最终都会被window抢走。 后来在工作中，更规范的写法是将所有的变量声明在js顶部，以防止声明提前带来的糟糕影响。 而ES6中的let，则让你更容易地避免以上两种易犯的错误。 let是一种新的变量声明的方式，它允许你把变量作用域控制在块级里面。 *你可能不信，让我们先苦后甜——以一个糟糕的例子开头 123456789101112131415function checkYourMoney(you) { var money = 0; if (you) { var money = 5; } { var money = 100; // 混淆你的视线 { var money = 1000; // 再次混淆 } } return money;}console.log(checkYourMoney(true)); 不管你信不信，控制台里输出的都是冷冰冰的1000。尽管现实中你可能希望钱确实能无故多出来，但在代码这儿可不行。 *反面教材结束，正面登场 123456789101112131415function checkYourMoney(you) { let money = 0; if (you) { let money = 5; } { let money = 100; { let money = 1000; } } return money;}console.log(checkYourMoney(true)); 这回变了，输出为0。*let的好处是让你在任何块内定义都不会互相影响，尽管在别的块内你定义了money不同的值，但对于return而言，只获取邻近的变量。 *相对而言，const的使用较少一些。它的作用是声明常量。虽然这么说，不过它的作用更类似于一个指针指向某个引用，这么听起来好像有些git的感觉。尽管它用于定义常量，但这常量并非一成不变。 1234const GIRL = [&apos;lovely&apos;]; // 定义一只可爱的妹子GIRL.push(&apos;beautiful&apos;); // 再漂亮点儿console.log(GIRL); // [&apos;lovely&apos;, &apos;beautiful&apos;]GIRL = &apos;lovely and beautiful&apos;; // TypeError: Identifier &apos;GIRL&apos; has already been declared(…) // 您的妹子已被认领 let和const的基本用法就是这样，还有几点需要注意的是 let声明的变量不具备声明提前的属性，意味着可以就近使用。 let和const只在最靠近的块(作用域/花括号)中有效。 使用const声明时采用大写方式。 const在声明时必须赋值。 let为编写者带来了很多便利，相应地维护成本也增加了，因为你需要非常了解每个声明的变量所处的块作用域。 2.Template Literals (模板对象) 我在工作中有写coffeescript，里面的#{}用法很方便，让你即使在字符串中也可以很自如地穿插变量，现在，ES6推出了类似的写法。 即${}——注意这里的分隔符是反引号`不是‘。 小试一把 12let code = &apos;cold&apos;;console.log(`My code is ${code}`);123// 在我的日常中更广泛的用法是——譬如angular中$http.get(`${config().lala_url}/abc/book?page${page}=&amp;count=${count}`)// do something... 3.Muti-line Strings (多行字符串) 相信不少人在使用jquery的时候都拼接过字符串，而如果一旦内容较多，画面一定很香艳。 true story——请感受一下冰山一角 123456789let order = &apos;&lt;div class=&quot;order&quot;&gt;&apos; + &apos;&lt;div class=&quot;orderTitle&quot;&gt;&apos; + &apos;&lt;div class=&quot;fl&quot;&gt;&apos; + &apos;&lt;div class=&quot;orderNum ml10&quot;&gt;&apos; + order.number + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos; + &apos;&lt;/div&gt;&apos;+ &apos;&lt;/div&gt;&apos; 而有了ES6的反引号``，妈妈再也不用担心我的拼接了！ 123456789let order = `&lt;div class=&quot;order&quot;&gt; &lt;div class=&quot;orderTitle&quot;&gt; &lt;div class=&quot;fl&quot;&gt; &lt;div class=&quot;orderNum ml10&quot;&gt; order.number &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` 请忽略这是段糟糕代码的事实——看！是不是清爽多了。 未完待续…… 参考： 1.前端开发者不得不知的ES6十大特性 2.ECMAScript 6 扫盲","link":"/2016/07/24/ES6-new-features-1/"},{"title":"ES6 新特性尝鲜-2之箭头函数","text":"最近在准备一个新项目，引入了ES6，平时也常写ts，在越来越多的实战中发现箭头函数确实是ES6里最实用的新特性之一。 Arrow Functions 箭头函数首先来看看ES5之前的函数定义的几种方式:123456789101112131415161718191.函数语句定义function printProps(o) { for (var p in o) { console.log(p + &apos;:&apos; + o[p] + &apos;\\n&apos;); };}2.表达式定义var f = function fact(x) { if (x &lt; 1) { return x; } else { return x * fact(x - 1); };}也可以定以后立即调用:var tensquared = (function(x) {return x * x}(10)) 如果代码中的函数较少，也还好接受。但当函数较多时，满屏的function有些让人烦扰。*让我们来试试ES6吧。 ES6箭头函数12ES6允许用箭头来定义函数。var f = a =&gt; a;等同于 123var f = function(a) { return a;} 如果没有参数或多个参数，可以直接使用括号。箭头后紧跟函数体。 123456789var f = () =&gt; b;即var f = function() { return b;}var sum = (a, b) =&gt; a + b;即var sum = function(a, b) { return a + b;} 当返回的是对象时，由于花括号会被解析为函数体，所以要加上括号。 1var getPerson = () =&gt; ({id: &apos;sdfdkjhgdflg&apos;, name: &apos;kyrie&apos;}); 当返回的是多行语句，需要用花括号括起来。 12345var init = (p) =&gt; { for (var o in p) { console.log(o + &apos; : &apos; + p[o]); }} 当然，出于代码整洁和规范的需要。通常会带上花括号。 123456var init = () =&gt; { return { address: &apos;西湖区&apos;, point: [120.123, 30.321] }} 使用箭头函数的好处 1.最大的好处就是使得代码更简洁,尤其是涉及回调的函数。 ​```javascript var timer = setInterval(function() { console.log(new Date()); }, 1000); 可简写为 var timer = setInterval(() =&gt; { console.log(new Date()); }); 同样的还有使用ajax时，如在angular中使用 $http.get(&apos;api.123feng.com/test&apos;) .then(() =&gt; { // do something }, () =&gt; { // do something }); 是不是简洁清爽了很多。 ​```2.还有this只指代定义时的对象，而不是当前对象，所以再也不需要用that来替代this。 ​```javascript 我在写angular时便会遇到，所有定义的变量都相当于是属性，需要用this.prop去访问。 这里使用了ts。 export class OrderBatchController { public order: any; constructor(){ this.order = {}; } getOrder() { var that = this; this.$http(&apos;api.123feng.com/test&apos;) .then(function(res) { // 将获取的值赋值,如果写成this，则该变量变成是window下的变量了。 that.order = res.data; }) } } 用箭头函数则无须这一步 getOrder() { this.$http(&apos;api.123feng.com/test&apos;) .then((res) =&gt; { // this始终指代当前的controller。 this.order = res.data; }) } ​```注意点1.函数体内的this指向定义时的对象，不管嵌套多少层函数，都指向定义时的对象。12345678910getOrder() { this.$http(&apos;api.123feng.com/test&apos;) .then((res) =&gt; { // this始终指代当前的controller。 this.order = res.data; setInterval(() =&gt; { this.order = {}; // controller下面的order又变回{} }, 1000) })} 2.不能用new一个来创建构造函数，否则将会报错。3.不可以使用arguments对象，会在箭头函数的函数体内不存在。使用rest参数代替（待探究） 小结 总体来说，个人觉得ES6的箭头函数和coffee中的箭头函数很相似，使用起来也很方便。最需要注意的地方则是这个this不会再三心二意了。 后续如果有其他注意点，再补充。 参考ES6入门","link":"/2016/08/31/ES6-new-features-2-arrow-function/"},{"title":"HTTP协议之自定义headers参数","text":"近期和我司服务端对接时发现藏在headers里的参数，并不是HTTP的response里的常规参数。几经折腾后发现是自定义的参数。供前端ajax调用时提取使用。 Before 在工作时常常有获取列表的接口，就必然会涉及获取到的数组的长度，即页数。 讲道理，将返回的数组内容和总数量一起返回并不太合理，就像一本书不会在每一页上都标明总页数，而是在书的最开始或者末尾有说明。所以秉着内容和页数不应存放在一起的原则，服务端同事将列表的总页数放在了response的headers里。 所以问题是如何从response headers获取相应参数。 详情 查找了部分文档后找到了Access-Control-Expose-Headers这个参数。 The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. 它表明了哪些参数是可以用名字展示在response的header里的——这里的展示应当理解为前端可以获取，而不是单纯的显示。 默认是展示6个参数： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 也可以展示其他参数。通过以下方式设置： Access-Control-Expose-Headers: Content-Length 甚至自定义参数： Access-Control-Expose-Headers: X-Resource-Count, Content-Length 这样当服务端传了X-Resource-Count时在前端就可以取到X-Rource-Count的值。 123456789101112131415161718192021222324252627282930313233343536373839401.在angular中获取$http.get(`${url}/getLists/`).then((res) =&gt; { // 可以获取到 console.log(res.headers(&apos;X-Resource-Count&apos;));});2.在jquery中获取$.ajax({ url: `${url}/getLists`, type: &apos;GET&apos;, contentType: &apos;application/json;charset/utf-8&apos;,}).done((data, textStatus, jqXHR) =&gt; { console.log(jqXHR.getResponseHeader(&apos;X-Resource-Count&apos;));});3.原生ajaxif (window.XMLHttpRequest) { // Mozilla, Safari. IE7+ httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE 6 and older httpRequest = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);}httpRequest.onreadystatechange = () =&gt; { if (httpRequest.readyState === XMLHttpRequest.DONE) { if (httpRequest.statue === 200) { // something... } else { // error } }};httpRequest.open(&apos;GET&apos;, `${url}/getLists`);______________________________________________________________function getHeaderCount() { console.log(this.getResponseHeader(&apos;X-Resource-Count&apos;));}httpRequest.onload = getHeaderCount;______________________________________________________________httpRequest.send(); 这样就可以愉快地使用X-Resource-Count了。 参考：[Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) Ajax","link":"/2016/10/17/HTTP-define-headers-params/"},{"title":"/* @ngInject */介绍","text":"angular的依赖注入是一个非常好的特性。但如果注入的很多也会比较麻烦。发现了一个可以自动创建注射器对象的方法。 /* @ngInject */ 由于项目使用脚手架构建的，使用了Gulp，所以可以用/* @ngInject */对需要自动依赖注入的function进行注释。避免了一个个输入的麻烦和意外的错误。*前提是在Gulp中使用了ng-annotate。 可以避免代码中的依赖使用到任何不安全的写法. 不推荐用ng-min. *只需在函数前添加即可 1234567891011export class WindController { public sender: IOrderSender; public checkJavaRes: any; /* @ngInject */ constructor ( private $uibModal, private url ){ ... }} 当它在ng-annotate(压缩注释工具?)下运行时，会输出依赖注入的数组. 1WindController.$inject = [&apos;$uibModal&apos;, &apos;url&apos;] 这样原本在index.module.ts(统一写路由的地方)中需要依赖注入的地方就可以无需再输入 123456angular.module(&apos;wind&apos;, [&apos;ngCookies&apos;,...]).controller(&apos;WindController&apos;, [&apos;$scope&apos;, &apos;$http&apos;, WindController]) ... 更新后angular.module(&apos;wind&apos;, [&apos;ngCookies&apos;,...]).controller(&apos;WindController&apos;, WindController) 假如不加入注释的话，使用后者的写法会报错 Error: [$injector:strictdi] WindController is not using explicit annotation and cannot be invoked in strict mode.必须要依赖注入。 参考: [angular中文规范](https://github.com/johnpapa/angular-styleguide/blob/master/a1/i18n/zh-CN.md)","link":"/2016/08/18/about-@ngInject/"},{"title":"call和apply的区别及各自应用场景","text":"call和apply是js里非常常见的两个概念。但自己从来没有好好的深入理解这两者，尤其是在何时使用，如何使用才适合这两个问题上，没有进一步的思考。这里写一篇笔记来反思。 call和apply的定义 在JavaScript权威指南上是这么定义的： call()和apply()可以看做是某个对象的方法，通过调用方法的形式来简洁调用函数。 call, apply都属于Function.prototype的方法。因此所有函数都有该方法。 call()和apply()的第一个实参是要调用函数的母对象，是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f(),可以这样使用它们。 123456f.call(o);f.apply(o);等同于o.m = f;o.m();delete o.m; 代码可以理解，但描述理解起来实在困难。 具体说明 定义都是用来考试时死记硬背的。所以来看看实例。 首先要明确一点：call()和apply()的作用是一样的，只是调用方式不同。 例如：foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3/* arguments */) 两者唯一的不同点在于第二个传入的参数。 第一个实参指代当前调用的对象，如果在ES5严格模式下，第一个实参不管传入什么null或undefined或其他，都会变成this。 第二个实参，call方法可以传入任意的实参，不论数量长度。如foo.call(this, arg1, arg2, arg3…) apply方法则传入的是数组，可以是任意长度的数组，而且传入的数组包括类数组对象。如foo.apply(this, arguments) 应用场景 我觉得这部分才是要深入理解的，何时去调用它们，使用它们有什么方便之处。 call和apply的用途是借用别人的方法来调用，或者说，是动态改变this这个对象。 前者或许更好理解。来看看这样一个例子。 123456789101112131415const a = { name: &apos;mdzz&apos;, say: (name) =&gt; { console.log(name) window.alert(`我是 ${name}`); }}const b = {};// b也是zz,但没有相应的say方法，所以此时b想借用a的方法。// 调用a的方法给b使用a.say.call(b);b.name = &apos;yrmdzz&apos;;// 传入参数时a.say.call(b, b.name);a.say.apply(b, [b.name]); 1234567891011121314151617181920212223242526272829303132333435363738394041/* 或者这样定义更为明显 */ function Foo(){}; // 添加原型属性 Foo.prototype = { name: &apos;mdzz&apos;, say: function() { console.log(this); // 当前调用的对象Foo alert(`I am ${this.name}`); } }// new 生成一个实例对象 const people = new Foo(); console.info(people); people.say(); // 定义一个没有say方法的对象animal // 让它调用people的say方法 const animal = { name: &apos;kitty&apos; } people.say.call(animal);/* 一个更显而易见的例子 */// 定义一个函数，可以判断传入参数的基本类型 function type(obj) { let toString = Object.prototype.toString; let map = [ &apos;[object Boolean]&apos;: &apos;boolean&apos;, &apos;[object Object]&apos;: &apos;Object&apos;, &apos;[object Array]&apos;: &apos;array&apos;, &apos;[object Number]&apos;: &apos;number&apos;, &apos;[object String]&apos;: &apos;string&apos;, &apos;[object RegExp]&apos;: &apos;regExp&apos;, &apos;[object Function]&apos;: &apos;function&apos;, &apos;[object Date]&apos;: &apos;data&apos;, &apos;[object Undefined]&apos;: &apos;undefined&apos;, &apos;[object Null]&apos;: &apos;null&apos;, ]; return map[toString.call(obj)];} 123456789101112131415161718192021222324252627/* 在参数不定时，则可使用apply */ // 这里的例子改写自权威指南 // 内置Math对象有一个max方法，接受任意个参数，返回其中的最大值 // 但有时我们调用时，无法预知参数的个数，而且这种取最大值的情况通常在数组中发生 // 假如有这样一个数组 let arr = [4,98,34,90,41,78]; // 直接Math.max会返回NaN,因为它不接受数组作为参数 Math.max(arr); // 返回NaN // apply方法接受数组作为参数 let biggest = Math.max.apply(Math, arr); console.info(biggest); // 98 // 第一个参数Math可以替换为任何其他值，如下的也都可以 let biggest2 = Math.max.apply(this, arr); let biggest3 = Math.max.apply(null, arr); console.info(biggest2); // 98 console.info(biggest3); // 98/* 还有一个比较有意思的apply使用场景 */ // 使用push方法来合并数组 let arrayA = [&apos;say&apos;, &apos;hello&apos;]; let arrayB = [&apos;ok&apos;, &apos;master&apos;]; Array.prototype.push.apply(arrayA, arrayB); // arrayA: [&apos;say&apos;, &apos;hello&apos;, &apos;ok&apos;, &apos;master&apos;] 所以我的理解是以下在两种情况下使用call(), apply(): 1.动态改变调用的对象，或者说使没有该方法的对象调用有该方法的对象的方法。 2.改变方法的传入参数为数组。 就目前看来，肯定还有更多的使用场景。但我还未遇到，等遇到或理解的更深一步的时候，再来补充。 参考： 《JavaScript权威指南》","link":"/2016/11/04/call-and-apply-difference-and-application/"},{"title":"chrome插件指南——程序员篇","text":"作为chrome重度用户，在日常工作中少不了用浏览器做些各种各样的事。作为一名前端攻城狮，也少不了用chrome进行开发和调试。这期我整理了部分自认为好用到飞起的插件，希望看到的人也喜欢，也和我一样爽到飞起。 插件列表 Vimium Octotree GitHub Awesome Autocomplete Vimium 有一个传说，说vim是编辑器之神。而我认识的使用vim的前端前辈们也都不是等闲之辈。这款插件就是让你使用vim的快捷键来操作页面。 它包含了日常对网页的几乎所有操作。如果你不熟悉，可以按下shift + ? 来查看所有快捷键。 为什么说它好用呢。首先键盘党一定会点赞，因为它可以让你手再也不用离开键盘去操作那烦人的鼠标。其次，想象一个使用场景——当你靠在沙发或床上，想要上下滑动页面，或者打开新页面，总免不了把手离开键盘，去使用鼠标。但这可是在床上，操作鼠标有诸多不便。也许你有mac，触控板的体验不错，但……如果你是windows,我相信这一定是件麻烦的事。 来看看快捷键一览： 页面滚动、打开新标签页、复制网址、打开书签、查看历史记录、快速跳转标签页、打开页面上的链接等等等等，你想要的，它全都拥有。 赶快去躺在床上试一试吧。 Octotree 作为一名程序猿，我想会有很多使用到Github的场景。不管是追求技术去看各种框架的源码，或是为了潮流去star一些新项目，或者甚至为开源项目贡献自己的一份力，都会离不开Github。 有一位我眼中的大神教授我，看项目不能仅仅满足于readme，要多看源码。但Github上查看源码需要在各个目录下跳转，有诸多不便，所以有了以下这款插件。 感受下，即插即用： 请暂且撇开这做作的字体和装逼的主题，只看左侧。 项目目录一览无余，加上一路直达这样的跳转是不是很完美，很方便。 Github Awesome Autocomplete 这是一个类似alfred的插件。用过alfred的相信没有几个不说好的。这个插件也类似。 先看看平常我们是怎么在Github上搜索的: 事实上，我并不想要这个搜索结果。想我堂堂大angular,怎么可能只有1W+的star…所以还必须要切换到best stars搜索，或者直接搜索angular.js才得到想要的结果。小弟无知，至今没搞明白这两个仓库有啥区别。 然而当我们使用插件后： 这样是不是一目了然，清爽许多?！ 小结 暂且先到这里，后续有补充再添加。 对了，别忘了先学会科学上网噢。","link":"/2016/09/18/chrome-plugins-for-coders/"},{"title":"CSS3 实现🎲旋转教程","text":"最近的工作开始接触到可视化的 3D 部分，因此自己也抽时间温习了以前学习的 css3 知识点，顺便完成一个入门小 demo —— 实现一个旋转的骰子。这个例子里有重温 css3 的一些知识点——用它来实现立体和旋转效果，然后用 flex 布局来实现骰子的点的排列。这个案例对于以后熟练使用 css 和 flex 有一定的帮助，所以这里也做一份教程和总结。最终效果就在页面右下角，相信眼不尖的人也注意到了。 索引 分解步骤 执行步骤 完整代码 分解步骤 要完成这个案例，我们先来分解实现过程，再按步骤一步一步来实现。 首先实现整体界面和骰子的基本界面，一共有六个面，包括面和点的基本样式。 然后实现每个面上的骰子点数排列布局，完成所有的界面。 使用 transform 实现立体形状，给骰子添加立体效果。 为骰子添加旋转动画效果。 执行步骤1. 基本界面 这一步很基础，直接看代码。 1234567891011121314151617181920212223.dice-content { position: relative; margin: 50px auto; width: 200px; height: 200px;}.dice-section { position: absolute; top: 0; left: 0; width: 200px; height: 200px; background-color: #e8e8e9; border: 1px solid #e0e0e0; border-radius: 15px;}.dice-point { width: 50px; height: 50px; border-radius: 50%; box-shadow: inset 3px 3px 5px black; background-color: #333;}123456789101112131415161718&lt;div id=&quot;dice&quot; class=&quot;dice&quot;&gt; &lt;div class=&quot;dice-content&quot;&gt; &lt;div class=&quot;dice-section&quot;&gt; &lt;!-- 这里为了使代码区分明显，点数用 span 来实现，因为在 flex 布局下它会以块级元素方式呈现 --&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;dice-section&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;dice-section&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 4、5、6等等 --&gt; &lt;/div&gt;&lt;/div&gt; 这是包了六个面的骰子的 div, 每个面的位置以绝对定位重叠在同一位置，便于之后修改。然后我在外层再放了一个 div 来实现定位、透视等效果，这点后续会再提到。 2. 点数排布 骰子每个面上的点数不一，每个面里面的点数的排列因此也不一样，但排列都是依循一定的规律。所以非常适合用 flex 布局来实现。 在点数布局中，我们主要使用了以下几个属性来实现——flex-direction、justify-content、align-item. 点数为 1 的情况最为简单，只要实现垂直居中。而 flex 实现垂直居中非常方便。align-items指定了 flex 容器中项目的对齐方式。所以父元素设置居中，子元素设置 auto 即可。 1234567.dice-section { display: flex; align-item: center;}.dice-point { margin: auto;} 点数 4 和 点数 6 的实现方式类似，首先它们被分割成 2 行。然后分别排列点数，分别显示在每一行的两侧。 123456789.dice-section { display: flex; flex-direction: column; justify-content: space-around;}.dice-section-row { display: flex; justify-content: space-around;}12345678910&lt;div class=&quot;dice-section&quot;&gt; &lt;div class=&quot;dice-section-row&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;dice-section-row&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 我们使用 space-around 项让行内元素均匀分布在行内。 这里值得注意的是我们对行也做了同样的处理，只不过是用 column 换了个方向，让行上下均匀分布在面上，撑满整个面，否则会挤在一块。 然后点数 2 和 点数 3 的实现方式类似，它们被分割成 2 行和 3 行。然后分别排列点数，分别显示在左中右的位置。 1234567891011121314151617.dice-section { display: flex; flex-direction: column; justify-content: space-around;}.dice-section-row-start { display: flex; justify-content: flex-start;}.dice-section-row-center { display: flex; justify-content: center;}.dice-section-row-end { display: flex; justify-content: flex-end;}123456789101112&lt;!-- 以点数 3 为例 --&gt;&lt;div class=&quot;dice-section&quot;&gt; &lt;div class=&quot;dice-section-row-start&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;dice-section-row-center&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;dice-section-row-end&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; flex-start、center、flex-end表明行内元素分别从行首、行中、行尾开始排列，这样使得点数正好分别排在行内的左中右位置。 同理，点数 5 的排列则是结合了 space-around 和 center 来实现。 到这里点数的骰子的界面基本完成，接下来是给骰子加上立体效果。 3. 立体效果 有两种方式可以让元素以 3D 效果方式呈现。 给父元素添加 transform-style: preserve-3d 告诉元素以 3D 方式呈现。它会影响子元素的呈现。 给父元素添加 perspective 属性，这个属性就是眼睛离画布的距离，值越小离画布越近，效果越明显(头越晕)。通常设置一个较大值来观察，这样更加清楚。 这里我们采用第一种方式。然后开始对每个面加以处理。 在旋转前需要一个原点作为参数，元素会围绕这个点旋转，在这里这个点是立方体的正中心。 1transform-origin: 50% 50% 0; /* 也是默认值 */ 我们使用 transform 属性的 rotate 来实现旋转，用 translate 来实现平移。 6个面里，前后面的改动是最小的。围绕着原点，那么正面需往前平移，然后背面要离正面一个面的长度大小，所以背面沿三维面的 Z 轴向后平移。 123456.dice-pos-front { transform: translateZ(100px);}.dice-pos-back { transform: translateZ(-100px);} 上下面的显示应当是沿 X 轴旋转，然后再位移，需注意旋转后基准的坐标系也变了，看似是上下沿着 Y 轴位移，实际是参照旋转前的 Z 轴位移。 123456.dice-pos-top { transform: rotateX(90deg) translateZ(100px);}.dice-pos-bottom { transform: rotateX(90deg) translateZ(-100px);} 左右面也是类似的道理。 123456.dice-pos-left { transform: rotateY(90deg) translateZ(100px);}.dice-pos-right { transform: rotateY(90deg) translateZ(-100px);} 到这里，一个完整的立方体效果应当出来了。但界面上可能还看不出，我们给这个立方体旋转一定角度，让它呈现得更立体一些。 123.dice-content { transform: rotateX(-30deg) rotateY(-40deg);} 效果如下: 4. 动画效果 css3 的动画从关键帧 keyiframe 开始，定义初始状态和结束状态。然后加以应用。 1234567891011121314/* 定义一个名为 rotate 的动画 */@keyframe rotate { from { transform: rotateX(-30deg) rotateY(-30deg) } to { transform: rotateX(180deg) rotateY(360deg) }}/* 然后应用，配置动画时长，动画效果等参数 */.dice-content { animation: rotate 10s infinite;} 到这里，最基本的一个旋转的骰子就实现了。 我们还可以通过 animation 的其他属性为这个旋转添加一点速度效果。 源码 我将常用的样式类提取了出来。 添加了 perspective 来增强效果。 添加 animation-timing-funtion 在各关键帧切换时添加速度效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .flex { display: flex; } .flex-column { flex-direction: column; } .jc-c { justify-content: center; } .jc-sa { justify-content: space-around; } .jc-fs { justify-content: flex-start; } .jc-fe { justify-content: flex-end; } .dice { perspective: 1000px; } .dice-content { /* 设定一个初始角度值以便查看效果 */ transform: rotateX(-30deg) rotateY(-40deg); position: relative; margin: 50px auto; width: 200px; height: 200px; transform-style: preserve-3d; -webkit-transform-style: preserve-3d; transform-origin: 50%; -webkit-transform-origin: 50%; animation: rotate 7s infinite; -webkit-animation: rotate 7s infinite; animation-timing-function: ease; -webkit-animation-timing-function: ease; } .dice-section { position: absolute; top: 0; left: 0; width: 200px; height: 200px; background-color: #e8e8e9; border: 1px solid #e0e0e0; border-radius: 15px; } .dice-point { width: 50px; height: 50px; border-radius: 50%; box-shadow: inset 3px 3px 5px black; background-color: #333; } /* 前后面不做翻转，只在 Z 轴坐标系上平移 */ .dice-pos-front { transform: translateZ(100px); } .dice-pos-back { transform: translateZ(-100px); } /* 上下面是沿 X 轴翻转并位移, 从效果上看是沿 Y 轴平移，但因为加了翻转效果，其实是在 Z 轴上平移 */ .dice-pos-top { align-items: center; transform: rotateX(90deg) translateZ(100px); } .dice-pos-top .dice-point { margin: auto; background-color: red; box-shadow: inset 3px 3px 5px #333; } .dice-pos-bottom { transform: rotateX(90deg) translateZ(-100px); } /* 左右面是沿 Y 轴翻转并位移, 从效果上看是沿 X 轴平移，但因为加了翻转效果，其实是在 Z 轴上平移 */ .dice-pos-left { transform: rotateY(90deg) translateZ(-100px); } .dice-pos-right { transform: rotateY(90deg) translateZ(100px); } /* 定义一个名为 rotate 的动画 */ @-webkit-keyframes rotate { 0% { transform: rotateX(-30deg) rotateY(-40deg) } 35% { transform: rotateX(180deg) rotateY(360deg) } 75% { transform: rotateX(-90deg) rotateY(-180deg) } 100% { transform: rotateX(30deg) rotateY(40deg) } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 纯 css3 实现  --&gt; &lt;div id=&quot;dice&quot; class=&quot;dice&quot; title=&quot; 点我就消失&quot;&gt; &lt;div class=&quot;dice-content&quot;&gt; &lt;!-- 1 --&gt; &lt;div class=&quot;dice-section dice-pos-top flex&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 2 --&gt; &lt;div class=&quot;dice-section dice-pos-left flex flex-column jc-sa&quot;&gt; &lt;div class=&quot;flex jc-fs&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-fe&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 --&gt; &lt;div class=&quot;dice-section dice-pos-front flex flex-column jc-sa&quot;&gt; &lt;div class=&quot;flex jc-fs&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-c&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-fe&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4 --&gt; &lt;div class=&quot;dice-section dice-pos-back flex flex-column jc-sa&quot;&gt; &lt;div class=&quot;flex jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 5 --&gt; &lt;div class=&quot;dice-section dice-pos-right flex flex-column jc-sa&quot;&gt; &lt;div class=&quot;flex jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-c&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 6 --&gt; &lt;div class=&quot;dice-section dice-pos-bottom flex jc-sa&quot;&gt; &lt;div class=&quot;flex flex-column jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;flex flex-column jc-sa&quot;&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;span class=&quot;dice-point&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考: 1. [transform(web)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform) 2. [transform(css)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transforms) 3. [flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex)","link":"/2017/09/23/css3d-study/"},{"title":"JavaScript数组去重","text":"整理了部分常用的数组去重方法。 ES3实现 采用和冒泡排序相似的思路，一一对比后将确定不重复的元素放入新数组。 123456789101112131415161718function unique(arr) { var res = []; for (var i = 0; i &lt; arr.length; i++) { var isUnique = true; // 标识该元素是否唯一 for (var j = i + 1; j &lt; arr.length - i; j++) { if (arr[i] === arr[j]) { isUnique = false; } } if (isUnique) { res.push(arr[i]); } } return res;}var arr = [0, 0, 1, 1, 2, &apos;2&apos;];unique(arr); ES5实现1.方法一：数组的indexOf方法——Array.prototype.indexOf 如果查找到的当前元素的位置和和实际位置相同，那么向新数组里添加。 12345678910function unique(arr) { let res = []; for (var i = 0; i &lt; arr.length; i++) { (arr.indexOf(arr[i]) === i) &amp;&amp; res.push(arr[i]); } return res;}var arr = [1, 1, 2, 2, 3];unique(arr); // [1, 2, 3]; 2.方法二：数组的filter方法——Array.prototype.filter 使用indexOf方法和ES5提供的数组方法filter, 返回查询到位置相应的元素12345678function unique(arr) { return arr.filter(function(value, index, array) { return array.indexOf(value) === index; })}var arr = [0, &apos;0&apos;, 0, 1, 1, &apos;1&apos;];unique(arr); // [0, &apos;0&apos;, 1, &apos;1&apos;]; filter方法接受一个函数，里面是判断条件，符合条件为true的数组元素组成一个数组，最终的返回这个数组。 123456789101112131415/** * [unique 数组去重，使用ES5的filter方法] * @param {[obj]} value [数组元素] * @param {[number]} index [索引值] * @param {[array]} arr [原始数组] * @return {[type]} [description] */function filter(value, index, arr) { return arr.indexOf(value) === index;}// 所以以上的去重函数可简化为：function unique(arr) { return arr.filter(filter);} 3.方法三：采用属性哈希值的方法.如果当前元素在对象中没有对应的属性存在，则设置该属性值为true. 该方法可以用于去重由纯数字类型的元素组成的数组。 123456789function unique(arr) { var obj = {}; return arr.filter(function(value) { return obj.hasOwnProperty(value) ? false : (obj[value] = true); });}var arr = [1, 1, 2, 2, 3];unique(arr); // [1, 2, 3]; 但是该方法无法判断含字符串类型的元素的内容, 因为对象的属性默认会保存为字符串类型。(该方法可能有限制，暂未发现) 1234567891011var arr = [1, 1, &apos;1&apos;, 2, &apos;2&apos;, 3];unique(arr); // [1, 2, 3]; 无法区分数字类型和字符串类型// 加上类型保存function unique(arr) { var obj = {}; return arr.filter(function(value) { return obj.hasOwnProperty(typeof(value) + value) ? false : (obj[typeof(value) + value] = true); });}unique(arr); // [1, &apos;1&apos;, 2, &apos;2&apos;, 3]; ES6实现1.方法一：Array.from与Set 首先使用Set定义一个没有重复值的可遍历对象。再使用ES6提供的数组方法from()将其转化为数组，或者使用扩展运算符...将其转化为数组。 123456function unique(arr) { return Array.from(new Set(arr));}const arr = [1, &quot;1&quot;, 1, 2, 2];unique(arr); // [1, &apos;1&apos;, 2]; 不会进行类型转换 这里使用了ES6提供的两种新的数据结构(Set和Map)之Set. 它类似于数组，但每个属性(值)都是唯一的。可使用构造函数Set生成。 Set有内置属性size，可以查看数组的长度。 12345678910// 数组作为参数传入const set = new Set([1, 2, 3, 4, 5, 5]);set.size; // 5// 类数组对象传入function getDivs() { return [...document.querySelectorAll(&apos;div&apos;)];}const set2= new Set(getDivs());set2.size; // 192 ​ ES6中，数组扩展了很多方法。这里用到了Array.from方法。它用于将两类对象转为真正的数组: 1.类似数组的对象(array-like-object) 2.可遍历(iterable)的对象,包括ES6新增的数据结构Set和Map 以上的Set则属于第二种，可遍历的对象。 2.方法二：扩展运算符(…)与Set 首先使用Set定义一个没有重复值的可遍历对象。再使用ES6新增的扩展运算符...将其转化为参数序列并作为数组的内容。 123456function unique(arr) { return [...new Set(arr)];}const arr = [0, &apos;0&apos;, 1, 1, 2, 2];unique(arr); // [0, &apos;0&apos;, 1, 2] 扩展运算符 ...用于实现将一个数组转化为逗号分隔的参数序列。 持续更新……","link":"/2016/12/05/duplicate-removal-algorithm-about-array/"},{"title":"eslint有关import/prefer-default-export报错的解决","text":"今天在配置eslint发现一个神奇的问题——采用airbnb风格的检查时有一个报错 *`error Prefer default export ...... import/prefer-default-export`* 查了半天资料终于发现如何解决。 解决 原来是这样 123export function runBlock($log) { $log.debug(&apos;runBlock end&apos;);} 运行eslint检查的时候一直会报错 error Prefer default export ...... import/prefer-default-export 查询了一些资料后发现是因为,这个单一接口并不是设置为默认的。需要添加参数default。 更改后如下 123export default function runBlock($log) { $log.debug(&apos;runBlock end&apos;);} 具体原因有待详细追究。目前认为是当输出只有一个变量时，需要添加default。 参考 es6… eslint-plugin-import","link":"/2016/08/08/eslint-about-import-prefer-default-export/"},{"title":"微信支付开发日志","text":"曾经有一项需求，是从移动端的H5页面请求微信支付功能。微信的文档写地较为混乱，在这里写个防坑指南。 支付的坑1.微信支付的文档不止一个。 在官方的文档里，有一段简单的关于微信支付的说明。调用wx.chooseWXPay方法启用。但是在这个文档之下，有另一个开发文档微信支付开发文档 这个文档里也有一个支付调用的方法weixinJSBridge，但是只能在微信浏览器里使用，非常不方便。本人测试从未成功过，所以建议放弃。 2.wx.chooseWXPay方法的传入参数和签名 该方法发起请求时是没有appId参数的，但是在生成paySign签名的时候，需要有appId和它的值。这里的I是大写的i。 生成paySign的时候的timeStamp是大写的，和传入的参数不一样，传入的是小写。 3.服务端的工作？！ 由于微信文档里没有说明哪些是前端工作哪些是后端，所以在一开始开发时我做了很多服务端做的事。比如生成signature, paySign.两者不一样。 生成签名的工作前端也是可以做的，但是要发起很多异步请求，处理非常多的回调，简直是回调地狱，而且不安全。最后服务端的伙伴处理了第一个签名。 注意两个access_token的不同。 微信公众号的准备工作1.微信公众号开通微信支付功能。 微信公众平台 微信支付-开发配置里配置支付授权目录。 正式授权目录可以添加多个，测试时只能添加一个。 不允许添加端口。只支持默认80端口。 目录即为调用微信支付空间的页面所在的目录。 将个人的微信号加到支付的白名单里，只有白名单里的用户才可以支付，但没想到付的是真钱。 同一个页面里，选择开发者配置，找到接口权限表。 网页授权用户基本信息。 这个url是用户回调的url,即开启微信支付控件页面的url,这个值即是redirect_url的值。 要记得encodeUrl转码。 进入公众号设置，功能设置 对js安全域名做设置。 这个值只能设置一个且似乎改动次数有限制。所以要小心改动。 上线前记得切换。 开发者中心里的配置项。 获取appId, secret等相关信息。 还有mch_id和key。 这些数据都不推荐写在前端页面里。 使用步骤 打开微信页面，从服务端的回调url里获取access_token, openId. 须服务端通过code验证等，然后返回。 获取wx.config配置需要的signature, 传递随机数nonceStr，时间戳timestamp等参数给服务端生成签名。 wx.config接口注入权限验证配置——通过signature等验证后。 通过openId获取prepay_id。 前端生成另一个签名paySign, 然后调用wx.ready里wx.chooseWXPay的方法调起支付。 Show Your the Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// ES6、jquery结合的写法.class WxpayCtrl { constructor() { this.access_token = this.getUrlParams().access_token; this.openId = this.getUrlParams().openId; this.appId = &apos;skidfoislkdrehjkgrg&apos;; this.key = &apos;sdkjgfgkgkhjishiduh&apos;; } /** * [getUrlParams 获取url的参数 querystring] * @return {Object} [一个url参数键值配对的对象] */ getUrlParams() { const url = window.location.search; const queryString = new Object(); if (url.indexOf(&apos;?&apos;) !== -1) { let str = url.substr(1); let strs = str.split(&apos;&amp;&apos;); for (let i = 0; i &lt; strs.length; i++) { queryString[strs[i].split(&apos;=&apos;)[0]] = decodeURI(strs[i].split(&apos;=&apos;)[1]); } } return queryString; } /** * [createTimestamp 时间戳] * @return {String} [description] */ createTimestamp () { return parseInt(new Date().getTime() / 1000) + &apos;&apos;; } /** * [createNonceStr 随机字符串] * @return {String} [description] */ createNonceStr() { return Math.random().toString(36).substr(2, 15); } /** * [getSignature 获取授权签名] * @return {String} [description] */ getSignature() { const promise = new Promise((resolve, reject) =&gt; { const data = { nonceStr: this.createNonceStr(), timestamp: this.createTimestamp(), url: window.location.href.split(&apos;#&apos;)[0], access_token: this.accessToken }; $.ajax({ url: `${url}/wechat/getSignature`, type: &apos;POST&apos;, data: JSON.stringify(data) }) .done((res) =&gt; { resolve(res); }) .fail((err) =&gt; { reject(err.message); }); }); return promise; } /** * [getPrepayId 用openId获取prepay_id， 和服务端协调后决定queryString] * @param {Number} cash [消费金额] * @return {String} [description] */ getPrepayId (cash=100) { const promise = new Promise((resolve, reject) =&gt; { const data = { amount: cash, openId: this.openId, type: &apos;JSAPI&apos;, nonceStr: this.createNonceStr() }; $.ajax({ url: `${url}/wechat/getPrepayId`, type: &apos;POST&apos;, data: JSON.stringify(data) }) .done((res) =&gt; { resolve(res.content); }) .fail((err) =&gt; { reject(err.message); }); }); return promise; } /** * [weiPay 微信支付，验证加最终支付] * @param {String} prepay_id [description] */ weiPay(prepay_id) { // 随机生成随机数，在不同地方调用的时候是不一样的，尤其注意！！！ const nonceStr = this.createNonceStr(); const stringA = `appId=${this.appId}&amp;nonceStr=${nonceStr}&amp;package=prepay_id=${prepay_id}&amp;signType=MD5&amp;timeStamp=${this.createTimestamp()}`; const stringSignTemp = `${stringA}&amp;key=${this.key}`; const sign = md5(stringSignTemp).toUpperCase(); wx.chooseWXPay({ timestamp: this.createTimestamp(), nonceStr: nonceStr, package: `prepay_id=${prepay_id}`, paySign: sign, signType: &apos;MD5&apos;, success: (res) =&gt; { if (res.errMsg === &apos;chooseWXPay:ok&apos;){ window.location.href = &apos;success.html&apos;; } }, fail: () =&gt; { window.alert(&apos;支付失败！&apos;); window.location.href = &apos;fail.html&apos;; }, cancel: () =&gt; { window.location.href = &apos;cancel.html&apos;; } }); } /** * [weixinPay 调起微信支付] * @return {[type]} [description] */ weixinPay(cash) { this.getSignature() .then((signature) =&gt; { /** * [appId 微信支付的相关配置,通过config接口注入权限验证配置] */ wx.config({ // debug: true, // 该选项仅用于调试 appId: this.appId, timestamp: this.createTimestamp(), nonceStr: this.createNonceStr(), signature: signature, jsApiList: [&apos;chooseWXPay&apos;] }); wx.ready(() =&gt; { this.getPrepayId(cash) .then((prepay_id) =&gt; { this.weiPay(prepay_id); }) .catch((err) =&gt; { window.alert(err); }); }); }) .catch((err) =&gt; { window.alert(err); }); }} 虽然这里有很多回调，代码也略凌乱，但它work了！ 当然有更好的方案，但紧急需求要求下这是较快的实现方式了。再次对接可让生成签名的工作移交服务端！ PS：经过这次对接微信支付文档后，对微信的开发失去了信心。然后对微信推出的小程序也坚持保守态度。 参考： * [接入微信支付流程清晰版](http://www.cnblogs.com/sunshq/p/5035163.html)","link":"/2016/12/22/fck-wechat-pay/"},{"title":"如何清除input元素自定义样式","text":"有注意到input在不同状态下，或者不同浏览器下都会有显示的问题。例如ios下的浏览器里input有边框显示问题，设置input属性appearance为none即可解决。但input仍然留下许多样式坑。 input(type=number)样式问题 当type的值设置为number时，聚焦状态下会出现一个小边框，如下图： 因强迫症和需求以及正常的审美观要求，一致确定去掉这个丑陋的多余项。 查阅部分资料后找到解决办法如下： 1234567input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; -moz-appearance: none; appearance: none; margin: 0; // Apparently some margin are still there even though it&apos;s hidden -清除margin。} 原理就是关闭input自带的number按钮选项。 input作为表单自动提交时 当input作为表单时，会自动记录之前的填写项，并自动补充，如果选择自动补充的选项，而且本身给input设置了样式时。画面就会非常唯美（丑陋）。 这里有两种解决方案： 1.修改自动填充的样式（推荐）: 12345678910111213// 使用以下样式来覆盖原有的，更改了背景和字体颜色input: -webkit-autofill,textarea: -webkit-autofill,select: -webkit-autofill { -webkit-box-shadow: 0 0 0 1000px #323339 inset; -webkit-text-fill-color: white;}// 覆盖以下的chrome自带样式input: -webkit-autofill, textarea: -webkit-autofill, select: -webkit-autofill { background-color: rgb(250, 255, 189); background-image: none; color: rgb(0, 0, 0);} 原理是通过打补丁来解决自定义样式——是不是优雅了很多~ 2.通过关闭表单的自动填充功能来彻底根除该问题： 1&lt;input type=&quot;number&quot; autocomplete=&quot;off&quot;/&gt; 这样就连提示也没有了~也是种解决办法。 参考：[Turn Off Number Input Spinners](https://css-tricks.com/snippets/css/turn-off-number-input-spinners/)","link":"/2016/10/01/how-to-clear-input-style/"},{"title":"如何在git仓库中彻底清除大文件","text":"坑的由来 事情是这样的，相信每个公司都有自己的官网。我们也不例外，而由于历史及各种不具名的原因，我司先前的程序猿哥哥将许多视频放在了代码仓库里。结果可想而知，原本只有代码的仓库突然间变得无比臃肿(或者是慢慢臃肿)，从早期的几十MB,迅速飙升至1G以上。眼看要挤爆服务器。这时我们总监看不下去了，大手一挥删了所有视频。仓库眼看瞬间缩小。但是，理论上是该缩小的，直到你不经意间瞄了眼——又多了一个G，这时你紧张了，慌了，明明删了视频，怎么仓库竟还变大了。 这一期，让我们走进git,细细体会git带给我们的欢乐与忧愁。 关于git 每个人都会有过去，git也不例外。git是个什么东西 到底发生了什么早些时候我对git的原理并不是很了解，只是随着日常使用，终于开始理解git其实是一个指针指向一次提交的对象，当你在各个分支间切换的时候，指针就随之切换，版本也随之更改。 那么，git 是如何做到的能在各个版本间无缝切换的呢。即使long long ago的代码，只要来一句git reset --hard sesd54f54sdf5sd4sd5f 照样给你打回原形。 真相只有一个，那就是其实所有的版本，不管是否存在了多久，都仍然存在于硬盘里。所以你才可以任性地对代码为所欲为。然而，为所欲为也要付出代价。 代价就是，你删了几次，就会有几个快照存在于硬盘里。删一个大视频，表面上少了500M空间，实则增加了一次至少500M的历史提交记录，虽然现在的代码仓库里不再有这个视频，但是你试试du -sh .git看看.git 文件大小，是不是有惊喜？我在这儿体会的最恐怖的一次，见证了3个多G的.git。 如何 solve it 首先我们看看git相关文件占用的空间，运行git count-objects -v 12345678count: 35size: 4404in-pack: 20775packs: 1size-pack: 1502667prune-packable: 0garbage: 1size-garbage: 136679 size-pack以千字节为单位表示，那么这里就有1.5G大小，这对代码仓库来说可是个恐怖的数字了。 那么让我们来找出罪魁祸首——到底是哪些大文件在混淆视听。 将所有含这些大文件的历史提交记录，一个不漏的找出来。 git verify-pack可以识别出大对象，使用sort参数对输出的5列信息排序，再进行定向 运行git verify-pack -v .git/objects/pack/pack-15esdkfdksjfd...asd.idx | sort -k 3 -n | tail -5 如果你的仓库确实有点臃肿的话，让代码飞一会儿。 得到以下结果: 12345b9e5fc1ea2a87e95ddea6fed47f29c184595485b blob 70580712 62447447 1360078567b8b3833e7f8e8207033b9f7e34e497a3207ecae2 blob 103319718 102366768 1157294281bc4f928a65692d19ab8d9378778463c13be7204c blob 117527265 117467079 102672811152565aeb9009bb4d07ca8d7c130425d9bf31f7b2 blob 201567615 181006235 78816222498c5dc977918aaf3b45a999ae92e031b4b15191b blob 590381017 589431074 198731150 unbelievable!都是huge的文件!最底下的那家伙，到底是什么啊！ 让我们用rev-list命令来查看commit 的 SHA值和文件路径： git rev-list --objects --all | grep 98c5dc9779 198c5dc977918aaf3b45a999ae92e031b4b15191b public/video/feng-mv.mp4 这次倒很快，答案揭晓——是公司宣传视频。我们明明有七牛。这玩意儿就不该出现在这里。 再来看看所有包含这家伙的提交历史: git log --pretty=oneline --branches -- public/video/feng.mp4 129364a4f65f03d3a6d0873106ba21bd3172418176 chore: 删除视频文件da24a01e46876a495518f9617501b4b360177f2b improve(官网首页) 一个大文件的一删一减两个操作，就会占据很多空间，更何况还有其他的较大文件。 找到了根源所在，是时候让我们大干一场: git filter-branch --index-filter &apos;git rm --ignore-unmatch --cached public/video/feng.mp4&apos; -- da24a01^.. 使用filter-branch重写所有相关的提交历史。 index-filter 修改暂存区域或索引。 git rm --cache 从git仓库里删除文件。 ignore-unmatch 忽略不匹配文件的提交记录，不会抛出错误。 最后一个哈希值指重写从这次提交开始的所有提交记录，避免索引所有的提交历史 好了，开始运行吧。一阵眼花缭乱的滚动之后，它宣布重写完成。 123...Rewrite 38f2b11070b7e21cbce465b5f6b384156e3a8e61 (475/475)Ref &apos;refs/heads/master&apos; was rewritten 此时的历史提交记录中已经不再会有指向那位大文件的引用了。 但仍然需要以下两条命令来删除refs对他的引用(关于这部分的理解我也有待深究)。 你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 .git/refs/original 通过 filter-branch 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据 库。 在重新打包前需要移除任何包含指向那些旧提交的指针的文件: 123456789rm -Rf .git/refs/originalrm -Rf .git/logs/git gcCounting objects: 21406, done.Delta compression using up to 4 threads.Compressing objects: 100% (9323/9323), done.Writing objects: 100% (21406/21406), done.Total 21406 (delta 11867), reused 20640 (delta 11348) 再看看节约了多少空间: 12345678910git count-objects -vwarning: garbage found: .git/objects/pack/tmp_pack_zG7GCbcount: 154size: 4884in-pack: 21406packs: 1size-pack: 1502752prune-packable: 0garbage: 1size-garbage: 136679 尽管表面上看去没有什么软用，但是当我运行du -sh .git查看大小时，发现. git文件夹确实缩小了。 现在这个视频文件存在于松散对象(size)中。虽然它没有彻底消失，但已经不再出现于推送或克隆中。 如果需要彻底移除，运行git prune --expire now。 再次查看 git count-objects -v。 小结 讲道理走到这一步应当是成功了，只是刚才运行git count-objects -v的结果并不那么尽如人意，它并没有缩减的很明显。 这点在以后解决成功时再另起一篇。 最后一点–作为一个前端攻城狮，可不能什么都往城墙里放啊!!!","link":"/2016/07/17/how-to-clear-huge-files-in-git/"},{"title":"初识 Threejs(下) —— 实现一个太阳系模型","text":"在上一篇文章中，我整理了 Threejs 中的一些基本概念。现在这一篇，就使用上次所整理的内容加上一些不复杂的算法，来实现一个运转着的太阳系模型。这里的所有行星大小及公转时间，尽量贴合实际。 索引 实现思路 场景初始化 创建行星 创建轨道 创建文本 行星添加公转效果 行星添加光照效果 鼠标交互事件 实现思路 这篇文章于早前发出，收到了前辈的指教。反思后发现确实后面的内容比较流水账，欠缺一个思路的总结和梳理，而只是一味实现。这里我先将整体的实现方案梳理出来，接着我们再分解并一步步去实现它。 我将其主要分为两个部分，静态的实现，以及动态的鼠标交互。 静态实现 太阳系模型的核心是八大行星围绕着太阳做公转运动。涉及到两点，一是运动，二是公转。运动使用动画即可完成。至于公转，实际上行星的运转是做椭圆周运动，我们在这里将其简化为圆周运动，那么核心就是计算圆周运动的坐标点。 那么实现这个静态的太阳系模型就有一定的思路了，首先我们用球体初始化行星，按照距离远近摆放在场景中。然后添加环状图形来当做轨道，辅助观察。接着文本采用外部引入的方式，加载后位置基本与行星相同，减去一定大小将其放在正上方。最后，将行星按照计算出的坐标信息，每一帧去设置位置。最终的效果就是动态的公转效果。 这里有几点值得注意： 字体在 Threejs 中需要另外加载，格外引入。 行星的初始化位置可以用随机的方式来分布，使其更真实。当然，有精力的话可以参考实际去计算坐标，摆放接近真实的位置。 后来在行星中添加了月亮，涉及的计算就是把以太阳左标为原点改为了以地球坐标为原点，其他计算方式则相同。 为行星添加光照效果，就是在太阳的位置上放一个点光源，然后在周围的地方摆放一个环境光光源优化视觉效果。 采用图片纹理的方式优化行星的视觉效果。 动态交互 场景基本完成后。我会添加一个鼠标交互，即鼠标移到行星位置上时，显示行星的名字。 这里主要的复杂点在于坐标系的转化。3d 的坐标系和浏览器平时的坐标系原点及坐标位置不一。这点在下文我详细说明。 场景初始化 首先，创建一个场景用来渲染这一切。 123456let scene = new THREE.Scene()let renderer = new THREE.WebGLRender()let camera = new THREE.Perpestive(40, this.el.clientHeight / this.el.clientWidth, 1, 500)renderer.setSize(this.el.clientHeight, this.el.clientWidth)this.el.appendChild(renderer.domElement)renderer.render(scene, camera) 创建行星 初始化各大星球，即创建球体。在参考了真实大小和距离后，我们尽量按接近真实的比例来创建。 首先我们创建一个对象数组来保存各星球的相关数据。包括名字，大小，位置，颜色等等属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const planets = [{ name: &apos;Sun&apos;, size: [5, 16, 16], dis: 0, pos: [0, 10, 0], color: 0xFFFFFF,}, { name: &apos;Mercury&apos;, size: [0.4, 10, 10], dis: 4, pos: [0, 10, 9], color: 0xFFFFFF, rev: 0.3,}, { name: &apos;Venus&apos;, size: [0.85, 10, 10], dis: 7.5, pos: [0, 10, 12.75], color: 0xFFFFFF, rev: 0.6,}, { name: &apos;Earth&apos;, size: [1, 10, 10], dis: 10, pos: [0, 10, 15], color: 0xFFFFFF, rev: 1,}, { name: &apos;Moon&apos;, size: [0.4, 10, 10], dis: 1, pos: [0, 10, 17], color: 0xC0C0C0, rev: 0.2,}, { name: &apos;Mars&apos;, size: [0.6, 10, 10], dis: 15, pos: [0, 10, 20], color: 0xFFFFFF, rev: 1.8,}, { name: &apos;Jupiter&apos;, size: [4, 32, 32], dis: 20, pos: [0, 10, 25], color: 0xFFFFFF, rev: 5}, { name: &apos;Saturn&apos;, size: [3, 32, 32], dis: 25, pos: [0, 10, 30], color: 0xFFFFFF, rev: 10}, { name: &apos;Uranus&apos;, size: [2, 32, 32], dis: 30, pos: [0, 10, 36], color: 0xFFFFFF, rev: 15}, { name: &apos;Neptune&apos;, size: [1.8, 32, 32], dis: 35, pos: [0, 10, 45], color: 0xFFFFFF, rev: 0.5}] 根据这些属性，我们再用形状和材质来创建球体。 12345function initPlanet(size, color) { const sphereGeometry = new THREE.SphereGeometry(...size) const sphereMaterial = new THREE.MeshBasicMaterial({ color }) return new THREE.Mesh(sphereGeometry, sphereMaterial)} 这里我采用遍历数组的数据的方式来依次创建球体。并用一个 THREE.Group 对象来统一保存。 在初始化的数据里，我们可以拿到位置等信息，在这里给球体也加上相应的位置。 123456789101112function initPlanets() { let planetsGroup = new THREE.Group() planets.map((planetObj) =&gt; { const planet = initPlanet(planetObj.size, planetObj.color) planet.name = planetObj.name planetsGroup.add(planet) }) return planetsGroup}const planetsGroup = this.initPlanets()scene.add(planetsGroup) 场景中添加球体物体后，理论上应该能看到九个球体了。但是，这里只能见到一个球体。因为像机的默认视角是正对着球，而此时的球的位置正好连成一条线。我们来调整一下，让相机从高处俯视。 12camera.position.set(0, 10, 20)camera.lookAt(scene.position) 创建轨道 为了更清晰得看清行星运转，我们添加一些轨道线来辅助。 所用的是 RingGeometry 几何形状。创建的方式类似行星。 但是需要注意的是，创建的环默认是垂直于水平面的，我们需要将它做一个旋转，转到水平面上来。 1234567891011121314151617181920212223function initTrack(size, color) { const ringGeometry = new THREE.RingGeometry() const ringMaterial = new THREE.MeshBasicMaterial({ color }) return new THREE.Mesh(ringGeometry, ringMaterial) // todo}// 统一创建 function initTracks(){ let tracksGroup = new THREE.Group() planets.map((planet) =&gt; { const outer = planet.pos[2] const inner = outer - 0.05 const size = [outer, inner, 100] const track = this.initTrack(size, 0xffffff) track.rotation.x = Math.PI * 0.5 track.position.set(0, 10, 0) tracksGroup.add(track) }) return tracksGroup}const tracksGroup = this.initTracks()scene.add(tracksGroup) 这样就可以在场景中看到行星在轨道上了。 创建文本 我们使用文本来标识行星的名字，位置在行星正上方。 THREE 创建文本需要先加载字体。通常使用字体是先通过官方的方法加载 json 文件。 1234const textLoader = new THREE.FontLoader()textLoader.load(&apos;./assets/fonts/helvetiker_regular.typeface.json&apos;, (font) =&gt; { // do sth}) 在自己的案例中，parcel 打包后似乎没有静态文件目录，于是这里了解了下 THREE.Font 部分代码后，发现只需要重新构造一个就可以。 1234567891011121314151617import Font from &apos;./assets/fonts/helvetiker_regular.typeface.json&apos;const font = new THREE.Font(Font)// 封装一下function loadFont() { return new THREE.Font(Font)}// 除去字体包以外，字体还有一些必要的样式function initFont() { return Object.assign({ size: 0.5, height: 0, curveSegments: 12, bevelEnabled: false, bevelThickness: 1, bevelSize: 0.8 }, { font: loadFont() })} 最终创建文本的方式和其他物体相似，也是形状和纹理。 12345function initText(content) { const textGeometry = new THREE.TextGeometry(content, initFont()) const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }) return new THREE.Mesh(textGeometry, textMaterial)} 最后，只要让文本使用对应行星的位置，再做一些小小的位移即可。 行星添加公转效果 在场景里添加以上图形后，我们能看到部分物体了，虽然可能位置有部分重叠。现在我们来给每个行星添加动态效果，让所有行星运转。 公转的本质是改变行星的坐标位置，每一帧进行一次重定位，那么球体看起来就是运动的。 这里的公转，就是围绕太阳做圆周运动，以太阳为中心，距离为半径，圆周上的点就是位置。所以每个行星的位置计算就是半径和弧度的计算。 例如距离为 5 的星球，圆周长则为 2π * r, 即 Math.PI * 2 * 5，计算每帧的弧度则为 2π * r / 60 / 60 / r 即 Math.PI * 2 * 5 / 60 / 60 / 5. 所有行星在同一水平面，所以 y 的坐标固定，具体的位置就是 Math.sin(Math.PI * 2 / 3600) * r, 5, Math.cos(Math.PI * 2 / 3600) * r 因为每个行星的公转速度不一，所以我们再加一个变量来控制速度，整理后如下 123456789function calcSpeed(rev) { return Math.PI * 2 / 3600 / rev}// 然后来调用动画的函数里执行planetsGroup.children.map((planet) =&gt; { planet.angle += calcSpeed(planet.rev) planet.angle = planet.angle &gt; 2 * Math.PI ? planet.angle - 2 * Math.PI : planet.angle planet.position.set(Math.sin(planet.angle) * planet.distance, 5, Math.cos(planet.angle) * planet.distance)}) 文字的移动效果同行星，只是位置要在行星的上方，并且水平方向上减去文本大小的一半。 12const r = text &amp;&amp; text.geometry &amp;&amp; text.geometry.boundingSphere.radius || 0text.position.set(Math.sin(planet.angle) * planet.distance - r, 5 + 1, Math.cos(planet.angle) * planet.distance) 行星添加光照效果 为了使行星看起来更加真实，我们使用另一种材质来创建行星。并给太阳一个光照效果。 123456789// 受光照影响的材质const planetMaterial = new THREE.MeshLambertMaterial({ color: 0x123321 })// 添加一个白色，光照强度为 1，光照距离为 100 的点光源，位置在太阳中心const pointLight = new THREE.PointLight(0xffffff, 1, 100)// 再添加一点环境光，使我们可以更清楚的观察所有行星const ambient = new THREE.AmbientLight(0xffffff, 0.7)pointLight.position.set(Sun.position)scene.add(pointLight)scene.add(ambientLight) 至此，一个有点像模像样的太阳系微缩模型完成了。 接下来我们为这个模型加点动态交互效果。 场景添加鼠标事件 我们在这里做一个较为简易的交互，即鼠标移到相应的行星上就显示该行星的名字。 3d 空间中，鼠标的交互事件的本质是获取鼠标点的坐标，然后转化为 3d 坐标系里的坐标，然后判断位置是否在物体内，然后做一些处理。 这部分的重点就在于将鼠标坐标转化为 3d 坐标系里的坐标。即坐标换算。 首先我们要创建一个鼠标对象，然后获取鼠标的坐标。 12345let mouse = new THREE.Vector2()function onDomMouseMove(event) { console.info(event.clientX, event.clientY)}this.el.addEventListener(&apos;mousemove&apos;, onDomMouseMove) 3d 坐标系的不同在于他是以场景中心作为原点的。而鼠标坐标是以左上角为原点的。转换后要将坐标赋值给鼠标对象。所以这里的坐标换算计算公式为： 123456789101112function onDomMouseMove(event) { mouse.x = (this.el.clientX - (this.el.getBoundingClientRect().width / 2)) / (this.el.getBoundingClientRect().width / 2)}mouse.y = - (this.el.clientY - this.el.getBoundingClientRect().height / 2)) / (this.el.getBoundingClientRect().height / 2)// 优化后function onDomMouseMove(event) { const rect = this.el.getBoundingClientRect() const { width, height } = rect mouse.x = (2 * this.el.clientX - width) / width mouse.y = - (2 * this.el.clientY - height) / height} 获取场景中的鼠标位置后。接下去就是判断位置是否在物体上。这里的逻辑是，由相机发往一个射线到鼠标位置处，期间相交的第一个物体就是鼠标点中的物体。即 raycatser 对象中。 1234567let raycaster = new THREE.Raycaster()raycaster.setFromCamera(mouse, camera)// 获取相交的所有物体const intersects = raycaster.instersectObjects(scene.children, true)if (intersects.length &gt; 0 &amp;&amp; intersects[0].object &amp;&amp; intersects[0].object instanceof THREE.Mesh) { // do sth} 现在我们已经能获取到鼠标位置所在的物体了。剩下是完成这个交互，先将文字默认隐藏，然后在鼠标滑过的时候再显示出来。 首先将文本存在同一个组里，便于查找。然后在鼠标滑过行星时，使用行星名字来找出对应的文本，然后显示。 1234567891011121314151617181920function initTexts() { let textGroup = new THREE.Group() planets.map((planet) =&gt; { let text = initText(planet.name) text.visible = false textGroup.add(text) }) return textGroup}// 显示文本逻辑if (intersects.length &gt; 0 &amp;&amp; intersects[0].object &amp;&amp; intersects[0].object instanceof THREE.Mesh &amp;&amp; intersects[0].object.name) { const name = intersects[0].object.name scene.children.map((obj) =&gt; { if (obj.name !== &apos;texts&apos;) { return } obj.children.map((text) =&gt; { text.visible = text.name === name }) })} 到这儿一个差不多的太阳系模型就完成啦。 后续还可以给各行星的初始位置添加随机位置，给行星添加纹理效果，给土星加上土星环，给地球加上月亮，再加上些星星背景，那就挺好看了。 具体的代码在这里threejs-learning 最终效果 gif 显示的较为简陋。当然，更清楚的效果还是直接跑项目吧~","link":"/2017/12/19/how-to-create-a-solar-system-using-by-threejs/"},{"title":"15 分钟快速上手 Parcel 中使用 React","text":"最近准备新开一个 Threejs 学习的坑，因为重点在 Threejs 上，所以想构建一个简易方便的环境。于是我自然而然的想到了最近火热的 parcel 来替代以往的 webpack. 在我自己尝试了之后，这简直比我想象中的还要简单方便——当然是指搭建一个基本环境啦。推荐：★★☆ 索引 确立技术栈 安装依赖 快速上手 技术栈 parcel 支持 node v8.0.0 +. 所以我们使用 node v8.0.0 当然也少不了框架 react. 所以使用 react 16.0.0+. npm 使用有些显老了，不如试试 yarn. 至于 parcel, 当然也是与时俱进用最新的了。 所以最终确认下技术栈和版本。 1234node v8.0.0react v16.2.0yarn v1.3.2parcel v1.4.1 安装依赖 mkdir [your project] —— 在一个合适的目录下新建个项目。 yarn init 初始化新项目，一顿回车后即完成。 PS： 如果 node 版本不够的话，先升级 node, nvm install v8.0.0 nvm use v8.0.0. 然后升级 yarn. 卸载后重装。npm uninstall -g yarn. 再 npm install -g yarn. 接下来是安装一些 react 依赖。 yarn add react@16.2.0 yarn add react-dom@16.2.0 yarn add prop-types 当然也少不了 babel 来编译 es6, es7 等。 yarn add babel-preset-env 用于 es6. yarn add babel-preset-react 用于 react. yarn add babel-preset-stage-0 用于 es7. 接着就是重头啦。 yarn add parcel-bundler@1.4.1 这顿操作之后，依赖已经加载完毕。 快速上手 配置 .babelrc 文件来使用 babel。 123{ &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;, &quot;stage-0&quot;]} 配置首页入口。 12345678&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;src/index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 配置 js 文件。使用 react. 12345678910111213141516import React, { Component } from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;import PropTypes from &apos;prop-types&apos;class Hello extends Component { static propTypes = { name: PropTypes.string } render() { return &lt;div&gt; hello { this.props.name }&lt;/div&gt; }}const app = document.querySelector(&apos;#app&apos;)ReactDOM.render(&lt;Hello name=&apos;world&apos;/&gt;, app) 这样就已经接近完成。 剩下的，只要在 package 中加上 scripts. 123&quot;scripts&quot;: { &quot;start&quot;: &quot;parcel index.html&quot;} 最终只要在项目下运行 npm start，再打开 open http://localhost:1234. 几乎是一眨眼的功夫，就可以看到 hello world 了。 是不是非常快捷而简单呢。 项目地址: threejs-learning附上官网链接: Parcel","link":"/2018/01/07/how-to-use-parcel-with-react-in-15-mins/"},{"title":"从 zsh 到 fish, 让你的 shell 更可爱更友好","text":"前阵子关注到阮老师更新了一篇博文，内容是介绍一个 shell —— fish.自己去尝试之后发现确实值得推荐，准备当做主力 shell 来替代原有的 zsh. 索引 介绍 安装(想吃热豆腐的点这里) 介绍为什么抛弃 zsh 投向 fish 的怀抱 zsh 作为我的主力 shell 用了很久，而且没有什么做不到，那为什么我要抛弃呢。这并不是恋爱中的喜新厌旧。也并不是 zsh 不好，而是 fish 太好了。在简短的试用之后，我决定留下它。因为体验实在是太丝滑流畅了。 这里列几点最直观的感受。 1. 自动补全和自动建议 zsh 固然有着强大的自动补全命令。不过和 fish 相比，就是小巫见大巫了。fish 的命令，除了在自动补全以外，还会标记命令的对错，输入命令的正确与否，通过颜色显示地一目了然。这里因为配色的关系，颜色对比可能不明显，但仍可以看到，红色清楚的标识了无效命令。 下面这张图显示的是有效命令： 细心的朋友可能还发现了刚才图中灰色的完整命令。这属于 fish 的自动建议。下面这张图可能显示地更直观(点击查看大图)： 尽管 zsh 有着模糊匹配历史命令的功能，但显而易见，这里的 fish 在你输入第一个字母就知道你要做什么的体贴，让用户体验有了极大的提升。就像贴心的女友，知心的姐姐一样为你包办所有。 除此之外，fish 在匹配历史命令的同时，也能标识无效命令。红色醒目地标出： 2. 效率 使用终端 shell 的一大原因，就是效率高。有时有人问我，为什么明明有 git 图形化工具，却还要使用命令行。我想来想去，虽然图形化工具显示直观，但比起命令行，操作起来太慢，况且有许多命令并不支持。 那么既然使用 shell 本身就是为了提升效率，那怎么能忍受一个速度奇慢的 shell 呢。这里的两幅图清晰地说明了各自的效率： 在两种 shell 下连续按下回车键，可以看到以上两个结果。前者是 fish, 后者是 zsh. 可以看到后者有明显的卡顿。也许正是因为 zsh 过于强大，功能过多，导致运行起来奇慢无比。最终让我无法忍受。 小结 对我个人来说，以上两点足够我切换 zsh 到 fish 了。也许其他人有着自己的看法，但我目前还没有发现 fish 使我不爽的地方，因此近期会继续用下去。 安装和使用安装 fish 在 macOS 下，安装有多种方式，这里列出采用 homebrew 安装的方式，十分简便。 1$ brew install fish 安装成功后，输入 fish 后，就可以开启全新的奇妙历程了。 如果你已经迫不及待想要把他设为默认 shell 的话： 1chsh -s /usr/local/bin/fish 假如有提示说 fish 并不是标准 shell. 运行如下命令将 fish 加到系统的默认 shells 中。再运行上面的命令设置即可。 1echo /usr/local/bin/fish | sudo tee -a /etc/shells 设置完之后，重启你的 iterm/terminal, 就能看到全新的 fish shell 了！ 使用 fish 的基本配置在 ~/.config/fish/config.fish 文件里. 如果安装好 fish 后没有这个文件，可以新建一个。 fish 支持通过 web 界面更改配置文件。运行 fish_config 可查看。 可以通过更改如下配置来设置 fish 的问候语，它会在每次进入时输出。 1set fish_greeting &apos;Talk is cheap. Show me the code.&apos; zsh 有许多好用的 alias, fish 同样可以。最快捷的方式也是在配置文件里直接输入，以下是我的 git alias. 如果你和我一样是前端，那么很有可能也使用 nvm 来管理 node. fish 没有相关的工具，不过可以通过更改配置来使其生效。 1bass source ~/.nvm/nvm.sh 也许你在 zsh 中安装了 thefuck 插件，是的，在 fish 中也可以使用。 12eval(thefuck --alias | tr &apos;\\n&apos; &apos;;&apos;)alias fuck-it=&apos;export THEFUCK_REQUIRE_CONFITMATION=True; fuck; export THEFUCK_REQUIRE_CONFIRMATION=False&apos; 也许你也装了 autojump 插件，是的，同样可以在这里使用。加入以下代码： 123456begin set --local AUTOJUMP_PATH $HOME/autojump/bin/autojump.fish if test -e $AUTOJUMP_PATH source $AUTOJUMP_PATH endend 这里主要是核对 autojump.fish 这个文件。路径对即可生效。 如果以上两个插件还未安装的话，首先使用 homebrew 安装即可，brew install thefuck, brew install autojump. 一些工具oh my fish 和 zsh 有着 oh my zsh 一样，fish 也有 oh my fish. 可以在终端中输入如下命令安装： 1curl -L https://get.oh-my.fish | fish oh my fish 通过运行 omf install [&lt;name&gt;/&lt;url&gt;] 来安装插件。例如运行 omf install ocean 安装主题。 omf list: 列出当前安装的包。 omf theme &lt;theme&gt;: 列出所有主题/应用某个主题。 omf remove &lt;name&gt;: 移除某个包。 fisherman fish 还有一个管理插件的工具 fisherman. 直接在终端中运行如下命令安装： 1curl -Lo ~/.config/fish/functions/fisher.fish --create-dirs git.io/fisher fisherman 通过运行 fisher &lt;name&gt; 安装插件。例如运行 fisher z. fisher ls: 查看当前插件。 fisher ls-remote: 查看所有插件。 fisher rm &lt;name&gt;: 移除插件。 总结 以上就是我使用 fish 的记录和基本教程。事实上还有很多地方可探索，不过到此为止日常使用是没有问题了。希望大家也可以在使用 fish 的过程中感到愉悦快乐！","link":"/2017/05/21/introduce-fish-shell/"},{"title":"js诞生与ES6","text":"1.JavaScript JavaScript，一种直译式脚本语言，是一种动态类型、基于原型的语言，内置支持类别。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。然而现在JavaScript也可被用于网络服务器，如Node.js。 在1995年时，由网景公司的布兰登·艾克，在网景导航者浏览器上首次设计实现而成。因为网景公司与昇阳公司的营销合作，加上网景公司管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语义与Self及Scheme较为接近。 为了获取技术优势，微软推出了JScript，与JavaScript同样可在浏览器上运行。为了统一规格，1997年，在ECMA（欧洲计算机制造商协会）的协调下，由网景、昇阳、微软和Borland公司组成的工作组确定统一标准：ECMA-262。因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。 2.JavaScript 定义一般来说，完整的JavaScript包括以下几个部分： ECMAScript，描述了该语言的语法和基本对象文档对象模型（DOM），描述处理网页内容的方法和接口浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口它的基本特点如下： 是一种解释性脚本语言（代码不进行预编译）。主要用来向HTML页面添加交互行为。可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。JavaScript常用来完成以下任务： 嵌入动态文本于HTML页面对浏览器事件作出响应读写HTML元素在数据被提交到服务器之前验证数据检测访客的浏览器信息控制cookies，包括创建和修改等 3.JavaScript 起源它最初由网景公司的布兰登·艾克设计。JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型(dom)，浏览器对象模型(bom)。 Netscape在最初将其脚本语言命名为LiveScript，后来网景在与昇阳公司合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时网景为了营销考虑与太阳微系统达成协议的结果。为了获取技术优势，微软推出了JScript来迎战JavaScript的脚本语言。为了互用性，Ecma国际（前身为欧洲计算机制造商协会）创建了ECMA-262标准（ECMAScript）。现在两者都属于ECMAScript的实现。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。 发展初期，JavaScript的标准并未确定，同期有网景的JavaScript，微软的JScript三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。 4.ECMAScript 与 JavaScript一个常见的问题是，ECMAScript和JavaScript到底是什么关系？ 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。在日常场合，这两个词是可以互换的。 5.ECMAScript历史与ES6ES6从开始制定到最后发布，整整用了15年。 前面提到，ECMAScript 1.0是1997年发布的，接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。 2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但是它的大部分内容被ES6继承了。因此，ES6制定的起点其实是2000年。 为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。 2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。 2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。 2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。 2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。 2015年6月，ECMAScript 6正式通过，成为国际标准。从2000年算起，这时已经过去了15年。 我们最常写的原生js即是基于ES3和ES5。目前所有主流浏览器都支持ES3、ES6。各大浏览器也在不断更新， 支持ES6。 6.ECMAScript 72013年3月，ES6的草案封闭，不再接受新功能了。新的功能将被加入ES7。 任何人都可以向TC39提案，从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。 Stage 0 - Strawman（展示阶段）Stage 1 - Proposal（征求意见阶段）Stage 2 - Draft（草案阶段）Stage 3 - Candidate（候选人阶段）Stage 4 - Finished（定案阶段）一个提案只要能进入Stage 2，就差不多等于肯定会包括在ES7里面。 7.Babel转码器Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。","link":"/2016/06/20/js-and-ES6/"},{"title":"聊聊你所不知道的 JSON","text":"JSON 很常用，但它的某些属性，并不常用，却挺好用的。推荐：★★★ JSON 语法 解析与序列化 应用场景 小结&amp;延伸 JSONJSON 是前端中非常常见的数据格式。现在常用来定义配置文件，或者与后端交互。它是 javascript 的子集。 与 Javascript 不同之处在于 它的语法里只有三种格式，简单值，对象，数组。 没有声明变量。 简单值里的字符串，和对象中的所有属性名必须以双引号包裹。 简单值 对应 js 中的数字，字符串，布尔值，null, 但不包括 undefined. 字符串需要用双引号包裹：&quot;hello&quot; 数字：5 对象 几乎和 js 中的对象是一样的。只是它不需要声明变量。 { &quot;name&quot;: &quot;bob&quot; } 数组 [1, 2, null, &quot;hello&quot;] 和 js 没有差别。同样不需要声明变量。 解析与序列化JSON.stringify() 这个是非常常见的方法，传递数据的时候常常需要用到，它的作用是将 js 变量进行序列化。 123456const params = { name: &apos;bob&apos;, phone: 123123}const data = JSON.stringify(params) 我们通常只用到第一个参数。实际上 JSON.stringify 方法接收三个参数。 过滤器 第二个参数用于过滤，接收数组或函数的形式。 当参数是数组时，会过滤掉其他的属性， 只取到数组内属性所对应的内容。如下： 12345678910const book = { title: &apos;Professional javascript&apos;, authors: [&apos;Nico&apos;], edition: 3, year: 2011}const bookCopy = JSON.stringify(book, [&apos;edition&apos;, authors])console.info(bookCopy)// output &quot;{&quot;title&quot;: &apos;Professional javascript&apos;,&quot;authors&quot;:[&quot;Nico&quot;],&quot;edition&quot;:3, &quot;year&quot;: 2011}&quot; 而如果参数是函数，那么就可以直接改变对象中的属性值。 函数接受 key, value 两个参数，对应属性名和属性值。 可以据此进行值的操作，例如过滤值或者更新值。 12345678910111213141516/** * [replacer description] * @param {String} key [键] * @param {[type]} value [值] * @return {[type]} [description] */function replacer(key, value) { if (key === &apos;title&apos; || key === &apos;authors&apos;) { return &apos;&apos; } return value}const bookCopy2 = JSON.stringify(book, replacer)console.info(bookCopy2)// output { &quot;edition&quot;: 3, &quot;year&quot;: 2011 } 当然要对其他格式的值调用序列化，并传入第二个参数也没有问题。只是没有效果罢了。会如实返回。 JSON.stringify(1, [&quot;name&quot;]) JSON.stringify(&quot;hello&quot;, [&quot;name&quot;]) 字符串缩进 序列化的第三个参数，则是对应着缩进数。 通常我们以 2 格或四格为缩进。那么代码便是这样的。 JSON.stringify(book, null, 2) JSON.stringify(book, null, 4) 传入更大的值也不是不可以，但最终它都会转换为 10. JSON.stringify(book, null, 200) 和 JSON.stringify(book, null, 10) 效果是一样的。 有意思的是，它还接受字符串作为参数，字符串的长度对应着缩进数。例如可以这样 JSON.stringify(book, null, &apos;aaaa&apos;) 这样：JSON.stringify(book, null, &apos;--&apos;) 甚至这样也没问题：JSON.stringify(book, null, &apos;长日&apos;) 而且输出时是换行显示的。在调试时非常方便。 以下分别是字符串缩进设置为 10 和字符串的效果。 123456789101112131415161718192021222324&quot;{ &quot;title&quot;: &quot;Professional javascript&quot;, &quot;authors&quot;: [ &quot;Nico&quot; ], &quot;edition&quot;: 3, &quot;year&quot;: 2011}&quot;&quot;{--&quot;title&quot;: &quot;Professional javascript&quot;,--&quot;authors&quot;: [----&quot;Nico&quot;--],--&quot;edition&quot;: 3,--&quot;year&quot;: 2011}&quot;&quot;{长日&quot;title&quot;: &quot;Professional javascript&quot;,长日&quot;authors&quot;: [长日长日&quot;Nico&quot;长日],长日&quot;edition&quot;: 3,长日&quot;year&quot;: 2011}&quot; toJSON 作为对象的方法存在， 自定义 json 的返回值。优先级比第二个参数高。 如下，只取出 title 属性. 1234567891011const bookToJSON = { title: &quot;Professional javascript&quot;, authors: [&quot;Nico&quot;], edition: 3, year: 2011, toJSON: function () { return this.title }}JSON.stringify(bookToJSON)// output &quot;Professional javascript&quot; JSON.parse() 解析方法用来还原序列化后的对象字符串。 除了常用的第一个参数外，同样有一个类似的转换器参数。 但只接收函数形式，和上文提到的函数过滤器，形参是一样的。 它可以用来做如下的操作。 123456789const book = { title: &apos;Professional javascript&apos;, authors: [&apos;Nico&apos;], releaseDate: new Date(2019, 11, 25)}const bookCopy3 = JSON.stringify(book)console.info(bookCopy3)// output &quot;{&quot;authors&quot;:[&quot;Nico&quot;],&quot;edition&quot;:3}&quot; 平平无奇，除了日期看起来是字符串了。 这时候可以应用 JSON.parse 的转换器方法了。把日期字符串转换回日期对象。 1234567891011121314/** * [reviver description] * @param {String} key [键] * @param {[type]} value [值] * @return {[type]} [description] */function reviver(key, value) { if (key === &apos;releaseDate&apos;) { return new Date(value) } return value}// 转换回日期对象console.info(JSON.parse(bookCopy3, reviver)) 应用场景 上述介绍的方法属性，有的适合调试，有的适合操作数据。 JSON.stringify 字符串缩进的能力对日志调试时有很好的帮助，让日志更加直观。 过滤器则可以应用在实际业务中。有如下场景： 搜索页面，可以传入许多参数。 后端接收参数，只接收 null 和相应的数据格式，否则会报错。 而前端的数据有时是 &apos;&apos;, 有时是 undefined. 需统一处理成 null. 如果对象属性不涉及多层，可以用函数过滤器的方式实现。 12345678function replacer(key, value) { if (value === &apos;&apos; || value === undefined) { return null; } return value}const newData = JSON.stringify(data, replacer)// 新数据中会转化空数据为 null 过滤器类似的应用还有，如果想从对象里取出某些属性值，这时数组过滤器可以实现。 123456789101112131415161718/** * [pickPropsFromObjByArray 取出某些属性，这里为了表明功能，刻意取得比较长的名字] * @param {Object} obj [description] * @param {Array} props [description] * @return {[type]} [description] */function pickPropsFromObjByArray(obj = {}, props = []) { return JSON.parse(JSON.stringify(obj, [...props]))}const book = { title: &apos;Professional javascript&apos;, authors: [&apos;Nico&apos;], edition: 3, year: 2011}pickPropsFromObjByArray(book, [&apos;authors&apos;, &apos;edition&apos;])// output {authors: [&quot;Nico&quot;], edition: 3} 如果用过 lodash, 这个方法是不是很熟悉。 像极了 _.pick 方法。 小结&amp;延伸 JSON 自带的方法其实还有多种玩法，只是我们平时不常用。 了解上述方法以后，对日常调试和开发，是有一定的帮助的。 其他延伸： 如何手动实现 JSON.stringify 如何用 JSON.stringify 实现深拷贝","link":"/2019/11/26/learning-about-json/"},{"title":"单测入门笔记","text":"以前因为技术氛围和开发需求等种种原因限制，还没有写过单元测试。近期入职一家技术氛围较好，并且推崇单测的公司。所以也有必要了解和熟悉下单测(单元测试)。推荐：★★★ 索引 单测是什么 单测框架概览 上手 Jest 断言 使用匹配器 测试异步代码 测试回调 测试Promise .resolves/.rejects async/await 在 React 中使用 小结 Issues 单测是什么 单测是至对程序中最小单元的验证和检查。具体化些，就是对一个模块，一个函数的验证。再应用到 React 项目中，通常是对 reducer 的验证。 单测框架概览 js 的单测框架选择也并不少，常用的有 Mocha，Jest，Jasmine 等。最近的项目里主要是 Jest 和 Mocha，其中 Jest 更多。下面说下自己对这两者的区别的一些初步理解。 Mocha 是现在较为成熟，生态较完善的单测框架。 Jest 由 Facebook 出品，由 Jasmine 演化而来。相对 Mocha 诞生较晚，但背后有着 Facebook 的支持，可见生态社区也会越来越完善。而且和 React 搭配使用也会更友好。 上手Jest 项目中 Mocha 和 Jest 都有，但 Jest 似乎更多。目前准备写的也是应用了 Jest 的项目，所以准备先入门 Jest。 首先新建一个项目 unit-test 并初始化，然后安装相关依赖。 123mkdir unit-testnpm initnpm install jest 在 package 中添加相应脚本。 123scripts: { &quot;test&quot;: &quot;jest&quot;} 项目中已有了 Jest. 此时我们来测试一个简单的加法函数。 新建一个 index.js. 1234function sum(a, b) { return a + b}module.exports = sum 再创建一个 index.test.js 用于验证。 1234var sum = require(&apos;./index&apos;)test(&apos;1 + 2 equals to 3&apos;, () =&gt; { expect(sum(1, 2)).toBe(3)}) 然后运行测试，观察输出。 1npm run test 如果验证通过的话，可以在终端看到如下通过提示。 至此，一个简单的测试完成了。 不过通常情况下，我们会结合 ES6，React 使用，所以会配合上 Babel，需要安装其他依赖。 1npm install babel-jest babel-core regenerator-runtime babel-preset-env babel-preset-react 然后添加一个 babel 配置文件 .babelrc. 123{ &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]} 然后我们就可以使用 ES6 语法了。可以将原来的 require 改为 import 等。 断言 在上述的测试用例中，有一句断言 —— expect(sum(1, 2)).toBe(2) 实际上，在每个测试中，都至少有一句断言来判断执行结果是否与预期的一致。目前的断言库语义化都做的很好，如同上面这句话，很容易理解这是期望的结果和执行的结果的比较逻辑。 像常用的 Mocha 有着自己的断言库 Chai, 而 Jest 我目前还不确定是引用了什么断言库，看起来好像它本身就支持。 而断言的写法，也是以 expect 开头，然后以匹配器方法调用作为结果。包括下文提到的一些匹配器方法 toEqual 等等。 12expect(func(..args)).toBe(res)expect(func(..args)).toEqual(obj) 使用匹配器 刚才我们使用 expect(sum(1, 2)) 来输出期望的值，再用 toBe 方法来比较值是否相等。这里 toBe 就是相应的匹配器。 toBe 内部使用 Object.is 方法来判断，该方法和全等(===)判断类似，但略有不同。例如 Object.is 会区分 -0 和 +0，但不会区分 Number.NaN 和 NaN. 1234Object.is(-0, 0) // false-0 === 0 // trueObject.is(Number.NaN, NaN) // trueNumber.NaN === NaN // false toBe 方法通常可以用来比较数字，字符串等基本类型。但如果要比较对象等引用类型。可以使用 toEqual,它会递归比较对象中的值。下面来试着使用下 toEqual 方法。 1234test(&apos;比较对象相等&apos;, () =&gt; { const data = { a: 1, b: &apos;2&apos; } expect(data).toEqual({ a: 1, b: &apos;2&apos; })}) 相应的，在各类型中还有对应的匹配器方法，例如使用 toBeNull 来匹配 null，使用 toBeCloseTo 来匹配浮点数，使用 toMatch 来匹配正则字符串，使用 toContain 来匹配数组是否包含某项等等。这些都可在 Jest 官网上找到。 测试异步代码测试回调 异步代码中常见的有测试回调，例如有 fetchData 的函数，传入 callback 回调函数。按照之前的理解，测试方式是这样的 1234567891011function fetchData(callback) { const data = &apos;async data&apos; callback(data)}// 有问题的写法test(&apos;测试回调&apos;, () =&gt; { function callback(data) { expect(callback(data)).toBe(&apos;async data&apos;) } fetchData(callback)}) 由于 fetchData 的执行是异步的，所以当该测试执行完毕时，它还没有执行结束，也就无法测试。 Jest 本身在测试回调函数时提供了一个参数用来标识内部函数是否执行行结束。 1234567test(&apos;测试回调&apos;, (done) =&gt; { function callback(data) { expect(data).toBe(&apos;async data&apos;) done() } fetchData(callback)}) 这样，当 done 函数执行结束时，测试才执行完毕。而如果 done 没有执行，那也意味着其中哪里出现了问题。 测试Promise 同样的，这样测试 Promise 也无法生效，结果并不会报错。 1234567891011function handleData(data) { return new Promise((resolve, reject) =&gt; { window.setTimeout(() =&gt; resolve({ res: data.res + 1 }, 3000)) })}// 错误示范test(&apos;测试 Promise 代码&apos;, () =&gt; { handleData({ res: 2 }).then((data) =&gt; { expect(data).toEqual({ res: 2 }) })}) 要测试 Promise, 只需要在 Jest 测试中返回一个 Promise 即可。 12345test(&apos;测试 Promise 代码&apos;, () =&gt; { return handleData({ res: 2 }).then((data) =&gt; { expect(data).toEqual({ res: 2 }) })}) 当然，Promise 还会有刻意测试错误的情况。于是我们想当然的又会觉得加上 return 就可以了。下面这段代码，我们来测试是否执行了 reject 方法，这时我们传入一个错误的参数再执行。 123456789101112131415function handleDataReject(data) { return new Promise((resolve, reject) =&gt; { window.setTimeout(() =&gt; { if (Object.prototype.toString.call(data) !== &apos;[object Object]&apos;) { reject(&apos;Type Error!!!&apos;) } resolve({ res: data.res + 1}) }, 3000) })}test(&apos;测试 Promise reject 代码&apos;, () =&gt; { return handleDataReject(&apos;test rejected&apos;).catch((data) =&gt; { expect(data).toMatch(&apos;Type Error!!!&apos;) })}) 这里确实执行通过了。但如果我们把一个正确的参数传进去，是否能验证错误的情况呢，答案是不会的。例如我们把刚刚的 test rejected 字符串改为 { res: 1 } 作为参数传入的时候，其实也检测不出错误的执行。 因为在测试错误的情况的时候，fulfilled 状态也是不会在测试中被检出的。换句话说，当执行正确的时候，Promise 不会跑到 catch 后续这个函数中，也就会被检测通过。但这里我们需要测试的是异常的情况，所以必须还是需要补充上一句后续断言是否执行的语句 expect.assertions(1)。它并不会抛出测试的错误，但它会提示你有一句断言没有执行，这时候你就知道了，刚才那段对象作为参数执行的代码并没有走到 catch 函数中。 123456test(&apos;测试 Promise reject 代码&apos;, () =&gt; { expect.assertions(1) return handleDataReject(&apos;test rejected&apos;).catch((data) =&gt; { expect(data).toMatch(&apos;Type Error!!!&apos;) })}) .resolves/.rejects .resolves/.rejects 是对上述更简化的写法。 12345678test(&apos;测试 resolves 代码&apos;, () =&gt; { expect.assertions(1) return expect(handleDataReject({ res: 1 })).resolves.toEqual({ res: 2 })})test(&apos;测试 rejects 代码&apos;, () =&gt; { expect.assertions(1) return expect(handleDataReject(&apos;test rejected&apos;)).rejects.toMatch(&apos;Type Error!!!&apos;)}) Async/Await 这里的用法其实与它们本身的用法类似。 12345678910111213test(&apos;测试 async 代码&apos;, async () =&gt; { expect.assertions(1) const data = await handleDataReject({ res: 1 }) expect(data).toEqual({ res: 2 })})test(&apos;测试 async error 代码&apos;, async () =&gt; { expect.assertions(1) try { await handleDataReject(&apos;test rejected&apos;) } catch(e) { expect(e).toMatch(&apos;Type Error!!!&apos;) }}) 由于使用了同步写法，这时候不需要再 return 了。当然，我们还是可以使用 .resolves/rejects 来做一些写法上的优化。 12345678test(&apos;测试 async 代码&apos;, async () =&gt; { expect.assertions(1) await expect(handleDataReject({ res: 1 })).resolves.toEqual({ res: 2 })})test(&apos;测试 async error 代码&apos;, async () =&gt; { expect.assertions(1) await expect(handleDataReject(&apos;test rejected&apos;)).rejects.toMatch(&apos;Type Error!!!&apos;)}) 在React中使用 通过以上的内容，我们对单测有了一个比较初步的了解。 但在实际项目中，我们通常会在 React 中来使用 Jest。而在 React 中书写单测，自己接触较多的是基于 Reducer 的。 下面来写一个 React 中的单测，假设我们有一个列表数据获取逻辑(假设没有异步请求)，然后我们要对它进行一个验证。 首先是 Reducer. 会有一个 reducer.js 文件 12345678910111213141516// 初始数据const initialState = { listData: { data: {} }}// reducer 将 listData 保存export default function ListReducer(state = initialState, action) { switch(action.type) { case: &apos;LIST_DATA&apos;: return Object.assign({}, state, { listData: action.data listStatus: &apos;success&apos; }) }} 然后编写相应的单测。reducer.test.js 1234567891011121314151617181920212223242526272829303132333435import ListReducer from &apos;./reducer&apos;// mock 数据const initialState = { listData: { data: {} }}// actionconst listData = { type: &apos;LIST_DATA&apos;, listData: { data: { name: &apos;kyrie&apos;, age: 21 } }}// 处理后的数据const listDataReducer = { listData: { data: { name: &apos;kyrie&apos;, age: 21 } }, listStatus: &apos;success&apos;}test(&apos;获取列表&apos;, () =&gt; { const state = ListReducer(initialState, listData) expect(state).toEqual(listDataReducer)}) 当然，这里的例子非常简单，运行 npm run test 也能轻易通过。但在实际项目里，Reducer 的处理可能会复杂的多，相应的书写也会更加复杂。上述是一个单个的测试，真实项目中，或许是按模块来组织的。每个模块中有相应的多个 Reducer. 那就需要用到测试套件(test suite) —— describe 块，其中会含有多个测试用例(test case), 即 it 块。 describe 函数的第一个参数是测试套件名，第二个是要执行的回调函数。 it 函数同理，它作为独立的测试用例，是测试的最小单位。 于是整理后如下： 12345678910describe(&apos;获取列表模块测试&apos;, () =&gt; { it(&apos;获取列表&apos;, () =&gt; { const state = ListReducer(initialState, listData) expect(state).toEqual(listDataReducer) }) it(&apos;获取列表失败&apos;, () =&gt; { // do sth }) // 更多的测试用例}) 整理后整个模块的内容都在 describe 套件内，组织起一个个测试用例。显而易见，这样更容易梳理和回顾。 小结 有些时候，项目里没有单测也能基本良好运行，就像我从前做过的项目一样。但这未必是好事。因为单测带来的，其实更多的是对业务的思考和设计。假如我们决定要写单测，那么在写该模块时，就应提前想到多个可能的场景，从而避免未知的错误，同时自己也会对当前业务有着更好的理解。另一方面，就像我现在所做的，其实通过写单测，可以去熟悉相应的业务模块的所有场景，这会比直接阅读业务代码会更熟悉的多。 上述代码对应的仓库 unit-testing. Issues目前碰到的一些问题整理，基于 ^22.4.3. 在运行 npm run test 时 123import { Modal } from &apos;antd&apos; // 这样引入时会报 CSS 相关的报错import Modal from &apos;antd/lib/modal&apos; // 这样才不会报错import Modal from &apos;../../../node_modules/antd/lib/modal&apos; // 或者这样也不会报错 排查发现是 Jest 无法解析 CSS。搜索部分结果，有人给出了方案，官方也提供了解决方案。目前发现可以解决。 TODO redux-mock-store 了解。","link":"/2018/06/29/learning-unit-testing/"},{"title":"被人忽视的 es6 重要类型 symbol 简单入门","text":"随着 ES6 的广泛应用，似乎其实还有一些它的特性，明明推出时影响巨大，却并没有掀起多少波澜。本文尝试着探究它，搞清楚它是什么，它能做什么，以及为什么它不火。推荐：★★★☆ 索引 Symbol介绍 Symbol怎么用 Symbol应用场景 小结 参考 Symbol是什么 从较官方的文档上看，它是一种基本数据类型 （primitive data type）。Symbol()函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：new Symbol()。 通俗一些，讲人话就是，它是 ES6 推出的新的基本类型，它的”构造”函数每一次调用返回的值都是唯一的。 123456789const symbol1 = Symbol();const symbol2 = Symbol(1234);const symbol3 = Symbol(&apos;foo&apos;);const symbol4 = Symbol();console.info(typeof symbol1); // symbolconsole.info(symbol1 === symbol4); // falseconsole.info(symbol2 === 1234); // falseconsole.info(symbol3 === &apos;foo&apos;); // false 可以看到，以上的输出结果通通都是 false, 它们都互不相等. 且获取到的类型是类型 symbol. Symbol怎么用基本使用 上文简要介绍了 Symbol 和它的使用。现在我们来详细看一下它是一个怎样的存在。 它的语法很简单 Symbol([description]). 入参是可选的。仅用作调试。 但比较怪异的是，它不支持 new Symbol 创建的语法。如果要这么执行，会抛出异常 Uncaught TypeError: Symbol is not a constructor。 猜测这是因为它本质上还是原始类型的值，而不是对象。 const num = new Number(1); typeof num; // 输出 object 其实构造函数返回的是对象。 而上文提到的入参，目前是没有官方方法提供的，只是在 ES2019 的标准里是可以直接访问了。symbol3.description // output: foo. 好的，我们回过头看这个可选的参数支持什么样的数据类型。 1234567const num = Symbol(123); // Symbol(123)const str = Symbol(&apos;string&apos;); // Symbol(string)const bol = Symbol(false); // Symbol(false)const obj = Symbol({}); // Symbol([object Object])const foo = Symbol(() =&gt; {}); // Symbol(() =&gt; {})const nul = Symbol(null); // Symbol(null)const und = Symbol(undefined); // Symbol() 运行后发现，这些类型当作入参都是支持的，并且最终输出都转化成了字符串。就像是使用 String(description) 先调用了一次转成了字符串类型。只有 undefined 的输出里，description 被吞了。undefined 这里为何不输出我在目前的文档里还没有找到解释。实际使用中，这种场景可能也较少。 作为属性使用 实际上，Symbol 作为属性值或者属性名来使用，会更有实际意义一些。 需要注意的是，Symbol 不是字符串类型，所以不管是访问还是定义，都需要用中括号包裹。 1234567const desc = Symbol(&apos;desc&apos;);let symbolObj = { [Symbol(&apos;name&apos;)]: &apos;kyrie&apos;, [desc]: &apos;desc&apos;};symbolObj.desc; // output: undefinedsymbolObj[desc]; // output: desc 以上可以看到，如果用 . 属性访问，实际是访问的字符串属性，而非 Symbol 属性。这里我们并没有赋值，因此是 undefined 的。 作为使用来说，自然是为了防止属性名相同时，有值被意外覆盖。以下定义了多个 name 属性，而最终它们都是存在的。 123456symbolObj[Symbol(&apos;name&apos;)] = &apos;jody&apos;;const symbolObj2 = { [Symbol(&apos;name&apos;)]: &apos;ella&apos;};const newSymbolObj = Object.assign({}, symbolObj, symbolObj2);console.info(newSymbolObj); // output: {Symbol(name): &quot;kyrie&quot;, Symbol(name): &quot;jody&quot;, Symbol(name): &quot;ella&quot;} 最后，这三个属性都是在的。不管是新增的属性亦或是合并的属性，都列出来了。那么我们会很自然的想到，都长一样了，咋去访问呢。 有的人可能会觉得，这玩意儿不是很像字符串么，那我索性通通 JSON.stringify() 序列化一遍好了。到时都是字符串，还怕取不出。不幸的是，序列化还真不行。stringify 方法先前我们知道，是不能单独序列化 undefined 和 任意函数的。这回，还得加上 Symbol。 123JSON.stringify(newSymbolObj); // &quot;{}&quot;JSON.stringify(() =&gt; {}); // undefinedJSON.stringify(); // undefined 因此，大可不必费周章使用旁门左道。如果只是访问的话，且看下文。 Object.prototype.getOwnPropertySymbols Object 原型上是有提供这样一个方法来访问 Symbol 属性的。 以数组形式返回属性名，有些类似 Object.keys 的效果。 12const symbolKeys = Object.getOwnPropertySymbols(newSymbolObj);console.info(symbolKeys); // output: [Symbol(name), Symbol(name), Symbol(name)] 这个返回，似乎没有什么用。毕竟我们刚刚设置了几个同名描述值的 Symbol 属性嘛。但对不同描述值的 Symbol 属性来说，自然是直观一些的。 1234symbolKeys.forEach((key) =&gt; console.info(newSymbolObj[key]));// kyrie// jody// ella 依次输出了三个属性值。这个顺序，据我个人观察，是按照定义先后顺序来的。这里也并没有找到明确的说法。 这个方法用完，似乎我明白了它为啥不火了。 当然，可以用作变量名作属性来区分，不过很现实的感受是，可以，但没必要。 1234567const name1 = Symbol(&apos;name&apos;);const name2 = Symbol(&apos;name&apos;);const symbolObj = { [name1]: &apos;kyrie&apos;, [name2]: &apos;jody&apos;};symbolObj[name1]; // 可以访问修改，但仅作访问用时，属实没必要 Symbol应用场景 从上文的描述来看，似乎它只能用作数据存储了，甚至是比较适合查看，而不适合修改。那它就真没有场景可以使用了吗？那倒不至于。 消除魔法字符串 在实际业务中，就有一个真实场景，例如某个详情页面的 tab 切换。 简单介绍下这里的业务逻辑，是在订单详情页面里，有几个 tab 需要展示，当切换到某一个 tab 比如物流轨迹的时候，需要特殊处理，调用获取轨迹接口。下面是原来的代码。 1234567891011/** * 在订单物流轨迹 tab 下，需要获取物流轨迹 * @param {String} activeTabKey */handleChangeTab = (activeTabKey) =&gt; { this.setState({ activeTabKey }); if (activeTabKey !== &apos;logistic&apos;) { return; } this.getLogisticTrack(this.state.currentLogisticNo);} 123456789&lt;Tabs onChange={this.handleChangeTab} activeKey={this.state.activeTabKey} tabBarExtraContent={this.renderTitle()} type=&quot;card&quot; data-rpno={RED_PILLS.TAB_CHANGE}&gt; &lt;TabPane tab=&quot;基本信息&quot; key=&quot;detail&quot; /&gt; &lt;TabPane tab=&quot;物流信息&quot; key=&quot;logistic&quot; /&gt; &lt;TabPane tab=&quot;交流版&quot; key=&quot;issue&quot; /&gt;&lt;/Tabs&gt; 可以看到，不论是标题或是 key，都很适合使用 symbol 来标识，尤其是 key，它本身并无意义，只需保证它的唯一性，用 symbol 替换，可以以此消除逻辑与字符串之间的强耦合。 这里的改变很简单，只需定义一个对象来保持即可。 12345678/** * 标签页对应 key */const TABS_SYMBOL = { detail: Symbol(&apos;detail&apos;), logistic: Symbol(&apos;logistic&apos;), issue: Symbol(&apos;issue&apos;),}; 相应的，render 和操作函数里都加上对应的变量值。 1234567handleChangeTab = (activeTabKey) =&gt; { this.setState({ activeTabKey }); if (activeTabKey !== TABS_SYMBOL.logistic) { return; } this.getLogisticTrack(this.state.currentLogisticNo);} 1234// render 内容 简写如下&lt;TabPane tab=&quot;基本信息&quot; key={TABS_SYMBOL.detail} /&gt;&lt;TabPane tab=&quot;物流信息&quot; key={TABS_SYMBOL.logistic} /&gt;&lt;TabPane tab=&quot;交流版&quot; key={TABS_SYMBOL.issue} /&gt; 这样，key 之间的耦合就消除了，我们仍可以做的再激进一点，把这里的 tab 标题也替换了。将这些属性当成是属性，不过这里仅作 symbol 当作属性的例子用，实际开发中这么做，后来的开发者可是会过来砍人的哟。 12345678910111213const detail = Symbol(&apos;detail&apos;);const logistic = Symbol(&apos;logistic&apos;);const issue = Symbol(&apos;issue&apos;);const tabTitle = { [detail]: &apos;基本信息&apos;, [logistic]: &apos;物流信息&apos;, [issue]: &apos;交流版&apos;,};// render 内容 简写如下&lt;TabPane tab={tabTitle[detail]} key={TABS_SYMBOL.detail} /&gt;&lt;TabPane tab={tabTitle[logistic]} key={TABS_SYMBOL.logistic} /&gt;&lt;TabPane tab={tabTitle[issue]} key={TABS_SYMBOL.issue} /&gt; 以上这段代码虽然有点多余，但是呢，还有一点借鉴意义。就是可以防止后来者更改这些属性，假如有个小伙伴觉得这个基本信息应该换个标题，而它又没有发现上面的变量，直接给这个属性重新赋值，这时是不会影响原有值的。 12tabTitle[Symbol(&apos;detail&apos;)] = &apos;详情信息&apos;;tabTitle[detail]; // 基本信息 或许这样写更加直观。 12345678const tabTitle = { [Symbol(&apos;detail&apos;)]: &apos;基本信息&apos;,};const newTabTitle = { [Symbol(&apos;detail&apos;)]: &apos;详情信息&apos;,};const finalTabTitle = Object.assign({}, tabTitle, newTabTitle);// output: {Symbol(detail): &quot;基本信息&quot;, Symbol(detail): &quot;详情信息&quot;} 看起来我们有了两个一样属性的不同值。只要它们都在，那么数据就是完好的。 小结 写到这里，似乎我有些明白了它为何不火。根本原因是它的适用场景，在前端应用的多数业务中，是较少的。保存实际数据的时候，防止数据键值重复，这看起来就像是要在前端保存一个小型数据库。而大多数时候，我们不需要去在前端系统里维护一个小型数据库。我们定义对象的时候，通常就知道了里面的属性，并且有轨迹可逊。至少这样看下来，只有消除魔法字符串这个场景，能在我们的实际业务场景中用到。当然，如果有其他比较经典的适用场景，也可以一并交流。 有关 Symbol 的介绍，其实这是一篇比较浅薄的入门，解决了一个微不足道但比较实际的问题。至于它的更多方法和应用，就有待读者大佬们自己发掘体验了，也可在评论区交流分享～ 参考 SymbolES6中的SymbolSymbol in ES6阮一峰文档","link":"/2020/06/13/learning-about-symbol/"},{"title":"如何让你的 Sublime Text 独具一格","text":"sublime 养成记作为大多数前端攻城狮的主力编辑器，怎么能不让它美一些呢。打开偏好設置，參照以下配置，开启你神祕的sublime text 3之旅吧！ 1234567891011121314151617181920212223242526{ &quot;auto_find_in_selection&quot;: true, // 开启选中范围内搜索 &quot;bold_folder_labels&quot;: true, // 侧边栏文件夹显示加粗 &quot;caret_style&quot;: &quot;smooth&quot;, &quot;color_scheme&quot;: &quot;Packages/Colorsublime - Themes/Easyballs.tmTheme&quot;, &quot;default_encoding&quot;: &quot;UTF-8&quot;, &quot;default_line_ending&quot;: &quot;unix&quot;, // 使用unix风格的换行符 &quot;draw_minimap_border&quot;: true, // 右侧代码预览时给所在区域加上边框 &quot;ensure_newline_at_eof_on_save&quot;: true, // 保证在文件保存时，在结尾插入一个换行符。这样git提交时不会产生额外的diff &quot;fade_fold_buttons&quot;: true, // 默认显示行号右侧的代码段闭合展开三角号 &quot;font_face&quot;: &quot;Monaco&quot;, // 个人最钟爱的字体 &quot;font_size&quot;: 19, &quot;font_weight&quot;: 700, &quot;highlight_line&quot;: true, // 当前行高亮 &quot;highlight_modified_tabs&quot;: true, // 高亮未保存文件 &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;save_on_focus_lost&quot;: true, // 窗口失焦立即保存文件 &quot;tab_size&quot;: 2, &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;, //主题推荐，除了使用的以外，Material和Seti_UI 这两款都很美，比太空灰更美 &quot;translate_tabs_to_spaces&quot;: true, // 将tabs转换为space &quot;trim_automatic_white_space&quot;: true, // 自动移除多余空格 &quot;trim_trailing_white_space_on_save&quot;: true // 保存时移除多余空格} 常用插件 插件安装包 package control ConvertToUTF8: GBK编码兼容 JsFormat: javascript格式化，包括json.切换Syntax后按 Ctrl+Shift+A?格式化 ColorSublime:用来安装官网的所有主题。 Color Highlighter: 高亮CSS中的颜色，可以设置成用背景色或者边框提示颜色 { &quot;ha_style&quot;: &quot;filled&quot;, &quot;icons&quot;: false } DocBlockr: 代码块注释 /*:回车创建一个代码块注释 /**:回车在自动查找函数中的形参等等。 Git: 还没学会用。 Modific: 高亮文件上次提交后的改动，适合git和svn BracketHighlighter 括号高亮 BracketGuard 高亮错误的括号 Better coffeescript ColorPicker 拾色器 (这个可以用其他软件替代) CSScomb: 给css的属性排序，默认按键是ctrl+shift+c，使用后能会留有空行，再和下面的格式化插件配合使用，效果最佳 CSS Format css格式化插件 // 先cmd+shift+p 然后选择选项，个人习惯选择 Format CSS: Expanded CSS3 支持CSS3，语法高亮，自动补全 Ctags 跳进方法内部，不过配置有些麻烦 Jade Javascript Next: 支持es6，还未使用 LiveStyle 支持实时调整CSS属性 需要文件路径 chrome也要安装插件 不常用 SCSS SyncedSidebarBg 让侧边栏和中间背景色相同 typescript Babel ES6/2015 和 React JSX上添加语法高亮 ES6语法检查 eslint 首先是要系统全局安装eslint, 运行npm install -g eslint，npm install -g babel-eslint 下载插件 sublimeLinter 下载 sublimelinter-contrib-eslint 下载完成后修改Sublimelinter 配置，Preferences-&gt;Package Settings-&gt;SublimeLinter-&gt;Settings-User, debug: true 开启 debug 模式 paths: 根据具体环境，设置 ESLint 路径 例如： 12345678910111213141516171819202122232425{&quot;user&quot;: { &quot;debug&quot;: true, ... &quot;linters&quot;: { &quot;eslint&quot;: { ... &quot;excludes&quot;: [&quot;*.html&quot;] } }, ... &quot;paths&quot;: { .... &quot;osx&quot;: [ &quot;/usr/local/node/v0.12.7/bin&quot; // 如果用nvm装的会是这个 &quot;/Users/kyriejoshua/.nvm/v0.10.30/bin/&quot; ], &quot;windows&quot;: [ &quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm&quot; ] } ...}} 然后在项目根目录下生成eslintrc.json文件 运行eslint --init 选择一些基本配置生成文件 具体配置看这里 ‘off’ or 0 关闭规则 ‘warn’ or 1 将规则视为警告 ‘error’ or 2 将规则视为错误 受不了自帶的丑陋图标？——更换图标方法 – You got the replacement icon (whatever file type, not neccessarily icns) somewhere, open it with Preview.点击准备替换的图标。 – Cmd + Option + 2 to open Preview’s Thumbnail pane. – Select the image in the Thumbnail pane and Cmd + C 复制选中图标 – Use Cmd + I to open the Info panel for the App. 打开app的图标预览 – You see the small icon at the top left of the Info panel. Click to select and Cmd + V 选中粘贴 That’s it! It might take longer than your method, but it doesn’t require the icon to be with “.icns” extension. 参考 sublime中文文档 sublime text3配置","link":"/2016/05/03/make-your-Sublime-Text-different/"},{"title":"前端入坑周年记——野蛮生长","text":"不久前，正好是我以前端身份工作的一周年。很难相信，毕业前迷茫得找不到北的我，会在没多久后找到一个与自己兴趣相投的职位并且决定长期发展。人总是是要向前看的，但有些时候也需要回顾，我想就这篇文章，来记录这一年里踩过的大大小小的坑，和经历前端风云变化的一些事。 不断踩坑我清楚记得刚开始工作时的状态——那会儿只学习了些基础知识的我，在第一次面对实际的业务代码的时候一脸懵逼。就像新手从新手村刚出来，就开始不得不面对boss。但其实远没有那么夸张，当你只见过html, javascript, css这些素颜天真的妹子，然后再第一次遇见化妆后的美女们，自然会不知所措。js化妆成了简洁的coffeescript(cs), html化妆成了简洁的jade, css穿上了高跟鞋变成scss.还有强大无比的版本控制工具git, 再加上本来习惯用的windows平台，换成了mac, 就像习惯穿的T恤牛仔，换成了西装衬衫。在把妹(coding)时也越来越不自信了。 但在一开始接触这些，其实并不是坏事。她们让我明白了前端的多样性，多元化，也让我做了今年最棒的事之一——由于工作需要，买了属于自己的Macbook Pro——尽管前不久我才刚刚把分期还完。使用MBP的效率实在是高的惊人，就前端而言，她是如此地方便和快捷。github上有一堆awesome-mac系列app等待你去挖掘。 搭配cs使用的是angular 1.3, 在这一年里慢慢发现，这个曾经流行的MVC框架王者，在框架领域开始慢慢被react和vue瓜分。而1.3更可算是古老的版本了，她和cs正在随着历史潮流退去。这是我后来才意识到的事。在我还没意识到这些的时候，我又接触了typescript + angular 1.4搭建的项目，ts和ES6相似，有许多ES6的新特性，而整体上有一点像java, 静态类型，类，继承，私有状态等等。 前半年大概就在大量接触新内容的状态中度过了。说来惭愧，至少过了个把月，我才渐渐适应这些琳琅满目的框架和预编译语言等等。在这里要感谢两位前辈聪哥和望哥，和他们接触的时间并不久，但给我留下很多可学习的地方。让我在编程初期意识到良好的代码规范在团队中的重要性，要养成好的代码习惯等等。 野蛮生长后来在望哥帮助下，我构建了一个小项目——主要使用了webpack+ES6, 是一个多页面应用，截至目前只引入了jquery，除此之外包括eslint规范审查，引入babel编译ES6等等。后来应用到了公司的生产环境中，在微信公众号里。建立这个项目初期是期望开发者能简单上手，但随着业务需求的增加，它开始变得捉襟见肘。首先缺乏bootstrap这样类似的样式框架，未定义公共样式，使得后来所有单个页面的样式都需要重写。后来我尝试添加路由，尝试引入express框架却发现每个模块都需要更改，实际条件不允许，更别谈引入react和vue之类的框架了。 接下来的过半年时间我在写以ts和ES6为主的业务代码。在没有框架可用情况下使用纯ES6边学习边写，没有任何模板，也没有时间写模板，不管是样式还是逻辑。即便ES6新提供的语法糖非常可爱实用，但过程却让我非常痛苦，也不得不去github看一些优秀项目的源码寻找更好更优化的方案。这段时间，写几乎纯原生的代码让我开始意识到代码的抽象性。写代码的能力和抽象的能力是正比的。 回顾下来，我渴望进步，所以在工作之余试图让自己处在学习的状态。但或许有些过犹不及——那些技术热文我看了许多，其中却也匆匆扫过许多，留下印象的却寥寥无几。有段时间我啃起了权威指南，有段时间又尝试理解Understore.js源码。阅读内容，方向太杂太乱导致我有时停滞不前。所以最近，我又让自己回归基础，啃起了js权威指南。我始终觉得基础的是最重要的。 划重点这一年，我的重心从angular+cs转到angular+ts, 再到后几个月的ES6+jquery+webpack，经历了较大的转变。而这年也几乎是我在前端摸爬滚打的一年, google, github issues, stackoverflow, segmengfault等等我用尽各种手段去寻找坑的答案。前两个月有前辈指导，后来就开始横冲直撞。库克说过——总之是一个名人说过——只要是方向对了，不管是跑是走是爬，都是进步，都是好的。但我不想爬了，不想横冲直撞，想走路，想走快点，再快点，我还有饱满的热情不想浪费呢。 最后，留一点私心。最近离职了，正在寻找下一份工作。我的一切几乎都在上面了，剩下的也在博客里，有talk有code。希望也有机会可以和各路前辈大神交流，十分想加入一个优秀的团队，和各位优秀的伙伴共事、成长。","link":"/2016/12/26/my-2016-with-front-end/"},{"title":"我的笔记选择之路","text":"最近清理旧电脑的时候，因为自己的一系列误操作加上某些软件自身的缺陷，最终导致了我的所有技术笔记毁于一旦，经过金钱和时间的投入最终可能挽回十分之一。具体过程和原因不再表述，但这件事使得我重新开始思考记笔记这件事情。推荐：★★★☆ 索引 当前场景 个人需求 试用体验 横向比较 我的选择 小结 当前场景 在今天之前，其实我使用这款 Quiver App 已经近两年了。期间无数次想要切换到别的软件，都以自己的懒散而作罢。最终，我尝到了苦果。于是我痛定思痛，准备这次一次性迁移数据，并且换用新的笔记软件。 先说下为什么我一直想切换别的软件，因为使用过程中文档内容会时不时突然消失。要解决这个 bug 也很简单，重启试试就可以了。但这点其实非常影响体验，你会害怕里面的数据是否真的丢失，而到如今，真的丢失了。 其次就是它的同步功能很鸡肋，没有一个直观的提示同步进度导致我无法判断它究竟是否同步完成。除了 icloud, 其他的选择也并不多。 最后就是它的社区生态。这款软件距离上次更新已经近一年时间，看起来这个软件被它的开发者都给遗弃，更别说开发新功能或者解决历史问题了。这次数据丢失，我提了 issue 并且发了两份邮件，结果都石沉大海，没有音讯。 剩下的，除了编写体验不那么好，也能勉强使用，于是我就这么将就用了两年时间，直到发生这次 P0 级故障。 至于为什么没有选择别的替代品，除了自己的懒散以外，我也一直没认真思考过自己真正的需求是哪些，究竟哪些功能点是不可或缺的；哪些是锦上添花的；哪些又是可以替代的。所以现在决定重新整理自己的笔记所需。 个人需求使用需求 关于笔记，个人而言，主要是指技术笔记，功能上必然少不了支持 md , 这点是最大的刚需。这里技术笔记是核心，但也不排除其他的生活类笔记，而 md 的格式也是完全支持且方便查看的。这里需要说明的是，md 支持并不是指导出格式，而是指编写时或复制时的源文件格式。有些功能强大的笔记软件让我比较意外的是，竟然不是完全支持 md 语法，亦或是它的编写源格式太丰富，按功能而不是按格式区分，其实并不方便。 其次是预览模式，尽管 md 的写法已经足够清晰明了，但相对于它生成的结果而言，还是显得捉襟见肘。所见即所得是比较常见且友好的处理方式，不过我对所见即所得并没有那么强制的需求，只是常规的预览模式就可以，例如分栏预览。又或者即便没有预览视图，那么一个美观的界面也是不赖的替代品。 至于用户体验，它是种玄学，就像有的人说不清哪里好，但就是谁都替代不了。 单纯从编写体验来说，个人感觉 Typora 和 Bear 给人的感觉就很舒适。这清爽的界面就自带专注加成的效果。面对着它，你不写，就是一种亏待。 快捷键操作，如果一个软件能快速地在预览和源代码模式之间切换，能快速在文档之间切换，这个体验也是极好的。 关于其他方面，有些软件可以把操作步骤尽可能的简化，例如创建文件、整理目录，一次点击、一次拖拽即可搞定，这种懒人操作可以给人带来极大的舒适感——也许这就是所谓的玄学吧。 组织需求 强制性的需求还有一点，就是文件管理系统。 原来我以为，所有源文件放任给软件自己管理、自己生成即可。直到这次数据丢失，才发现 md 的源文件是王道。虽然它可能会成倍增长你的文件数量，但也逼迫你去精简你的文件，简化你的组织结构。 有些软件不支持目录结构是让我很意外的，我理所当然觉得笔记类软件应该具备目录管理功能的。尤其是当多个笔记混杂在一起时，例如技术类笔记，生活类笔记，又或者按工作内容划分，目录就可以很好地分类管理这些笔记了。 除此之外，标签是我从另一个维度去划分笔记的方式。例如工作和生活这两个目录分类，我同时又会以技术文档、绩效、未来规划、技术探索等标签作为另一种管理。标签和目录可以双向定位，方便归纳和对比同类笔记。 隐性需求 云服务是一把双刃剑，选对了无缝衔接，选错了欲哭无泪。我显然是后者。icloud 无法恢复文件令我对它失望透顶。所以在云服务的选择上，我没有那么重视了。有许多人选择放在 github 上，这不失为一种好办法，省去了云的费用，还逼迫自己手动去更新。手动更新虽然比较麻烦，却会让你对自己的文档更加熟悉，更加了解。每一次变更都能做到心中有数。 支持 ios 客户端也是次重要的需求，就个人而言，其实很少在手机上看文档，但若需要时，不怕一万就怕万一。当然这种场景很少，所以我把他排在隐形需求里。 对其他服务的支持，有自然是最好的，没有也不会强制。对我来说，笔记的记录首先是给自己看的，分享的需求并不强烈，所以对导出成什么格式，支持什么格式不强求。至于待办列表，提醒事项等等就都是锦上添花的功能了。 一些笔记的试用体验 其实决定我使用一个记笔记软件的决定性因素，往往在于它不支持什么。下面是我试用部分主流的笔记软件遇到的部分问题，让我直接劝退弃用了。 Notion: 作为一个很喜欢使用标题来区分段落的用户，我万万没想到它对 h4 h5 h6 四五六级标题竟然不支持，而且它似乎也不支持原生 md，有时候我就只想写写 md, 我不关心它里面有多少强大的 block. 我只关心我的需求能实现。 Ulysses: markdown 支持不友好，没有预览功能。 Vnote: 界面太过复杂，乍一看以为是 Word 文档，眼花缭乱的布局使我劝退。 Notable: 网络不稳定，几十分钟内竟几次提示已离线，而且试用不能建立文件夹（也可能是我没找到功能点——但如果设计的就这么隐蔽的话那也还是罢了）。 Typora: 文件管理薄弱，仅支持同目录查看，但不方便创建和组织文件，也没有标签功能。 Bear: 完全没有文件管理功能，只提供了标签管理。 笔记类软件横向比较 我把我的关注点，统一整理列举如下，对比了自己使用过的几个软件。 笔记 App 云同步 mac 客户端 ios 客户端 md 源码 md 语法支持 目录结构 文件管理 标签支持 所见即所得 预览模式 稳定性 用户体验 社区 Obsidian ❌ ✅ ❌ ✅ ✅ ✅ ✅ ✅ ❌ ✅ ⚠️ ⚠️ ⚠️ Typora ❌ ✅ ❌ ✅ ✅ ✅ ❌ ❌ ✅ ✅ ⚠️ ❌ ❌ Bear ✅ ✅ ✅ ✅ ⚠️ ❌ ❌ ✅ ✅ ⚠️ ✅ ❌ ❌ Notable ❌ ✅ ❌ ⚠️ ⚠️ ✅ ❌ ✅ ❌ ❌ ❌ ⚠️ ⚠️ Notion ❌ ✅ ❌ ❌ ⚠️ ✅ ❌ ❌ ❌ ⚠️ ⚠️ ⚠️ ❌ Ulysses ✅ ✅ ✅ ✅ ⚠️ ⚠️ ❌ ❌ ❌ ✅ ⚠️ ⚠️ ❌ Quiver ✅ ✅ ⚠️ ⚠️ ⚠️ ✅ ❌ ❌ ❌ ✅ ❌ ❌ ❌ 我的选择 我的最终选择是 Obisdian，是的，可能它又有些小众，可它的实际使用体验使我爱不释手，在我眼里，它有着极强的潜力待兑现。 首先是它组织文件的方式令人惊艳，所有文档即是 md 格式源文件，Notable 也能做到这点，但是不如它丝滑。它在侧边栏上就可以操作文件夹，生成 md 文件，然后通过拖拽，可以将它们完全按我喜欢的方式组织。 至于静态文件，例如图片，也可以完全按照自己习惯的方式去保存，目前我选择放在统一的目录中，这样方便一起维护。 其次整体的界面十分清爽，虽不像 Typora 这般极简设计，却也有着独到的味道。恍惚间我以为自己在用简化版的 Vscode. 而经过我一段时间的使用和观察，几乎可以肯定，它就是类似 Vscode 的编写方式，它很可能也是 js 编写，运行在浏览器中，接着用 Electron 套了个壳。 最后是编写体验也不错。它对快捷键天生友好，可以通过快捷键快速切换预览模式，切换主题，侧边栏展开打开，甚至还能通过快捷键直接切换文件，这是多少笔记软件都无法做到的啊。 除此之外，它还有着一个命令面板。像极了许多编辑器，在这里面可以做更多的事情。 最终我决定选择它，再结合 github 的能力，每隔一段时间做备份，保存上传。在以上这些功能的加成下，我发现心急手快的时候，甚至可以直接在编辑器中书写编辑，因为它让我像管理一个正经的 git 项目一样去管理我的笔记了。 小结 曾经在一家公司时，和类似 CTO 角色的大佬谈话，他给的个人发展建议是系统管理自己的知识很重要。当人成长越来越远的时候，需要将自己学习过的知识进行统筹管理。碎片化的知识很难给人带来帮助。 工作越久，越觉得这一点深有体会。虽然我现在的整理还是比较薄弱，但也是随着不断的记录，我才能探索出一条完美的笔记之路。 最后贴一张 Obsidian 使用截图吧。","link":"/2020/07/11/my-choice-of-notes/"},{"title":"我的 git 工作流","text":"这篇文章的契机是曾经有个同事问我为什么要在终端里使用 git, 当时我愣了会，因为从没有人问我这个问题，我也没有为这问题好好总结过。虽然其实有很多显而易见的好处，但我还未好好总结一番。既然自己平时在工作中使用 git 的地方非常多，也有着一套标准和工作方式在执行，那我希望通过这次整理把这流程体系更完善的加以说明。既规范化、提高工作效率，也可留作记录。 基本流程 首先是最基本的操作，从一次工作的开始到结束。这是一个比较基础的流程。 Working Directory(工作区) =&gt; Staging Area(暂存区) =&gt; Git Repository(git 仓库) 123456git checkout -b feature-newgit statusgit add .git commit [-m &apos;commit message&apos;]git checkout develop|mastergit merge feature-new 从当前分支切出一个新分支，在该分支下进行开发。 在工作区内修改文件，当任务完成时，添加所有改动文件到暂存区，然后提交，注明提交信息。 提交完成后，切回到原始分支，然后 merge 刚刚完成的功能分支。 而在这过程中，有许多地方可以改善，或者根据实际应用场景，有很多部分可以扩展。 这里以三种状态为界限展开。 Working Directory and Staging Area 工作区是自己开发时的部分。通常当一个新需求降临时，我们从 develop|master 切出分支，即自动停留在这阶段。 当需求开始开发，改动了部分代码而没有完成任务，这时我使用 git add . 来将代码保存到暂存区。 git add .的适用场景还包括但不限于以下： 睡午觉。 泡咖啡。 吃晚饭。 简言之，是工作因故暂时停止而任务又没有完成时，适合使用该命令。 Git Repository 当一个需求或任务完成时，我们需要将改动提交上去。 最常见的是，当一项任务完成时，我们先把所有改动放到暂存区，然后运行 git commit -m &apos;feat: 完成xx功能&apos; 来将这次改动提交到仓库。必要时再将分支 push 到远程。 以上是对基础使用的扩展总结。但，如果只谈这些这篇文章就毫无价值了。以下是一些进阶使用方式——毕竟任何事都不会只有基础那么简单。这些使用对我工作的效率是有极大帮助的。 进阶使用Working Directory and Staging Areagit status优化 个人而言，在未开发完需求时，最常见的使用 git 时机是查看当前的改动状态，有多少文件修改，有多少文件已经放在暂存区。 这时通过git status来查看文件状态。 不过，正因为频繁使用。完全可以简化查看内容。 git status -sb(git status -short -branch)查看分支情况并简化信息。 简便多了。 git diff优化 一个常见的场景是需要查看当前代码的改动部分——我想大部分人都不会刻意去记住自己究竟改了哪些代码。 运行git diff查看当前改动的文件: 这里我用diff-so-fancy优化排版了diff 的查看。 简单直接对吧。 如果文件多也不怕，可直接查看单个文件。 git stash和git stash apply 这是个可能有些人不熟悉的命令，但实际上很有用。 想象一下这个场景，你在自己分支上改了部分代码，突然某个环境有个严重问题要你切换到 master 或某个分支马上查看，这时工作没完成并不适合提交，放在暂存区的话不方便切换分支。git stash在这里就很有必要了。 git stash保存当前工作进度，代码改动。然后你可以尽情地切换分支，在别的分支上修复完问题后再回来，使用git stash apply恢复即可。 改动了部分代码： 保存代码改动： 当在其他分支完成后再回到当前分支恢复： git checkout .撤销修改 有时候会遇到这样一个情况，午睡时或喝咖啡或其他小伙伴过来故意动手动脚开玩笑的时候，不小心按到键盘上的某些键，而且该死，正好打在了编辑器上。我们当然不会傻到一个个去找出来然后动手删掉。 这时只要用git checkout .来取消所有修改。 git checkout file——或者发现只有一个文件改动时。 Git Repositorygit commit优化: 使用 commit message 规范提交 如果你临时起意想要创建一个项目用来随意把玩，那自然随意提交即可。但只要项目是多人维护，多人开发的，或者有回顾自己以往的改动记录的需求的，commit message 就显得很有必要了。 我参考阮一峰老师的如下规范来编写 commit message. 例如刚才的改动，使用git commit -m &apos;feat: 完成 demo4&apos;来提交。 这里我写错了，少写了完成两字，不过没关系，下一节有说明。 如果严格遵守规范，那么回顾过往的提交记录时，结果将是一目了然的。 而即便没有以上较麻烦的规则，严格遵守自己的规则也是必要的，这使得你能够清楚直接的了解自己过去、或者别人过去在这个项目里面做了什么。 git commit补充 正常的提交像上面按规则使用git commit即可。但如果突然发现自己的提交信息有误，或者遗漏了重要的信息。没关系，仍然可以修改刚才的提交——只要你还未 push 到远程！ git commit --amend命令可以将当前的改动补充到前一次提交中。 刚才我提交过快，把feat: 完成 demo4写成了feat: demo4, 现在我改回来。 这点在补充完善 commit message 时非常方便。但也需要非常注意，这只适用于还未 push 时，否则会引起一些小麻烦。 git rebase合并提交 很多时候，一个需求的完成需要数天时间，迫于各种原因，期间会提交数次。但总的来说，我们只是完成了某个需求。所以并不需要中间的或者前几次提交，这时候合并提交就显得有必要了。 git rebase -i HEAD~n可以合并前几次提交。 合并前： 现在我们将最近两次提交合并git rebase -i HEAD~2: 这里清楚显示了各命令用法，我们使用squash来合并，把第二个 pick 改为 squash. 可以再次编辑 commit message, 我们精简一下，写在一起。 完成后可见提示。 这时再查看记录： 两条 commit 已经合为一条。 和git commit --amend类似，因为涉及到修改 commit 历史，所以千万不要在git push后尝试哦！ git log优化 git log --oneline以一行的形式快速查看提交记录，这个可见刚才的提交记录。 git log -p查看提交记录同时也查看具体改动的代码部分——这在 code review 时非常方便。 git log -p file查看单个文件提交记录同时也查看具体改动的代码部分——这在找错时非常方便，再也不用到处找人询问是哪个家伙改了 XX 文件的代码了。 git log --stat查看提交记录的时候显示文件改动信息——也很适合 review 或排查错误. git log --auther=zhengyuan zhu查看某个家伙的提交记录——我没改这部分代码啊，看看那个家伙做了什么(这家伙究竟有没有好好工作)。 git shortlog简化版提交记录。 git shortlog -s -n查看所有人提交次数并排序——或许这样看更加简洁方便。 很高兴看到在这个项目里我贡献的部分较多。 其他 git pull --rebase可以简洁 pull 过程——适合洁癖者——我是很反感在查看 log 时看到一堆 merge 记录和情况。即有时如果远程仓库和本地仓库代码不一致时，git pull 会自动进行一次合并，这条记录突兀地存在于 commit history 里，我觉得毫无必要。 git pull --rebase过程中可能会遇到冲突，解决后用git rebase --continue来继续。或者觉得这次不稳，可以用git rebase --abort来取消。 如图所示的f6c5d08和6cbd73f提交就可以通过git pull --rebase避免。 小结 这里罗列了我常用的 git, 还有部分因篇幅原因不能再一一列举。可能更适合再写一篇来总结。相比之下，我觉得 GUI 很难做到像这样随心随欲地做到自己想用 git 所做的事。而这些完全可以使用一行命令搞定的事，我也不高兴去将手从键盘区移开然后去挪动笨重的鼠标去一个个点击。 希望大家都可以学好 git, 善待 git, 然后在 CLI 里尽情使用 git 吧.","link":"/2017/07/07/my-git-workflow/"},{"title":"个人git使用手册","text":"git安装 主要针对Mac环境下 安装说明 SSH 以下通常在测试时需要，因为需要连上主机 命令行里的输入方法（如果能在页面上做最好还是在网页上） 命令行里输入 cat ~/.ssh/id_rsa.pub 查看密钥、公钥方法 输入 vim ~/.ssh/authorized_keys 在内容里编辑，加上自己的公钥，这样可以方便以后每次测试或者做其他事时不再需要每次都输入密码（首先要输入密码进入 如ssh root@10.0.0.246 根据提示输入密码 ） 更详细的见以下链接 SSH使用说明 使用git 理解git的三种状态：已暂存、已修改、已提交 文件常常处于这三种状态之一 熟悉git的常用命令 如果提交文件时有需要编译的文件，就下载相应的编译 例如，在终端中输入：npm intall -g coffee-script 强烈推荐翻墙使用，下载更快，更方便 git常用命令(自己不太熟的)：git merge-合并、git revert-回到某次提交的状态并产生一次新的提交、git reset-撤销某次提交 、、、、、、 git 遇到问题error:bad line length character 权限问题，或者修改Host ###查看历史提交记录 *格式为作者，修改距离现在多久/提交时间：提交说名 -简短的哈希字串 展示分支合并、历史*git log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph*格式基本同上 git log --pretty=format:&quot;%h - %an, %ar/%cd : %s&quot; 撤销操作撤销 取消文件的暂存*git reset HEAD &lt;file&gt;来取消暂存 撤销对文件的修改 ！不推荐使用，不能还原 git checkout --&lt;file&gt; #####补充提交 *补充提交，会覆盖上次的提交，并不会产生一次新的提交 *提交前用git add &lt;file&gt;加上补充的文件 *git commit --amend 远程仓库 查看远程仓库*git remote -v 显示读写远程仓库使用的git保存的简写与其对应的URL*git remote show origin &gt;查看远程仓库的更多信息*添加远程仓库 git remote add &lt;shortname&gt;&lt;url&gt;例如：git remote add pb http://www.google.com 可以用pb来代替整个url 例如：git fetch pb 拉取远程仓库 从远程仓库抓取和拉取 git fetch [remote-name] 并不会自动合并*git pull 会自动合并,相当于先执行git fetch再执行git merge 推送到远程仓库 `git push [remote-name] [branch-name] #####远程仓库的移除和重命名*修改远程仓库的简写名 git remote rename 例如： git remote rename pb paul &gt;将pb重命名为paul !这个操作也会修改远程分支的名字 *移除远程仓库 git remote rm 例如：git remote rm paul ###打标签 #####列出标签 git tag ###git别名 *用于修改git操作的别名，使操作更方便 运行git config --global alias.logpregra &apos;log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph&apos; git logpregra就等价于 git log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph*常用的还有 git config --glabal alias.ci commit、git config --global alias.co checkout 定义外部命令 替换外部命令而不是子命令时，在命令前面加一个‘！’号 *git config --global alias.visual &apos;!gitk&apos;*定义git visual为gitk的别名 ###分支简介 查看分支 运行git log --oneline --decorate --graph --all 查看提交历史、各个分支的指向以及项目的分支分叉情况*在本机上已配置为git logoneall 删除分支 git branch -d [branch-name] 如git branch -d watch-pro 合并分支 当有冲突存在时*其中之一方法利用图形化工具来解决冲突，运行git mergetool &gt;git中默认的合并工具是opendiff 分支管理 git branch --merged 查看哪些分支已经合并到当前分支*查看所有包含未合并工作的分支，*git branch --no-merged*使用git branch -d命令来删除未合并的工作时会失败，因为它还未合并*但如果确实想丢掉那些工作，可以用-D选项强制删除 远程分支 远程分支以 (remote)/(branch)形式命名 运行git ls-remote (remote) 来显式地获得远程引用的完整列表 &gt;就是远程的所有分支,或者使用git branch -a来查看远程分支，似乎这个比前者更有效 更换远程分支的名字 git clone -o booyah 那么远程分支的名字就会是 booya/master 更新远程仓库到本地的命令 git fetch teamone 抓取远程仓库teamone有而本地没有的数据 假如刚刚克隆了一个仓库，想要获取一个远程分支，先在当前分支下pull，保证是最新的，然后运行git checkout -b index-pro origin/index-pro 这样你就有一个同名分支index-pro和远程的分支index-pro同步了 推送 推送本地的分支到服务器上 git push origin servefix等同于 git push origin servefix:servefix 如果不想让远程的分支重名 可以这样git push origin servefix:awesomebranch ####如何避免每次输入密码 如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。 如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。 跟踪分支（上游分支）：与远程分支有直接关系的本地分支 在远程跟踪分支之上建立本地的分支进行工作 git checkout -b [branch] [remotename][branch] 例如 git checkout -b serverfix origin/serverfix 可以用--track快捷方式 例如 git checkout --track origin/serverfix 设置本地分支与远程分支为不同的名字 git checkout -b sf origin/serverfix 本地分支sf会从origin/serverfix拉取 设置本地已有的分支跟踪一个新的拉取下来的远程分支，或者修正正在跟踪的上游分支，可以使用-u和--set-upstream-to选项运行 git branch 例如 git branch -u origin/serverfix 查看设置的所有跟踪分支 运行git branch -vv 上游快捷方式 当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。 删除远程分支 通常在通过远程分支做完所有工作了以后操作，一般这个删除只是删除了指向服务器的指针，并不会删除数据，服务器会保存一段时间的数据，直到垃圾回收运行，也容易恢复 git push origin --delete serverfix git分支-变基 git中整合来自不同分支的修改主要有两种方法：merge和rebase*变基即在新分支上引入补丁和修改，然后在原分支上再应用一次 运行git checkout [branch-name] git rebase master 然后合并 git checkout master git merge [branch-name] 变基使得提交历史更整洁 图例说明 将client的修改合并到主分支并发布，但暂时不合并server的修改*这时可以使用 git rebase命令的--onto选项，选中在client分支里但不在server分支里的修改，在master分支上重演*git rebase --onto master server client*取出client分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们在master分支上重演一遍。*然后可以快进合并master分支了*git checkout master*git merge client 接下来再把server分支中的修改也整合进来，使用git rebase [basebranch] [topicbranch]*git rebase master server 然后再合并主分支master*git checkout master*git merge server 变基的风险(不太理解) 不要对在仓库外有副本的分支执行变基 图例说明 接下来，有人向中央服务器提交了修改，其中包括合并。然后你抓取了远程分支的修改，将其合并到本地的开发分支，然后提交历史就会变成这样。 刚才的那个人又把合并操作回滚，改用变基，然后又用git push --force命令覆盖了服务器上的提交历史。之后你再从服务器抓取更新，会发现多出来些新的提交。 如果此时执行git pull,会合并来自两条提交历史的内容，生产成一个新的合并提交，如下图。 如果现在执行git log命令，会发现有两个提交的作者，日期，日志是一样的。 而且如果将这堆推送到服务器上，那么实际上是将那些已经被变基抛弃的提交又找回来。 用变基解决变基 如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下git都能成功分辨出哪些是你的修改，并把它们应用到新分支上。*如果遇到图3-38的情境，如果没有执行合并，而是执行git rebase teamone/master,git 会: 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）*检查其中哪些提交不是合并操作的结果（C2，C3，C4）*检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）*把查到的这些提交应用在 teamone/master 上面*会得到下图的结果* *要使得方案有效，需要对方变基时确保C4和C4几乎是一样的。否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。 *在本例中另一种简单的方法是使用git pull –rebase命令而不是直接git pull。 又或者你可以自己手动完成这个过程，先git fetch，再git rebase teamone/master。 *如果你习惯使用git pull，同时又希望默认使用选项–rebase，你可以执行这条语句git config –global pull.rebase true来更改pull.rebase的默认配置。 *__只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。__ *如果某些情形下决议要这么做，一定要通知每个人执行git pull –rebase`命令，这样虽然不能避免伤痛，但能有所缓解。 总的原则是：只对还没有推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才能享受到两种方式带来的便利。 子模块！ 新克隆一个项目时，会克隆相应的子模块，但是子模块内容为空。运行git submodule init初始化 再运行git submodule update同步 如果是在一个项目中新增子模块git submodule add git@code.gomrwind:FrontEnd/ui.git 假如成功了 运行git status会看到 12new file: .gitmodulesnew file: ui 然后可以cat .gitmodules查看配置 应当如下 1234[submodule &quot;src/ui&quot;]path = src/uiurl = git@code.gomrwind.com:FrontEnd/ui.gitbranch = master 要注意的是！如果之前有下过提示出错等，要更改.git中的config配置。还有.git下的modules下的相对应文件夹需要删除rm -rf files 点这里学习 123456如果在运行子模块的相关命令时出现以下问题：fatal: Needed a single revisionUnable to find current revision in submodule path运行命令删除错误的文件，重新更新： * rm -rf [模块文件名] * git submodule update --init 12345如果在运行子模块相关命令时出现以下问题fatal: reference is not a tree: 16effe6cfd27ff78b04ff95e9103514e6dcf5cb3Unable to checkout &apos;16effe6cfd27ff78b04ff95e9103514e6dcf5cb3&apos; in submodule path &apos;gezbox/lib/NotificationStyles&apos;Failed to recurse into submodule path &apos;src/ui&apos;切换分支到master,再拷贝一个分支作为对比，这是子模块有修改导致的。确认修改后再在那个分支上提交更新。 服务器上的git-协议（本地协议、HTTP协议、SSH协议、GIT协议）本地协议 最基本的协议 运行git clone /opt/git/project.git 或者执行git clone file:///opt/git/project.git 推荐使用前者 增加一个本地版本库到现有的git项目，执行git remote add local_proj /opt/git/project.git HTTP协议注意点！！！ 新建一个项目时，要新建一个文件 .gitignore 里面设置哪些文件不随git提交 如果忘记了，在之后再添加时或再次修改时。 最好重新克隆到本地。然后依次运行git rm --cached . git add . git commit -m &quot;.gitignore is now working&quot; 先把所有文件从版本控制中删除，然后再重新加回来，提交上传后新的.gitignore就生效了 git rm –cached .`表示哪些文件不随git提交 如果有错误提示 could not get git status --porcelain 很有可能是因为忘记添加.gitignre。执行一遍上述操作 could not get git status --porcelain 这样的错误提示，我的理解是上传的文件数量过多导致的。在.gitignore忘记加入时将node_modules等文件也上传，node_modules内容过多大概就导致了这个报错。甚至会导致无法使用git commit","link":"/2016/03/03/my-gitbook/"},{"title":"前端性能加快之nginx开启gzip压缩","text":"近期发现公司内部网站加载特别慢，原因是我们将所有样式文件，外部引入的文件都分别合成成一个文件，这文件少则1M，多则3、4M。大的简直不敢想象。导致打开速度几十秒甚至一分钟。实在无奈，经前辈指点终于发现nginx有个好配置…… gzip Gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。也经常用来表示gzip这种文件格式。软件的作者是Jean-loup Gailly和Mark Adler。在1992年10月31日第一次公开发布，版本号0.1。 gzip HTTP协议上的GZIP编码是一种用来改进web应用程序性能的技术。通常可以将纯文本内容压缩到原有大小的40%甚至更小。 减少文件大小，一是可以减少存储空间。二是通过网络传输文件时，可以减少传输时间。 USAGE 在nginx中使用gzip压缩很方便。只要将默认的注释除去，加上一些配置即可。 vim /etc/nginx/nginx.conf 12345678gzip on;gzip_min_length 1k;gzip_http_version 1.1;gzip_buffers 4 16k;gzip_types text/plain application/x-javascript text/css text/javascript;gzip_comp_level 2;gzip_vary off;gzip_disable &quot;MSIE [1-6].&quot; gzip on 开启gzip gzip_min_length 当返回内容大于这个值时会进行压缩，以K为单位，如果值为0，所有页面都进行压缩，但没有必要。 gzip_http_version 识别http协议的版本。默认值为1.1，就是对HTTP/1.1协议的请求才会进行压缩。 gzip_buffers 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_types 设置需要压缩的MIME类型，非设置值不进行压缩。 text/html默认已经压缩 图片可不开启压缩，jpg/gif/png格式的图片本身就是压缩过的。 gzip_comp_level 设置压缩等级，等级越低压缩速度越快文件压缩比越小，传输块但也比较耗费CPU。可设置为1-9，默认是4。 gzip_vary 判断HTTP是否支持压缩，如果不支持的就不压缩。 gzip_disable 禁用IE6的gzip，IE6支持不好，不过这年头用IE的人也不太想理会了…… PS：公司缺少运维，真心锻炼前端的全栈能力…… 参考：[开启Nginx的Gzip压缩功能](https://www.insp.top/article/open-nginx-gzip-module)","link":"/2016/08/02/nginx-gzip-on/"},{"title":"面试题整理-2017","text":"面试时遇到的一些没答上来的问题，在这里总结反思。其实很多都并不难，回顾基础大多可以答对，但现实就是要我们在任何时候都做好准备。所以，教训如下。 InterviewHTML 什么是w3c规范： W3C是英文World Wide Web Consortium的缩写，w3c理事会联盟。它是对网络标准制定的一个非赢利组织，例如制定HTML、XHTML、CSS、XML的标准。 CSS import和link有什么区别: link属于html标签，而import是css提供的引入文件方式。 加载顺序有异。link会在页面加载同时加载，而import会在页面全部下载完后再被加载。 兼容性差异。import是css2.1才提出的，所以那些老的快掉牙的浏览器(ie5+)并不支持。link则没有该问题。 dom控制样式时，只能改变用link引入的css.而import的css是无法用dom控制的。 JavaScript 创建对象的几种方式: 12345678910111213141. 使用构造函数创建:var obj = new Object();2. 对象直接量:var obj = {};3. 自定义构造函数创建:function Fun(name) { this.name = name;}var obj = new Fun(&apos;joshua&apos;);4. Object.create(parentObj[,{key: {key: value}}]);var obj = Object.create({name: &apos;kyrie&apos;}); 以下代码输出什么: 12345678910111213for (var i = 0; i &lt;= 3; i++) { setTimeout(function(){ console.log(i); }, 0);}// 输出 4个4;/* 理解如下(待完善): 由于js是单线程的，只有当前一个逻辑运行结束，才会执行下一个逻辑。 对应到这里，就是for循环先运行完成，再执行setTimeout. 这样for循环结束，一共有四次循环，产生四个结果。 而setTimeout打印每次的结果，所以是4个4。 */ 以下代码输出什么： 12345678910111213141516171819202122function b() { console.log(myVar1); console.log(myVar2);}function a() { var myVar1 = 1; var myVar2 = 2; b();}var myVar1 = 11;a();console.log(myVar2);// 11;// myVar2未定义，报错;/* 理解： 注意这里b不是闭包，无法访问到a函数内的变量。 所以myVar1会从函数作用域内向全局作用域寻找，输出11 而myVar2在全局下没有定义，就会报错。 */ 控制台内执行以下代码，然后用户在10秒内连续点击页面三次，请问会输出什么: 123456789101112131415161718192021222324function waitSomeTime() { var st = 10000 + new Date().getTime(); while(new Date() &lt; st){}; console.log(&quot;don&apos;t wait, it&apos;s ok&quot;);}function clickMe() { console.log(&apos;why click me&apos;);}document.addEventListener(&apos;click&apos;, clickMe);waitSomeTime();console.log(&apos;hello&apos;);// 会依次输出如下&quot;don&apos;t wait, it&apos;s ok&quot;;&apos;hello&apos;;&apos;why click me&apos;;&apos;why click me&apos;;&apos;why click me&apos;;/* 理解如下(待完善): 由于函数体内的逻辑是顺序执行的, while因条件不对不会触发，所以直接跳过，执行下一句。 */// 因为紧张，这题本来对了被面试官又误导错了。输在心理素质上。 将一个二叉树反向打印: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 二叉树反序 a / \\ b c / \\ \\d e f a / \\ c b / / \\f e d*/var a = { value: &apos;a&apos;, left: null, right: null };var b = { value: &apos;b&apos;, left: null, right: null };var c = { value: &apos;c&apos;, left: null, right: null };var d = { value: &apos;d&apos;, left: null, right: null };var e = { value: &apos;e&apos;, left: null, right: null };var f = { value: &apos;f&apos;, left: null, right: null };a.left = b;a.right = c;b.left = d;b.right = e;c.right = f;// bad idea but usefulfunction walkTree(root, current) { var obj = current ? current : root; if (obj.left || obj.right) { var temp = obj.left; obj.left = obj.right; obj.right = temp; walkTree(root, obj.left); } else { // 一侧或者两侧已经遍历完的情况 if (!this.shouldStop) { this.shouldStop = true; walkTree(root, root.right); } else { console.info(JSON.stringify(root, null, 2)); } }}// better ideafunction walkTree(root) { if (root.left || root.right) { var temp = root.left; root.left = root.right; root.right = temp; root.left &amp;&amp; walkTree(root.left); root.right &amp;&amp; walkTree(root.right); } console.info(JSON.stringify(root, null, 2));}walkTree(a); 未完待续……","link":"/2017/01/05/questions-in-interview/"},{"title":"理解 React 组件的生命周期","text":"近期 React 可谓是站在了风口浪尖上。某些大厂们纷纷开始抛弃它转而使用其他框架。但实际上，React 只手遮天的势力难以一时磨灭，我们这些小厂里的前端其实不必太过担心。真到了 React 末日的时候，这个世界也一定发生了巨变。所以，在当下，我们还是专注于当前，使用好 React. 于是我在这里总结了这大半年使用 React 的体验，主要是组件的生命周期和它常见的应用场景。 生命周期钩子方法组件的挂载阶段 constructor componentWillMount render componentDidMount componentWillUnmount constructor 执行阶段：在开始 render 之前。 在这里进行 state 的初始化工作。但不要使用 setState. 还可以做一些事件绑定的工作。 Note: 如果既不绑定事件也不初始化 state, 那么其实可以不使用 consturctor. 在少数情况下，constructor 中的 state 可以使用 props 来替代，但如果要达到状态随 props 改变的效果，最好使用状态提升来实现，因为 state 并不会随着 props 的改变而改变。 123456constructor(props){ super(props) this.state = { type: props.initialType }} componentWillMount 执行阶段: 组件将要挂载的阶段。在 render 前调用，只会调用一次。 这里或许可以添加一些接口请求数据的逻辑，但在这里进行 state 的更新是异步的，它并不会触发 re-render 也就是 render 重新渲染。通常情况下，更推荐使用 constructor 来替代. Note: 如果要避免一些副作用，更好的办法是将这里面的逻辑放在 componentDidMount 里来处理。 render 渲染挂载组件。这步一定会执行的。 在正常状态下，该方法会返回以下几种类型的值： React element: 最常见的返回。即使用 JSX 创建的原生 DOM 或自定义的组件例如 &lt;MyComponent/&gt;. Protal: 使用 ReactDOM.createPortal 方法创建的对象。 Boolean: bool &amp;&amp; &lt;div/&gt;, 当 bool 为 false 的时候，不渲染。 String|Number: 文本节点。 null: 不渲染。 Note: 该方法是纯函数，不应有 setState 的操作。每次渲染只会输出同一个值。如果有对状态的变更，应该是放在 componentDidMount 里。 该方法是可以返回数组的，这样就可以返回多个对象。 1234567render() { return [ &lt;div key=&quot;A&quot;&gt;First&lt;div/&gt; &lt;div key=&quot;B&quot;&gt;Second&lt;div/&gt; &lt;div key=&quot;C&quot;&gt;Third&lt;div/&gt; ]} componentDidMount 组件挂载完毕时即调用。生命周期内只会调用一次。 应用场景：通常可以将请求后端数据—— ajax/fetch 放在这里。此时界面上 DOM 已经存在。可以做有关 DOM 的操作。例如 findDOMNode. Note: 在这里调用 setState 会进行一次额外的 rendering,虽然这会导致两次的 render, 但用户不会察觉这过度的时间。可能要多加考虑的地方是这会导致一定的性能问题。 componentWillUnmount 执行阶段：当组件卸载的时候的回调函数。 应用场景: 适用于清除定时器，取消请求等逻辑。 Note: 这个函数回调适合销毁那些在 componentDidMount 里创建的方法。 更新阶段 componentWillReceiveProps componentShouldUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps componentWillReceiveProps(nextProps) Note: 每次接收到新的 props 调用。注意这里是接收到 props 就调用，但 props 的值不一定就和原来的值不一样，有可能还是相同的。在某些情况下，这会造成重复渲染。 在组件完全挂载后才会调用。在完全挂载之前是不会调用的。 可以在这里比较 props 和 nextProps, 然后更新 state, 但 setState 不会触发该方法。 shouldComponentUpdate shouldComponentUpdate(nextProps, nextState) 当每次 props 或 state 更新时调用。在首次 render 之后的每次 render 之前执行。 Note: 该方法的返回值将会影响 componentWillUpdate、render、componentDidUpdate 的执行。但在未来这一点有可能会改变。 可以在这里可以进行一些值是否相等的判断，但最好不要将对象，数组等判断放在这里，因为这可能会引起性能问题。 componentWillUpdate componentWillUpdate(nextProps, nextState) shouldComponentUpdate 方法返回 true 之后执行。 Note: 在这里不能调用 setState 方法，也不能进行 redux 的 action, 因为他会重复调用该方法。 如果需要在 state 更新后操作 props, 把这部分逻辑放在 componentWillReceiveProps. render 渲染挂载组件。 componentDidUpdate componentDidUpdate(prevProps, prevState) 在初次 render 以后的每次渲染之后执行。执行逻辑和 componentWillUpdate 一样，当 shouldComponentUpdate 返回 false 时不会执行。 应用场景：该方法总是在 DOM 存在后才会执行，所以可以在这里进行一些操作 DOM 的逻辑。也可以在这里发起一些网络请求，但前提 props 发生了更改，否则可能也会引起性能问题。 componentDidCatch (16版本引进) componentDidCatch(err, info) 捕捉异常。 try/catch 固然很好，但它会立即捕获异常。在 React 中，有时我们虽然遇到错误，但不希望影响挂载或渲染过程。所以统一在这个回调里进行处理。对用户来说，业务仍然是正常的，错误维护了 React 的生态，并不会影响组件挂载。 React 组件都必须是纯函数，并禁止修改其自身 props. 这里以图片形式更直观地来理解这整个生命周期流程 组件的生命周期流程图 PS: 截止 9 月份，React 宣布将会随着 16 版本更新，修改原有的 license， 将原专利许可和 BSD 协议改为 MIT 协议。算是给这场风波一个较为圆满的结果。参考： 1.react 2.reactchectsheet 3.reactjs","link":"/2017/08/30/react-component-lifecycle/"},{"title":"DOM 重要知识点回顾","text":"回顾部分重要的 DOM 知识点。 DOM 元素的增删改查。 获取或设置元素的属性。 DHTML 动态HTML。 一系列实现网页动态效果的技术统称。 区别: HTML：超文本标记语言，标签名固定。 XHTML：更严格的HTML语言标准。 XML: 可扩展的标记语言，标签名可自定义，语法和HTML完全相同。 JS(ECMAScript、DOM、BOM) ECMAScript(核心语法)。 文档对象模型。 浏览器对象模型。 DHTML: 7大内置对象 window: 指代当前浏览器打开窗口。 document: 指代当前页面的HTML文档。 navigator: 封装了浏览器软件的版本信息和部分设置。 history: 封装当前窗口成功浏览过的网址的历史记录栈。 location: 指代当前窗口中地址栏。 screen: 指代当前显示器。 event: 指代事件对象。 DOM 网页中一切内容都是节点(Node)对象。 所有节点对象以树形结构组织在一起(Dom Tree)。 增删查改。 DOM TREE 网页加载时生成的文档模型。 Document: Dom Tree根节点, 网页加载完成自动生成。 继承自 HTML Document 的原型，Document 的原型中提供了 document 对象可用的 API. 节点对象 元素节点对象：指代 HTML 文档中每个元素。 文本节点对象：指代 HTML 文档中的文本内容。 节点对象：所有节点对象都继承自一个父对象：Node.prototype. Body 对象：body -&gt; HTMLBodyElement.prototype -&gt; HTMLElement.prototype -&gt; Element.prototype -&gt; Node.prototype -&gt; 所有结节点共有属性. document 对象：document -&gt; HTMLDocument.prototype -&gt; Document.prototype -&gt; Node.prototype. nodeType: 元素节点(1)。 文本节点(3)。 nodeName(返回全大写形式的标签名): 元素节点(标签名)。 文本节点(#text)。 nodeValue: 文本节点(文本内容)。 元素节点(null)。 节点关系 父子关系: node.parentNode: 获得 node 对象的父节点对象。 node.childNode: 获得 node 对象的所有子节点对象。 node.firstChild: 获得 node 对象下第一个子节点对象。 node.lastChild: 获得 node 对象下最后一个子节点对象。 返回 NodeList 类型的对象。 NodeList 中的节点对象都是基于 Dom 树动态查询。 Dom 树的变化随时反映在 NodeList 中。 遍历所有子节点：1234567891011for (var i = 0; i &lt; node.childNodes.length; i++) { console.log(node.childNodes[i]);}// 每遍历一个元素，for 循环就会重新查找 childNodes 结果// 优化如下for (var i = 0, len = node.childNodes.length; i &lt; len; i++) { console.log(node.childNodes[i]);}` 兄弟关系 node.previousSibling: 获得平级对象的前一个节点对象。 node.nextSibling: 获得平级对象的后一个节点对象。 查找元素 id: var elem = document.getElementById(&apos;id&apos;). TagName: var elems = element.getElementsByTagName(&apos;tagname&apos;). elems是一个动态集合——HTMLCollection类型的对象。 随着页面 Dom 的改变实时改变。 name: var elem = document.getElementsByName(&apos;&apos;). 直接获得表单元素: var form = document.form[&apos;id&apos;].(存疑) elems = form[&apos;name&apos;]. 返回对象或者 HTMLCollection. class(HTML5): var elems = node.getElementsByClassName(&apos;class&apos;). 选择器查找: Selector API 没有兼容性问题。 原生API，执行效率高。 返回值：包含全功能，全属性的元素对象集合。 var elem = element.querySelector(&apos;selector&apos;). var elems = element.querySelectorAll(&apos;selectors&apos;). 读写元素对象内容属性 操作元素的内容：开始标签和结束标签之间的内容。 elem.innerHTML: 开始标签和结束标签的 HTML 原文。 批量替换或删除一个元素下所有子节点的最快速高效的办法。 注意点： 替换内容不要包含事件处理程序。 不是所有元素都支持: table 极其子元素，除了 td 外都不支持。 html/head/style. elem.textContent: DOM 标准。 存在兼容性问题： IE8: elem.innerText. firefox 不支持。 性能问题： 每次设置 innterHTML 时，会临时创建解释器对象。频繁设置会导致内存浪费，效率差。12345678910for (var i = 0; i &lt; values.length; i++) { ul.innerHTML += &apos;&lt;li&gt;&apos; + values[i] + &apos;&lt;/li&gt;&apos;}// 会创建多个解释器对象var lis = [];for (var i = 0; i &lt; values.length; i++) { lis.push(&apos;&lt;li&gt;&apos; + values[i] + &apos;&lt;/li&gt;&apos;);}ul.innerHTML = &apos;&lt;li&gt;&apos; + lis.join(&apos;&lt;/li&gt;&lt;li&gt;&apos;) + &apos;&lt;/li&gt;&apos;; 读写元素属性 通过 HTMLElement 类型提供的标准属性: HTML DOM. elem.[attr] 通过 get/setAttribute 函数——核心DOM. elem.getAttribute(&apos;attr&apos;). elem.setAttribute(&apos;attr&apos;). 获取或设置所有属性类型都是字符串。 可读写 HTML 元素中自定义属性。 attribute: 指 HTML 标签中属性或自定义属性。 property: 指内存中对象的属性。 前两种方法不可通用。 读写内联样式 返回一个 CSSStyleDeclaration. CSS 中的属性都是 style 对象的子属性。 所有 CSS 紫属性都返回带单位的字符串。 例如：console.log(elem.style.width); // &apos;100px&apos; 子属性的命名规则，去横线，改驼峰。 修改属性： elem.setAttribute(&apos;style&apos;, &apos;style string&apos;). elem.style.cssText = &apos;style string&apos;. 移除属性： elem.style.removeProperty(&apos;attr&apos;). 大量修改样式建议如下： CSS 中为元素的不同状态定义样式类 JS 中控制对应的样式类改变 遍历 DOM TREE 遍历：以任意元素对象开始，以深度优先的原则，获取所有子对象。 递归：函数内调用自己123456789101112var blank = [];function getChildren(parent) { console.log(blank.join(&apos;&apos;) + &apos;|-&apos; + (parent.nodeType != 3 ? parent.nodeName : parent.nodeValue)); if (parent.childNodes) { blank.push(&apos;\\t&apos;); for (var i = 0, len = parent.childNodes.length; i &lt; len; i++) { getChildren(parent.childNodes[i]); } blank.pop(); }}getChildren(document); 递归遍历 手写遍历元素树：仅包含元素节点的树结构 tree 节点数 元素树 父子节点 — — 父节点 parentNode parentElementNode 子节点 childNode childElementNode(IE8支持) 首末节点 — — 首个子节点 firstChild firstElementNode 最后子节点 lastChild lastElementNode 兄弟节点 — — 前一个 previousSibling previousElementSibling 后一个 nextSibling nextElementSibling DOM 2级遍历API NodeIterator 迭代器： 一个集合中每次金宝村一个对象的游标 游标通过前后移动在集合中遍历每个元素 迭代器1234567891011121314/** * [iterator 迭代器] * @param {Object} parentNode [开始遍历的父节点对象] * @param {String?} nodeType [选择节点的类别(NodeFilter.SHOW_ALL|NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT)] * @param {Function} filterFun [筛选器函数对象] * @param {Boolean} boolean [] * @type {[type]} */var iterator = document.createNodeIterator(parentNode, nodeType, filerFun, boolean);// 调用 nextNode 方法iterator.nextNode();// 待完善 TreeWalker: 用法和迭代器完全一样 新增了部分API，所有如下：firstChild、lastChild、previousNode、nextNode、previousSibling、nextSibling、parentNode. 操作节点创建、删除节点对象 核心 DOM. 创建：var newElem = document.createElement(&apos;tagName&apos;);12var newElem = document.createElement(&apos;tagName&apos;);// var a = document.createElement(&apos;a&apos;); 在 DOM 树中添加：1234parent.appendChild(newTag);parent.insertBefore(newTag);parent.replaceChild(newTag);... HTML DOM: 部分常用元素对象可以直接生成。123456789101112131415// 创建新对象的同事插入 tr 到 table, i 为新行位置的索引// HTMLTableElement:var newTr = table.insertRow([i]);// HTMLTableRowElement:var newTd = tr.insertCell(i);// HTMLSelectElement: onchange(),sel.selectedIndexvar sel = document.getElementById(&apos;#select&apos;); // ? 这步存疑var opt = sel.add(new Option(&apos;innterHTML&apos;, &apos;value&apos;));// 创建一个新的空对象。// 将第一个参数设置为 opt.innerHTML 属性// 将第二个参数设置为 opt.value// 将 opt 对象添加到 sel 中sel.remove(); // 移除 性能：频繁添加节点会反复解析 DOM 树，导致效率低下。 文档片段：内存中临时保存多个 DOM 节点对象的空间。12// 向文档片段中临时存入节点对象var tempFrag = document.createDocumentFragment(); 文档片段接入 DOM 树中时，不会在页面显示。 BOMWINDOW 在浏览器中代替 global 对象的全局对象。 全局作用域。 修改或设置浏览器窗口的相关属性。 打开新链接的方式 在当前窗口内替换当前页：1&lt;a href=&quot;url&quot;&gt;&lt;/a&gt;1var newWin = [window.]open(&apos;url&apos;, &apos;self&apos;); 打开新窗口，可重复打开:1&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;1var newWin = [window.]open(&apos;url&apos;[, &apos;blank&apos;] ); // 默认是 blank 打开新窗口，不可重复打开1var newWin = [window.]open(&apos;url&apos;[, &apos;blank&apos;]); 窗口定位、移动 window.innerHeight/width: 浏览器窗口可见区域的大小。 window.outerHeight/width: 浏览器窗口完整大小。 window.moveTo(浏览器窗口左上角 x 坐标，浏览器 左上角 y 坐标). window.moveBy(x 坐标的变化量，y 坐标的变化量). 在打开窗口时制定窗口大小和位置：123456789101112131415/** * [open] * @param {String} strUrl [链接] * @param {String} strName [名字] * @param {String} config [&apos;attr=value, attr=value&apos; 键值对的方式保存] */open(&apos;url&apos;, &apos;name&apos;[, &apos;config&apos;]);// 例如：window.open(&apos;www.google.com&apos;, &apos;google&apos;, &apos;resizable=no, scrollbars=yes,status=no&apos;);// config 可以写：// height/width: 窗口文档显示区大小// top/left: 窗口左上角 x 坐标，y 坐标// resizable: 是否允许调整窗口大小// location: 是否允许修改地址栏 对话框 alert(&apos;warning&apos;); var input = prompt(&apos;tips&apos;); var bool = confirm(&apos;tips&apos;); // 含两个按钮 定时器 周期性定时器：反复执行。123456789101112131415161718// 定义任务函数。// 全局变量保存定时器的 id.// 启动定时器。/** * [setInterval 周期性定时器] * @param {Function} function [须调用的函数] * @param {Number} time [间隔时间] */var timer = setInterval(fun, time);// 例如：// 定义它：var timer = setInterval(function(){ console.log(new Date());}, 3000);// 清空它：clearInterval(timer); 一次性定时器：执行一次任务后便自动退出。1234567891011121314// 定义任务函数。// 定义全局变量，保存定时器 id.// 启动定时器。/** * [setTimeout 一次性定时器] * @param {Function} function [任务函数] * @param {Number} time [延迟时长] */ var timer = setTimeout(function() { console.log(new Date()); }, 3000); // 清空它： cleatTimeout(timer); NAVIGATOR: 封装浏览器软件版本信息的对象 navigator: 检测插件。 navigator: 检测 cookie 是否启用。 chrome -&gt; 设置 -&gt; 显示高级设置 -&gt; 隐私 -&gt; 内容设置 -&gt; 禁用 navigator.userAgent: 包含了浏览器名称和版本号。 LOCATION: 封装当前窗口打开的 url 信息的对象 window.location === document.location; // true location.search: 获取 url 中查询字符串参数 在当前窗口内打开新 url:123location.href = &apos;url&apos;;window.location = &apos;url&apos;;location.assign(url); location.replace(&apos;url&apos;): 禁止后退： HISTORY: 当前窗口打开后的历史记录栈123456789// 前进history.go(1);// 刷新history.go(0);// 后退history.go(-1);history.go(-2); SCREEN screen.width/height: 完整分辨率。 screen.availWidth/availHeight: 除去任务栏后的剩余分辨率。 window.innerWidth/innerHeight: 浏览器可视区域的大小，出去控制台等。 window.outerWidth/outerHeight: 浏览器整体大小 事件：网页中，人为触发或自动触发的状态改变 事件处理程序：一个对象的特殊属性。 属性一般引用一个函数对象或 JS 程序块。 当事件发生时，自动执行绑定在属性上的程序。 例如：123456789window.onload = function() {};btn.onclick = function() {};txt.onfocus = function() {};select.onchange = function() {};// 其他div.onmouseover // 鼠标跨入边界执行div.onmousemove // 鼠标在范围内移动则执行div.onmouseout // 鼠标跨出边界执行 事件流：当事件出发时，内外层元素间的时间出发顺序 DOM 标准事件流：由外向内捕获 -&gt; 目标触发 -&gt; 由内向外冒泡触发。 IE8 事件流： 目标触发 -&gt; 由内向外冒泡触发。没有捕获阶段。 绑定事件处理程序 HTML 中设置事件属性: &lt;div onclick=&quot;javascript&quot;&gt;&lt;/div&gt; // this 必须从页面中传入 DOM0 级 API: JS 中设置对象的时间属性 obj.onclick = function() {}; // this 指代正在调用时间处理程序的元素对象 存在以下两个问题： 无法改变事件流中事件触发的顺序。 同一对象的统一吹函数，同时绑定多个函数对象。 DOM2 级标准 API: obj.addEventListener(&apos;click&apos;,function(){}[, boolean]); // 依次传入事件名，函数对象，是否在捕获阶段触发 IE8 的处理：obj.attchEvent(&apos;click&apos;, &apos;function() {}&apos;); // 依次传入事件名，函数对象 EVENT: 事件触发时自动创建，自动传入事件处理函数内(默认为第一个参数) 获取：var event = window.event || arguments[0]; // 在函数内使用 获得事件源(目标对象)：var src = event.target || event.srcElement; // this 随着事件冒泡而变化 取消冒泡： event.cancelBubble = true; // IE event.stopPropagation(); // DOM 兼容写法：if (e.stopPropagation) { e.stopPropagation(); } else {e.cancelBubble = true;} 取消事件：取消事件的默认行为，停止继续执行 if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; }","link":"/2017/02/12/review-dom/"},{"title":"回顾JS——第一部分","text":"因面试时裸面的惨痛教训，特此回顾从前所学的JS。这个办法也许很蠢，但她肯定有效。 回顾JavaScript知识点(ES3,ES5为主，部分ES6)什么是JavaScript JavaScript: JS是一种轻量的，解释性的，面向对象的头等函数语言。其最广为人知的应用是作为网页的脚本语言，但同时它也在很多非浏览器环境下使用。JS是一种动态的基于原型和多范式的脚本语言，支持面向对象，命令式和函数式的编程风格。 JavaScript的标准就是ECMAScript.截至2012年为止，所有的主流浏览器都完整的支持ECMAScript 5.1, 旧式的浏览器至少支持ECMAScript 3标准。2015年6月17日，ECMAScript的第六个版本正式发布，该版本正式命名为ECMAScript 2015, 但通常被称为ECMAScript或ES6。 网页中编写JS 使用script标签 可以写在页面的任何位置，随网页解释执行 元素的事件属性 事件触发后，才会执行事件处理程序 &lt;div onclick=&quot;window.alert(&apos;Send me a job! Please!&apos;)&quot;&gt;&lt;/div&gt; 单独的JS文件 &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; 变量 内存中一个数据的空间 JS中变量不能以数字开头，不能使用保留字，如果有多个单词，一般采用驼峰命名 可以使用_或$开头，这是唯二的例外，目前所知。 规范： 变量一定要声明，ES5前使用var，ES6后使用let或const. 变量的声明通常在文件顶部(ES5前)，避免因声明提前造成的问题。 数据类型 原始类型 Undefined: 一个没有被赋值的变量会有默认值undefined. Null: null,常用于清空变量。 String: JS的字符串类型用于表示文本数据。它是一组16位的无符号“整数值”的元素。一旦创建便无法更改。 Number: ECMAScript中只有一种数字类型：基于IEEE 754 标准的双精度64位二进制格式的值(-(2^53 - 1) 到 2^53-1)，没有像Java里的那种浮点数整数之分。 Boolean: 布尔表示一个逻辑实体(true/false). Symbol (ES6新增): 符号类型是唯一的并且是不可修改的，而且可以用来作为Object的key的值。 引用类型(Object): 对象是指内存中的可以被标识符引用的一块区域。 使用typeof操作符判断对象类型。 数据类型转换 JS是弱类型编程语言 声明变量时，无需提前规定变量的数据类型。 赋值时，根据存入数据，动态决定数据类型 运算时，JS会根据需要动态转换数据类型(隐式转换) 隐式转换和强制转换 强制转换 x.toString()、String(x) parseInt(x)、parseFloat(x) Boolean(x) typeof x 查看x的数据类型 严格模式 ES5中的严格模式是JS中的一种限制性更强的变种方式。 严格模式会将JS陷阱直接变成明显的错误。 严格模式修正了一些引擎难以优化的错误，同样的代码有些时候严格模式会比非严格模式下更快。 严格模式下禁用了一些有可能在未来版本中定义的语法。 运算 n++: 将变量本身的值+1，并返回新值 ++n: 将变量本身的值+1，并返回旧值1234var n = 12;var n1 = n++; // n1 = 13;m = 12;m = ++m; // m1 = 12; 比较操作符 严格比较操作符 === 非严格比较操作符 == Object.is()(ES6新增) Object.is(value1, value2) 和严格比较操作符类似，但更规范 关系运算 关系运算中，所有数据默认转为数字类型比较 如果无法转为数字，就会转为NaN,如果转为NaN，那不管另一半是什么，都会返回false,NaN和任何数据(包括它自己)比较 如果是俩字符串比较，则会依次比较字符串中每个字符的unicode码，只要任意一位字符比较出结果就不再继续向后比较12345var name1 = &apos;Eric&apos;; name2 = &apos;Scott&apos;;name1 &gt; name2; // false &apos;E&apos; -&gt; 69, &apos;S&apos; -&gt; 83var name3 = &apos;Smith&apos;;name2 &gt; name3; // false &apos;c&apos; -&gt; 99, &apos;m&apos; -&gt; 109 undefined: 自动初始化变量 null: 主动清空变量12345undefined == null; // true 含隐式转换undefined === null; // false 不含隐式转换typeof null // objecttypeof undefined // undefined 逻辑运算 &amp;&amp; || 位运算赋值运算 如果是原始类型赋值，则原变量不会随着新变量的改变而改变。 如果是引用类型的赋值，新变量的改动会随之影响原变量，使其一起改变。因为本质上，它们指向同一对象。 三目运算 condition ? expr1 : expr2 函数 在JS中，函数是一等公民，它不仅像对象一样拥有属性和方法，还可以被调用。 一个函数定义(函数声明，函数语句)由以下三部分组成: 函数名(name). 函数参数列表(params): 包围在括号()中并由,分隔。 函数功能(statements): 包围在花括号{}中，用于定义函数功能的一些 JavaScript 语句。 12345678/** * [square 输入一个数，返回该数的平方的函数] * @param {Number} number [description] * @return {Number} [description] */function square(number) { return number * number;} ​ 变量作用域 全局作用域 保存在全局window对象下，任何位置都可以访问 意味着也随时可以修改 函数作用域 保存在函数内：随每次函数调用时，临时创建。函数调用完即释放内存空间。再次调用再次创建。 声明提前：JS程序正式执行前，引擎会预读var和function到当前作用域的顶部，而赋值留在原地。 按值传递：在向函数传入参数时，外部变量仅将值复制一个副本给函数的参数变量。 函数内修改参数变量，不影响函数外原变量(原始类型)的值。理论同赋值运算。 全局函数，可以在全局进行调用的函数。 parseInt/parseFloat isNaN isFinite eval encodeURI/decodeURI encodeURLComponent/decodeURIComponent 程序结构 顺序结构 分支结构 if else switch case: 当一个case触发时，之后的所有的case都自动触发。 使用break来退出当前结构。 相邻俩case需要连续时，可省略前一个case中的break。 循环结构 循环三要素：循环条件，循环变量，循环体 while、do while、’for’1234567891011121314// whilevar n = 0;while(n &lt; 3) { console.log(&apos;n = &apos; + n); n++;}// n = 0; n = 1; n = 2;// do whilevar n = 4;do { console.log(&apos;n = &apos; + n);} while(n &lt; 3);// n = 4; 数组程序 = 数据结构 + 算法 数据结构：程序中数据如何存储的机构 算法：程序的执行步骤：顺序、分支、循环 数组类型 数组不限制元素个数，数组中的元素可以为任意类型 关联数组(hash数组) 为每个元素自定义字符串下标12345var arrM = [];arrM[&apos;name&apos;] = &apos;Sandra&apos;;arrM[&apos;shx&apos;] = 80;arrM[&apos;yw&apos;] = 65;arrM[&apos;yy&apos;] = 95; 关联数组的下标没规律。 关联数组的length属性无效。 使用for in循环遍历 索引数组：自动从0开始，每个元素有各自编号1var arrM = [&apos;Sandra&apos;, 80, 65, 95]; 数组常用API toString、 join、 sort 、 concat、 slice、 splice、 reverse、 reduce、 reduceRight、 map、 filter… 控制台里看一下 栈和队列(数据结构) 栈和队列：JS中没有专门的栈和队列的类型，是用数组模拟的 栈：一端封闭，只能从另一端进出（仅适用于JS） FILO：first in last out 队列：只能从末尾进入，从头出的数组 LIFO： last in first out","link":"/2017/01/15/review-js-part1/"},{"title":"回顾JS-第二部分","text":"第二部分。 JS中内置对象 String、 Number、 Boolean、 Array、 Date、 Math、 RegExp、 Error、 Object、 Function、 Global(window) 注意和基本数据类型的区别。 包装类型？：临时封装原始类型数据，并提高对数据操作方法的对象————类型名和原始类型名相同。 正则表达式 贪婪模式：默认情况下，正则表达式会匹配最大的符合条件的字符串。 懒惰模式：仅匹配最小的符合规则的字符串。 12345678// 筛选网页中的a元素// 贪婪模式 =&gt; 懒惰模式 .*?// 贪婪模式&lt;a\\s+(.*)href\\s*=\\s*[&quot;&quot;]([^&quot;&quot;]*)[&quot;&quot;]// 懒惰模式&lt;a\\s+(.?)href=\\s*=\\s*[&quot;&quot;]([^&quot;&quot;]*)[&quot;&quot;] RegExp 封装一个正则表达式，提供了利用正则表达式执行验证和查找的功能 12345678// 正则不会改变时var reg = /正则表达式/ig;// 正则可能会改变时var reg = new RegExp(&apos;&apos;, &apos;ig&apos;);// 注意转义 &apos;\\&apos;和&apos;&quot;&apos;new RegExp(&apos;^\\\\s+|\\\\s+$&apos;, &apos;ig&apos;);new RegExp(&apos;&lt;a\\\\s+(.*?)href\\\\s*=\\\\s*[\\&apos;\\&quot;][^\\&apos;\\&quot;]*[\\&apos;\\&quot;&apos;]&apos;, &apos;ig&apos;); RegExp API String: match: 所有关键内容的个数 search: 查找有没有,返回布尔值 RegExp: reg.exec(str):既获得内容，又获得位置 reg.text(str):返回布尔值 MathMath API ceil、 floor、 round、 pow、 sqrt、 random Date 每个时间都有get/set方法，除了setDay. 命名: 年月日星期不带s结尾 时分秒毫秒以s结尾 取值: 只有月中的日从1开始到31结束 其余都是从0开始，到进制-1结束 所有set方法，都会自动调整进制. 时间计算： 两日期对象相减：得到毫秒差 -&gt; 进制 -&gt; 小时 单个时间点做加减(人为操作) 取分量 做加减 set 回去 时间显示: date.toString(): 默认以标准时间显示日期 date.toLocaleString(): 将日期转为操作系统当地时间 date.toLocaleDateString(): 仅获取Date对象中的日期部分 date.toLocaleTimeString(): 仅获取 Date对象中的时间部分 错误处理 错误：程序运行过程中发生的异常状态。 错误处理：当程序发生错误时，保证程序不退出的机制。 发生错误时，程序会自动抛出一个Error对象: Error对象中封装了错误信息。 JS中的6种错误对象: SyntaxError: 语法错误。 ReferenceError: 引用错误。 TypeError: 类型错误，错误的使用了类型或类型的方法。 RangeError: 范围错误，特指函数的参数范围。 EvalError: 调用eval函数时发生的调用错误。 URLError: URL错误。 1234567891011try {// 正常执行流程(可能出错)} catch(err) {// 错误发生时执行的代码// 1. 记录/显示错误信息// 2. 继续向调用者抛出异常} [finally {// 非必须// 无论对错，必须始终执行的代码// 一般finally, 释放占用的资源}] 错误处理中的 return: 其他位置的 return 会先确定要返回的值，暂时挂起，再执行finally,finally中的操作不影响其他位置已经确定的 return 值。 finally 中有 return, 会替换其他位置的 return. 应用场景： 用户输入数据可能出现的问题。 使用个别浏览器不兼容的对象。 向服务器发送/接收消息时。 null/undefined. 抛出自定义错误 自己实现的函数，被他人调用时，为了向浏览器提示开发错误，都要主动抛出错误信息。 throw new Error(&apos;信息内容&apos;) 该代码片段后的代码不再执行 优先选择if else, 因为try catch更占资源，创建了新的变量err等等 Function对象 普通对象：封装数据，并提供对数据的操作。 函数对象：不封装数据，反而是一个可调用的对象。 重载： 多个函数(方法), 拥有相同的函数名，但不同的参数列表。调用时，可根据传入的参数值列表，自动调用匹配的函数。 当一件事可能根据参数的不同，执行不同的流程时，使用重载。 JS使用arguments对象(类数组对象)，模拟重载的效果。 函数创建方式： 123456789101112// 1. 声明方式,声明提前，可以写在任意地方function getName(name) { return name;}// 2. 直接量方式,必须写在调用地方之前var getName = function(name) { return name;}// 3. 构造函数方式(必须使用字符串包裹),执行效率低，因为在运行时动态修改函数体的内容var getName = new Function(&apos;name&apos;, &apos;return name&apos;); 内存中的函数对象(待理解) 声明函数时，创建了两个对象。 函数对象：保存函数的定义本身。 作用域链对象：顺序保存了函数可用的变量范围的地址。 默认情况下：作用域链对象只有一个元素，指向 window. 调用函数时， 在作用域链对象中追加一个新元素。 新元素指向将要创建的函数对象。 创建本次调用的活动对象。 活动对象：调用临时创建的，仅保存函数的局部变量的对象。 调用时，使用便利的优先级遵循先局部，后全局的顺序。 如果活动对象中有，就不用全局。 调用后，作用域链中指向活动对象的引用，出栈活动对象的引用出栈，活动对象变回垃圾，被回收，局部变量不复存在。 匿名函数 一个函数只被调用一次——自调的方式。 函数不是自己调用，传递给别人用——回调。 1234// 回调arr.sort(function(a, b) {return a-b;})// 自调(function(a, b){return a-b;})(); 闭包 希望共享局部变量，又不希望被随便篡改时，就要构建一个闭包结构。 使用外层函数封装受保护的局部变量。 在外层函数内定义专门操作局部变量的内层函数并返回。 在全局调用外层函数，获得内层函数的对象，保存在全局变量中反复使用。 特点： 嵌套函数。 内层函数使用了外部函数的局部变量。 内层函数对象被返回到外部，在全局反复调用。 作用：保护可共享的局部变量。 外层函数调用了几次，就有几个受保护的局部变量。 12345678910function fun() { var n = 999; nAdd = function() {n += 1;}; function f2(){alert(n)}; return f2;}var result = fun(); // 创建了一个闭包result(); // 999nAdd(); // 使局部变量n+1result(); // 1000 OOP: 面向对象程序设计 对象：程序中描述现实中一个物体的属性和功能的机构。 一个对象代表现实中的一个物体。 封装事物的属性和功能的结构。 创建对象的几种方式 对象直接量。123var obj = { key: value} 使用构造函数创建多个统一结构的对象,可以反复创建。1234567891011121314// 定义构造函数function OperateFun(name, age) { this.name = name; this.age = age; var _this = this; this.getName = function (){ return _this.name; }}// 调用该构造函数var obj1 = new OperateFun(&apos;Lily&apos;, 45);console.log(obj1.name);console.log(obj1.age);console.log(obj1.getName()); 过程中执行了以下四步： new 创建空对象空间。 调用构造函数，在对象中添加属性和功能。 将新对象的 __proto__ 属性指向构造函数的 prototype 对象。 将新对象地址，返回调用者。 创建空对象，再设置属性。123var obj = new Object();obj.name = &apos;Sun&apos;;obj.age = 17; 使用Object.create()方法创建对象。1234567891011121314151617/** * [Object.create description] * @param {Object || null} proto [一个对象，作为新创建对象的原型] * @param {Object} prpertiesObject [可选参数，属性与值] * @return {Object} [description] */// 一个原型为null的空对象var obj1 = Object.create(null);// 以字面量方式创建的对象var obj2 = Object.create(Object.prototype, { // name会是新创建对象的数据属性 name: { writable: true, configurable: true, value: &apos;Hency&apos; } }); this this: 只用于对象中的方法，访问对象自己的属性 this指代正在调用方法的当前对象 this和定义在哪无关。只和调用时的对象有关。 原型 面向对象：封装，继承，多态 原型：几种保存所有对象公用属性值的方法的对象。 每个函数都有一个属性prototype,指向自己的原型对象。 每个对象都有一个proto属性，指向创造自己的构造函数的原型(prototype). 重点作用于构造函数。 封装：将现实中一个事物的属性和功能，集中定义在程序中的一个对象里。 多态：一个对象在不同情况下显示不同的状态。JS中对多态支持不好，只讨论重写。 继承 继承：父对象中的属性值或方法，子对象可以直接使用。 设置子对象继承父对象：3种1.单独修改一个对象的父对象，不影响其他对象。 Object.setPrototypeOf(childObject, parentObject); 2.直接修改构造函数的原型对象。 不影响已创建的对象，会影响之后新创建的对象。 3.创建新对象同时，手动设置父对象。 Object.create(parentObject, null); 检查两对象之间的继承关系(包含整个原型链上的所有父对象): parentObject.prototype.isPrototypeOf(childObject); 原型链 原型链：由每个对象的proto构成的多级继承关系。 所有对象的原型链的顶部都继承自Object.prototype. Object.prototype.__proto__ === null; // true 所有函数对象的原型链一定都继承自Function.prototype. Function.prototype._proto__ === Object.prototype; // true 检查某个对象中是否拥有指定的属性或方法 检查原型链中是否包含 属性名 in 对象 =&gt; name in Object. 判断存在: if (Object.name !== undefined || Object.name) 仅检测自有属性: Object.hasOwnProperty(Object.name); 扩展内置对象的内置方法 12345678910111213141516// 给Array添加类似String的indexOf方法// 首先检查原来的原型链中是否有该方法function indexOf(value) { if (!this.indexOf &amp;&amp; !Array.prototype.indexOf) { // 疑问: 为什么这里this.indexOf in Array.prototype 会返回false // 使用this来指代当前的调用对象(数组) for (var i = 0; i &lt; this.length; i++) { if (this[i] === value) { return i; } } return -1; }}// 可以简写成以下这样Array.prototype.indexOf = Array.prototype.indexOf || indexOf;","link":"/2017/01/25/review-js-part2/"},{"title":"H5 兼容问题整理及解决方案","text":"一些 H5 的兼容问题及解决方案。推荐：★★★ Issue1 Issue2 小结 Issue1简述：input 设置为只读后，ios 中仍然可以点击。 业务场景： 页面某个表单填写完成后，手机号等剩余输入框内容设置为只读。 具体问题： input 设置为只读后，ios 上仍然可点击，可以上下切换，交互上比较怪异。 解决思路： 最初的角度是从取消元素的默认事件切入，event.preventDefault(). 但是不生效。 因为 input 的默认事件是当值变化时触发，而不是点击事件。 但我仍然觉得需要从事件的角度触发，那么 js 不行，试试 css? 查阅后发现还真有属性来控制鼠标事件 —— pointer-events 这个属性指定当前元素在什么情况下成为鼠标事件的目标。 在当前的场景下，答案自然是任何情况下，都不要成为鼠标事件目标，这样，元素变不可点击了。 解决方案： 123input { pointer-events: none;} pointer-events文档地址Issue2简述：ios 端键盘弹起后，直接关闭键盘，会导致底部区域多出一片空白——原先键盘占据的位置。 业务场景： 在某些申请贷款的业务场景里，存在页面有许多输入项，输入内容几乎占据整个页面。如下图。 具体问题： 输入内容较多时，当较底部的输入项输入完毕后，直接关闭键盘，底部会多出空白的键盘区域，整个页面布局上移，表面上元素正常显示，但元素内容的点击事件等却错位，导致 bug 产生。 解决思路： 比较直观的思路是，监听键盘关闭的事件，然后手动将页面滚动至底部。 但事实是，没有直接监听键盘关闭的事件，小程序中有，但 H5 中没有。 于是要从侧面去判断，有两个方向。 一个是监听页面大小变化——键盘的弹起收回是否会引起页面整体高度变化。 另一个是监听输入框失焦——输入完毕后，点击键盘，输入框自然就失焦了。 查阅后，发现监听大小的方式，在 ios 中不生效，因为它并没有改变页面整体大小，而是把页面往上推移，因此不予采用。 那么就要从输入框失焦的角度。 查到了事件 focusin 和 focusout. 并且这两个事件是可以冒泡的，因此可以直接绑定在 body 上。这时，以为解决了，惊喜的写下: 12345678910111213141516componentDidMount() { /** * [失焦时控制的滚动事件] * @param {[type]} e [description] */ this.handleScroll = (e) =&gt; { document.body.scrollIntoView() } document.body.addEventListener(&apos;focusout&apos;, this.handleScroll)}// 别忘了卸载事件componentWillUnmount() { document.body.removeEventListener(&apos;focusout&apos;, this.handleScroll)} 当在手机上实际操作时，尽管每次点击键盘上的关闭，屏幕底部不再出现空白，但却发现输入完每一项，不关闭键盘而直接进入下一项时，页面都会自动向下滚动一次，直接滚到底部，输入框并不在屏幕正中了，体验十分不好。 那，既然每次滚动到底部的体验不好，就每次让他滚动到输入的当前位置，使得输入项仍在屏幕中央，用户是可见的。 要实现这样的效果，就需要每次记录下页面滚动的距离。在 focusin 方法中记录。 1234567891011121314151617181920212223242526// 这里使用了一个兼容的获取滚动距离的函数function getScrollTop() { return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop}componentDidMount() { /** * [聚焦时记录下滚动距离] * @param {[type]} e [description] */ this.recordScroll = (e) =&gt; { this.scrollTop = getScrollTop() } this.handleScroll = (e) =&gt; { document.body.scrollIntoView() } document.body.addEventListener(&apos;focusin&apos;, this.recordScroll) document.body.addEventListener(&apos;focusout&apos;, this.handleScroll)}componentWillUnmount() { document.body.removeEventListener(&apos;focusin&apos;, this.recordScroll) document.body.removeEventListener(&apos;focusout&apos;, this.handleScroll)} 输入时乱滚到底部的现象没有了，每次他都会乖乖滚到当前的位置。但是……每次都滚动，给人的感觉还是很怪异，尤其是这里有这么多输入的场景。还是得想办法控制滚动，能不能只在关闭的时候滚动。 先究其原因，focusout 事件是冒泡的，因此每一个 input 的失焦事件，都会向上冒泡，而我们从上到下切换输入框时，实际上触发了上一个 input 的失焦事件，从而冒泡至 body. 引发滚动。 要解决，就要区分这类的失焦事件和关闭键盘的失焦事件，然而实际上，并没有专门分方法或属性来区分事件。这里的判断仍然要靠我们自己。 没有办法直接判断，那就每次都执行，但，也每次都取消，直至最后一次。 最终的解决方案有些类似于函数防抖，在每次聚焦时取消失焦时注册的事件，从而让最终的失焦事件触发。 这里，只有输入框相关的事件，因此我们会做判断，以避免其他意外情况。 解决方案： 1234567891011121314151617181920212223242526272829303132333435363738// 这里使用了一个兼容的获取滚动距离的函数function getScrollTop() { return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop}componentDidMount() { /** * [聚焦时取消失焦时注册的事件] * @param {[type]} e [description] */ this.recordScroll = (e) =&gt; { if (e.target &amp;&amp; e.target.tagName === &apos;INPUT&apos;) { window.clearTimeout(this.timer) this.scrollTop = getScrollTop() } } /** * [失焦时设置定时器异步触发事件，并记录返回值以供取消] * @param {[type]} e [description] */ this.handleScroll = (e) =&gt; { if (e.target &amp;&amp; e.target.tagName === &apos;INPUT&apos;) { this.timer = window.setTimeout(() =&gt; { document.documentElement.scrollTop = this.scrollTop; document.body.scrollTop = this.scrollTop; }, 10) } } document.body.addEventListener(&apos;focusin&apos;, this.recordScroll) document.body.addEventListener(&apos;focusout&apos;, this.handleScroll)}componentWillUnmount() { document.body.removeEventListener(&apos;focusin&apos;, this.recordScroll) document.body.removeEventListener(&apos;focusout&apos;, this.handleScroll)} focusin文档focusout文档小结 有段时间没有开发 H5 内容了，兼容性上还是踩了不少坑，这里取了两个比较有代表性也比较常见的，解决方案可以参考，或者互相探讨是否有更好的解决方案，后续如果有新的问题，也会一一记录。","link":"/2019/11/30/something-about-h5/"},{"title":"sublime text插件安利之wakatime","text":"今天发现一款十分优秀的插件，可在各种编辑器中使用,我在sublime中首先使用了它。 万能的它还支持Vscode，Vim,Atom,Webstorm,甚至Chrome中也可使用。 Wakatime 这是一款我觉得非常优秀的插件，以至于我愿意单独把它拿出来说明它的正确打开方式。 通过sublime的常规下载插件方式即可下载。 下面简单说明使用。 官网文档里说的比较详细了，下载后设置api_key参数，就像设置sublime的配置一样。 Awesome Part 来看看令人激动的部分。 1 首先它可以看到每天在编辑器上所花的时间，以及所使用的语言，甚至修改过的文件。 可以看到我每天在各种js之间切换。ts,cs,es6……下面是具体文件 2 还有在各种编辑器上或各种项目上所花的时间。 我也在各种项目和编辑器之间切换(好不专一)。 3 甚至每个项目上具体文件所花的时间。 4 只要connect至gitlab或github，甚至也可以查看commit。 目前支持主流的前端编辑器Vscode,Atom,Vim,Webstorm… 小结：再也不用担心自己碌碌无为的时间都不知道花哪儿去了。让wakatime告诉你答案！","link":"/2016/09/21/sublime-text-plugin-wakatime/"},{"title":"浅谈JavaScript API设计原则","text":"__近期整理项目，发现有一些api的写的比较好，风格统一，流畅，可以对比学习。下面罗列一些设计api时应当遵循的原则。以web-order仓库为例。__ 1.流畅性 简单易懂 1234567891011var a = _.pick(obj, [&apos;name&apos;, &apos;age&apos;, &apos;address&apos;]);_.pick是lodash的方法，从对象obj中取出name和age，address属性。但是这个操作需要经常调用，完全可以封装起来。function a(obj){ return _.pick(obj, [&apos;name&apos;,&apos;age&apos;,&apos;address&apos;]);}这样每次调用a方法即可。明确易用。 可读性 1234567891011一开始接手这个web-order的时候，我是非常头疼的。到处是函数式编程，一层嵌套一层。这个时候如果没有交接，代码对新接触的人来说是非常痛苦的，所以有必要增强方法的可读性。下面是整理过后的：function generateChoosenPeople(people){ return _.pick(people, [&apos;name&apos;,&apos;age&apos;,&apos;address&apos;]);}获取选中的人————名字即说明了该函数做的事情，可读性较好。但是，还有一点并不太令人舒服的地方，就是名字取得太长了。容易读懂，但不容易记住，也不方便使用。所以就需要下一点。 减少记忆成本 1234567将名字简化：function getMan(man){ return _.pick(man, [&apos;name&apos;,&apos;age&apos;,&apos;address&apos;]);}这样既简明，也方便调用。 2.一致性 api的一致性 现在的项目中，一个人开发一个项目的情况非常少见，而且即使一个人开发，代码的风格统一也是很有必要。更何况通常是多人开发。目前遇到的最头痛的一个问题，不是不知道一个问题怎么解决。而是要尝试解决的时候要先上手，看懂别人的代码，毕竟总不能说重写就重写。 请看下列方法取名： 12345closeTips();closePrintModel();printChoosenOrder();getListByOrderPackage();getOrdersLength(); 对这些方法的第一印象是很长。但仔细看，api命名风格是统一的。各方法做什么事都在名字中已体现。一目了然，清晰明确。大大减少上手时间。 规则很简单： 1.一律采用驼峰命名，首字母小写。 2.第一个单词是动词。 3.错误处理 预见错误并处理错误 在第一个示例中提到的方法，getMan,要求传入的参数是对象，但如果传入的是数组或是字符串呢，这个时候就需要对参数进行检查并抛出错误。 对方法改写如下： 1234567891011function getMan(man){ if (Array.isArray(man) || typeof order !== &apos;object&apos; ) { console.error(&apos;param a must be type of string&apos;); return; } return _.pick(man,[&apos;name&apos;,&apos;age&apos;,&apos;address&apos;]);}当传入参数不符合条件的时候，先抛出错误。先判断是不是数组，然后再判断是不是对象，否则就抛出错误。 另一个常见的是ajax请求的错误处理，最先接触ajax的时候，从没想过请求失败的情况。经同事提醒，才了解到这样对用户很不友好。 上一个最早写的ajax请求,用angularjs的http： 1234$http.get(&apos;http://123lalala.com/test&apos;).then(() =&gt; { // do something...}) 这种情况只考虑了正常的情况下所做的操作，没有考虑其他情况。 其实很简单，只要再加上一段。但是之后对用户就友好许多，增加了错误提示。 12345678$http.get(&apos;http://123lalala.com/test&apos;).then(() =&gt; { // do something}, (err) =&gt; { console.error(&apos;请求失败&apos;); // or window.alert(&apos;请求失败&apos; + err.msg);})4.后续如果有补充再更新，有疑问或指正请提出。","link":"/2016/06/23/talk-about-JavaScript-API-design/"},{"title":"升级 MacOs Mojave 后的兼容问题解决","text":"升级 MacOs Mojave 后不免会遇到兼容性问题，这里列举几个自己遇到的，后面列出了解决方案。推荐：★★☆ 索引 问题概览 小结 参考 问题概览 终端启动报错 xcode运行报错 vim报错 终端启动报错问题描述 打开终端时，直接报错 manpath: error: unable to read SDK settings for &apos;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk&apos; 解决方案 升级 xcode 和 commandline tools. 在应用商店里升级 xcode 后，运行 xcode-select --install. 再重启终端即可。 xcode运行报错问题描述 打开 xcode 跑项目时，之前可以跑的项目无法运行。 解决方案 打开 File =&gt; Project Setting, 将里面的 Build System 的 New Build System 选项改为 Legacy Build System. 升级前就是这个选项 Legacy Build System. vim报错问题描述 在运行 git commit --amend 等不直接使用 vim 的命令时，报错。 12345Vim: Caught deadly signal SEGVError detected while processing function 70_PollServerReady[7]..70_Pyeval:Vim: Finished.line 4:Exception MemoryError: MemoryError() in &lt;module &apos;threading&apos; from &apos;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc&apos;&gt; ignored 解决方案vim 直接报错 重新下载 vim. 运行 brew install vim --with-lua --with-override-system-vi 重启 shell. 如果是 vim 直接打开的报错。那么以上步骤可以解决问题。 vim 其他报错 如果是在运行其他命令时出现该报错。则很可能是 YouCompleteMe 插件的问题。 首先继续执行上述重新下载 vim 的步骤。 然后进入对应目录下。 cd ~/.vim/bundle/YouCompleteMe 更新代码插件的代码。 git pull 更新子模块的代码。这步很重要，不能遗忘。 git submodule update --init --recursive. 更新后需要重新编译插件，在当前目录下执行编译。 python install.py 如果不编译，会出现这样的报错。 The ycmd server SHUT DOWN (restart with &apos;:YcmRestartServer&apos;). YCM core library too old; PLEASE RECOMPILE by running the install.py script. See the documentation for more details. 问题解决。 如果报错依然存在，试试在 ~/.vimrc 文件中先将 YouCompleteMe 插件注释，再取消注释后重启。 小结 以上是目前在升级系统后遇到的兼容问题，都得到了解决。后续再遇到问题，再进行补充。 参考Update MacOS to Mojave, then vim get error with powerline更新 macOS Mojave 后 vim 打不开","link":"/2018/11/23/the-compatibility-issues-in-macos-mojave/"},{"title":"Sublime Text 3 高效插件配置","text":"不久前，sublime text 官方推出了一次大更新。这次更新几乎时隔一年，而且有重大改动，虽然我早用 dev 版提前体验了新版本，但也借此机会再鼓捣了下自己的工具。 索引 Sublime Text 插件 Sublime Text 下载 插件1. Git 在 sublime 内使用 git. 因为我个人是在终端使用 git. 所以日常 git 不会在这里提交。但有一个比较实用的功能是查看当前文件的修改历史。比在终端里用 git log -- [file] 查看会方便一些。 在命令面板输入 git log current file 可以查看当前文件修改历史，查看有谁改过当前这个文件和具体改动了什么。 2. Git blame 查看当前行的修改历史。比前一个插件更加具体，直接查看当前行的最近一次改动负责人和提交记录。 git 插件也有该功能，但使用起来不如这个方便。 3. GitGutter3.1 Modific 在行号前形象地显示当前的改动差异。 后者也是一个可以显示改动的插件——但是它还支持 SVN 等。可选其一使用。 4. SublimeLinter、SublimeLinter-contrib-eslint4.1 Babel sublime 编辑器内可以配合 eslint 使用来检查代码规范或是代码风格。只是要两个插件配合使用。 两个插件下载完毕即可使用。 如果没有生效的话，可以打开 sublimelinter 的用户设置检查 node 的路径是否正确，或者是否安装了相应的版本。 sublimelinter 官网还有更多使用配置。 该插件对使用 jsx 语法的 js 文件支持不太友好，所以你可能还需要这一个插件 Babel 来解析文件。 5. React ES6 Snippets5.1 React Snippets 写 react 非常实用的 snippets. 如果还没有使用 ES6 的话，那就使用后者。 其他框架自然也有。AngularJS、Vuejs Snippets、Vue Syntax Highlight、j​Query. 6. DocBlockr 友好的注释插件。支持 Javascript, PHP, CoffeeScript, Actionscript, C &amp; C++ 等。 7. cssDOC 右键在 MDN 上查询属性相关信息。快捷方便。 7.1 CSS3 CSS3 自动补全，高亮，检查插件。 7.2 CSS Format CSS 格式化插件，统一格式。 8. SyncedSideBar 打开文件时侧边栏定位到当前文件。在查看文件时会十分方便。 9. BracketHighlighter9.1 BracketGuard 高亮括号对应项。 后者高亮使用错误的括号。 10. Material Theme、DA UI 最后推荐两款清爽的浅色主题。以下是效果图。 清爽干净的 UI,是不是对最新版 sublime 已经跃跃欲试了呢。 下载Sublime Text 在此。嫌 sublime 万年不更的小伙伴可以下载 dev 版 ，其实暗地里啊，它更新地比 vsc 还勤呢。题外话 在这个 vsc 分了半边天的代码工具里，我还是对 sublime 情有独钟。甚至我对 vim 也有着自己的偏爱。即便 vsc 或者 webstorm 方便到了令人发指的地步，我也希望还有人能坚守 sublime 等轻量级编辑器的阵地。因为我喜欢这个鼓捣的过程，喜欢把自己需要的东西一步一步手动加上去的过程，在这个过程中，会更加理解自己需要什么，不需要什么，对那些新增的插件的下载和使用也会有新的理解。而且我也相信有许多程序员和我有着相同的癖好。 偶尔我也会试用 vsc，但确实用不习惯。在丝滑流畅这一点上，它和 sublime 比还有一定的差距。而它相较于 sublime 的优势在我使用时却没有明显体会。类似直接查看函数的定义的功能，我反而认为自己去寻找可以更了解项目的整体结构。最终还是一句话，自己使用起来最舒服的工具就是最适合自己的工具。","link":"/2017/10/07/the-introduction-of-sublime-text-plugins/"},{"title":"有关 getaddrinfo 报错的解决","text":"有关 getaddrinfo 报错的解决方式。 问题 近期在配置新项目环境的时候遇到了如下问题： 123456events.js:72 throw err;Error: getaddrinfo ENOTFOUND talk.bb at errnoException (dns.js:37:11) at Object.onanswer [as oncomplete] (dns.js:124:16) 经提示后发现是host配置的问题。 因为项目的配置 gulpfile.coffee 文件里是这样的： 12345server.listen config.webpackDevPort, &apos;talk.bb&apos;, (err) -&gt; if err? throw new gutil.PluginError(&apos;webpack-dev-server&apos;, err) gutil.log &apos;[webpack-dev-server] is listening&apos; cb() 这里的 talk.bb 实际上是替代了 localhost 作用，虽然目前在接手这项目的时候还不知它的作用，但就此去解决的方法就是在 host 文件下增加 talk.bb 配置。 解决 修改电脑的 host 配置，以管理员身份修改，运行 sudo vim /etc/hosts.可见文件如下： 123127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost 在其中增加 talk.bb 即可，如下： 1234127.0.0.1 talk.bb127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost * *不知这类的问题算不算是计算机基础问题，依然还有很长的路要走……*","link":"/2017/01/23/the-problem-about-host/"},{"title":"webpack-dev-server 中代理(proxy)相关问题的解决及反思","text":"记一次工作中踩的坑。坑不大，但耗时非常长。 问题 近期刚加入新公司，配置环境方面踩了非常多的坑。有的最后发现其实是非常简单的原因导致，有的到最后也没有找到原因。这里记录一个最近发生的，让自己头疼了很久的问题，最后的解决方式并不难，但解决的过程值得记录和反思。 新项目中使用了 gulp 来配置 webpack, 其中也包括了 webpack-dev-server. 问题便来自于这里。 首先来看看代码： 12345678910# gulp 中一个很普通的 task, 使用 coffeescript 编写gulp.task &apos;webpack-dev&apos;, (cb) -&gt; webpackServer = publicPath: &apos;/&apos; hot: true stats: colors: true proxy: &apos;/api/&apos;: target: &apos;http://localhost:8000&apos; 这里使用了 webpack-dev-server 的 proxy 配置来代理请求，将原 /api/发起的请求发往 localhost:8000, 看起来似乎没有什么问题，实际上也并没有问题所在。 然而，因为某些未知 bug, 我不得不更改 proxy 的 target 对象。实际上，个人认为，前端在调试时，使用本地的后端服务并不恰当，最好是在 dev 环境上进行接口调试。dev 环境提供的服务至少稳定。 因为那该死的 bug, 和刚才说明的考虑，我将这个 target 指向了公司的 dev 站点。 改动很少，大致如下: 12345gulp.task &apos;webpack-dev&apos;, (cb) -&gt; # ... proxy: &apos;/api/&apos;: target: &apos;http://chat.dev.cn&apos; 本以为不会有任何问题，小小的改动怎会引起巨变。然而，坑就这样产生了。开发环境中的 xhr 请求无法请求到原来的接口。但在浏览器中直接打开 http://chatops.dev.cn/api/user 却能得到应有的结果。这让人烦躁，让我心慌。 解决过程 最初碰到这问题的时候，我一脸懵逼，第一反应是这属于 nodejs 相关的问题，但我对 nodejs 接触不多，想到要从一无所知的事物下手，心情更加烦躁。 待冷静下来后，首先想到的是跨域问题。既然 chrome log 里涉及到了 xhr, 那么从跨域的角度或许能找到线索。 不幸的是，我发现，这个代理请求是 nodejs 发出的，并不是浏览器发出，既然不是浏览器发起，那也没有跨域这一说。 随即我反应过来，既然是 webpack-dev-server 的问题，那么从官方文档查看或许会有进展。果然，文档中有如下说明并列举了使用方式。 Proxying local virtual hostsIt seems that http-proxy-middleware pre-resolves the local hostnames into localhost, you will need the following config to fix the proxy request: 我根据文档修改，于是得到如下结果： 1234567891011gulp.task &apos;webpack-dev&apos;, (cb) -&gt; # ... proxy: &apos;/api/&apos;: target: host: &apos;chat.dev.cn&apos; protocol: &apos;http:&apos; port: 80 ignorePath: true changeOrigin: true secure: false 这时我怀着激动的心情重启服务，却得到了失望的结果——接口请求到了，返回的格式却是’text/html’. 一定是有哪里出了问题，但无从得知。心情更加烦躁。 从刚才 webpack-dev-server 的说明中，我又查阅了 http-proxy-middleware 的相关文档，里面有它自己相关的说明，但和 webpack 相关的仍然一无所获。 无奈之下，第一反应是回到万能的 google, 提取关键字 webpack-dev-server 和 proxy，几乎漫无目的搜索后，并没有发现有用的解决办法。 于是我又想到 github issues, 在 webpack-dev-server 开源项目中查找相关 issues, 的确有部分 proxy 的疑问在，但仍然没有可提取的信息。 stackoverflow 上也是同样的结果。这几乎是我最绝望的时刻。 冷静下来，我开始反思，是不是一开始就走错了路。于是我回到了官方文档上，逐一试探。 在尝试了 quiet 选项之后无效。 将端口改为本地一样的 8000 也无效。 我想，虽然不是跨域，但 origin 应当是更改的，changeOrigin 应保留。而 secure 在基础配置里也有，应当也不是。于是我再尝试修改 ignorePath 的值，重启之后，发现竟然成功了。 最后的代码如下： 1234567891011gulp.task &apos;webpack-dev-server&apos;, (cb) -&gt; # ... proxy: &apos;/api/&apos;: target: host: &apos;chat.dev.cn&apos; protocol: &apos;http:&apos; port: 80 ingorePath: false # 默认即为 false,注释掉也可以 changeOrigin: true secure: false 回顾与反思 这个问题，前前后后困扰了我近一个工作日的时间，跨度有好几天。每天都花费了一定的时间在上面，直至今天，用了近半天的时间才得以解决。 事实上，这个问题的本质我还是没有发现，我只是简单地让他生效，并不知其中的原因。等到发现根本原因，理解透彻之后，再回来更新这里。 在解决这个问题的过程中，我先后想到 nodejs, 跨域，官方文档，google, github issues, stackoverflow 到最后回到文档。仔细想想，其中有部分是可以避免的，比如在漫无目的的使用 google 时，搜索的效果其实并不好，提取关键字也不够到位。 而且在每个过程之间，都有一定的时间跨度，这是不足之处。因为在前一种方式尝试过后难以平复失败时的焦躁心情，不能冷静的思考其他可能，才浪费了许多时间。 另外，要拥有一种任何问题都可以搞定的心态，没有搞不定的问题，只有没有信心的人。问题总是可以解决的，只不过有的解决方式并不那么完美，但也许睡过一觉再醒来，再想想，就会发现新的角度。如果一个问题暂时无法解决，那就好好睡一觉，第二天继续干。","link":"/2017/03/07/the-problems-in-using-webpack-dev-server/"},{"title":"面试题整理-2018","text":"P6 的标准。这里所有的题都应该十分熟悉。推荐：★★★☆ Part 2 2018版 JavaScript 类型判断 函数防抖和函数节流 浅比较和浅拷贝的实现 函数柯里化 ES6 Promise React CSS BFC 行内元素 浏览器 同源策略 跨域方案 前端安全 其他 JavaScript酷家乐面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 引用类型(引用值传递和堆栈模型，这是最主要的)var a = { b: 1}function changeA(obj) { obj.b = 2 return obj}let aa = changeA(a)console.info(a.b) // 2console.info(aa.b) // 2aa = { b: 3}console.info(a.b) // 2console.info(aa.b) // 3// 事件模型var len = 6for (var i = 0; i &lt; len; i++) { setTimeout(function() { console.info(i) // 6 个 6，异步执行宏任务 }, 1000)}console.info(i) // 6 异步执行，所以这里优先打印// 考察类型判断和声明提前function temp() { console.info(typeof bbb) // undefined console.info(typeof f) // function 声明提前 bbb = 1 function f() {}}console.info(typeof temp()) // undefined 没有 return 返回值// 匿名函数 this 指向 windowvar obj = { getBar: function() { return this.bar }, bar: 1};(function() { return typeof arguments[0]() // undefined 相当于 typeof window.bar})(obj.getBar)// 不用循环实现一个工具函数 f(n, v), 生成 n 个 v 的数组。递归function f(n, v) { return n &lt; 1 ? [] : [v].concat(f(n - 1, v))}f(10, 1) var 变量声明及原型1234567891011121314151617181920212223242526272829303132function Foo() { getName = function() { console.log(1) } return this}Foo.getName = function() { console.log(2)}Foo.prototype.getName = function() { console.log(3)}var getName = function() { console.log(4)}function getName() { console.log(5)}// 请写出以下输出结果Foo.getName(); // 2getName(); // 4 函数直接量的定义会声明提前从而被 var 声明的所取代Foo().getName(); // 1 window.Foo().getName() this 指向 windowgetName(); // 1 由于调用了 Foo().getName()，而该方法\b内没用 var/let 声明的变量，都是 window 的，因此 window 上的 getName 被改写new Foo.getName(); // 2 函数的属性方法调用new Foo().getName(); // 3 函数的原型链上的方法随着继承而调用new new Foo().getName() // 3 函数的原型连上的方法随着继承而调用// 原型var obj = {}obj.__proto__ // Object.prototypeObject.__proto__ // function() {}Object.prototype.__proto__ // nullFunction.__proto__ // function() {}Function.prototype.__proto__ // Object.prototype 类型判断 typeof instanceof： 测试构造函数的 prototype 是否出现在对象的原型链之中。由于 prototype 是可更改的，所以同样的表达式不一定会返回一样的结果。 object instanceof constructor 1234567891011121314151617181920typeof [] === typeof {} // &apos;object&apos;typeof Object === typeof Array // &apos;function&apos; 构造函数typeof null // &apos;object&apos;typeof undefined // &apos;undefined&apos;typeof NaN // &apos;number&apos;111 instanceof Number // false&apos;111&apos; instanceof String // false// 因为它们都不是用构造函数实例化的对象，所以不是// 下面则是var num = new Number(111)num instanceof Number // truevar str = new String(&apos;curry&apos;)str instanceof String // true{} instanceof Object // 报错[] instanceof Array // true[] instanceof Object // true// 通常的判断Object.prototype.toString.call(obj) 函数防抖和函数节流 函数防抖：频繁调用的事件，在事件触发超出时间间隔时才执行，当一次事件执行时，后一次要等时间间隔过去才能再次执行 应用场景：输入框校验，输入完成后进行。 函数节流：指定时间间隔内只触发一次，在间隔内触发多次，则只有一次生效 应用场景： scroll 到底部的判断，debounce 的话只有停止滚动才判断。所以是 throttle. 拖拽，缩放事件等。resize, scroll，mousemove 事件等。 输入框搜索联想 keyup 时间等。 在线 Demo-直观清晰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * [debounce 函数防抖] * @param {Function} fn [执行函数] * @param {Number} delay [延时时间] * @return {Function} [返回函数] */let debounce = (fn, delay = 100) =&gt; { let timer = null // 使用非箭头函数，这样可以获取 arguments 对象 return function () { // 清除上次定时器, 定时器可以用变量保存 if (timer) { clearTimeout(timer) timer = null } timer = setTimeout(() =&gt; { // 这里类数组对象可以作为参数传入 fn.apply(this, arguments) }, delay) }}/** * [throttle 函数节流] * @param {Function} fn [执行函数] * @param {Number} delay [延时时间] * @return {Function} [返回函数] */let throttle = (fn, delay = 100) =&gt; { let isRunning = false // 使用非箭头函数，这样可以获取 arguments 对象 return function () { if (isRunning) { return } isRunning = true setTimeout(() =&gt; { fn.apply(this, arguments) isRunning = false }, delay) }}// 举例let throttleEvent = throttle(() =&gt; { console.info(new Date().getTime())}, 1000)let debounceEvent = debounce(() =&gt; { console.info(new Date().getTime())}, 1000)window.addEventListener(&apos;scroll&apos;, debounceEvent) // 不恰当，只为看效果window.onresize = throttleEvent 函数柯里化 蚂蚁的题。 1234567891011121314151617181920212223242526272829303132function sum(a, b, c) { return a + b + c}var currySum = curry(sum)// currySum(1)(2)(3) = sum(1, 2, 3) // 实现这样的效果// 兼容参数个数的实现function curry(fn, args) { let arr = args || [] // 入参，在第二次调用时会有初始值 let len = fn.length // 函数参数的数量 return function () { res = arr.concat(Array.prototype.slice.call(arguments)) // 传入的参数与原来的参数整合 // 参数长度不足时，仍然传入原函数 if (res.length &lt; len) { // 调用柯里化函数，并传入原函数和参数 return curry(fn, res) // 等同于 curry.call(null, fn, res) // 参数长度足够时，输出结果 } else { return fn(...res) // 等同于 fn.apply(null, res) } }}currySum(1)(2)(3) === sum(1, 2, 3) // 6// 30 秒代码上的实现，更加简约// 该地址已失效：https://30secondsofcode.org/function#curry// https://www.30secondsofcode.org/js/s/curry/// args 这里不是很理解const curry = (fn, len = fn.length, ...args) =&gt; { return len &lt;= args.length ? fn(...args) : curry.bind(null, fn, len, ...args)} ES6Promise12345678const wait = ms =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms))wait().then(() =&gt; console.info(4))Promise.resolve().then(() =&gt; console.info(2)).then(() =&gt; console.info(3))console.info(1)// 1 2 3 4// 传递到then中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在JavaScript事件队列的所有运行时结束了，事件队列被清空之后才开始执行.// 微任务(promise)优先于宏任务(setTimeout)执行。 Promise 串行的实现 reduce 方法的思路123456789101112131415161718192021let a = (v = 0) =&gt; { return Promise.resolve(v + 1)}let b = (v = 0) =&gt; { return Promise.resolve(v + 3)}let c = (v = 0) =&gt; { return Promise.resolve(v + 5)}let arr = [a, b, c]function handlePromiseList(arr) { return arr.reduce((promise, fn, index) =&gt; { console.info(`当前是 ${index}`) return promise.then((res) =&gt; { return fn(res) }) // 需要传入初始值供链式调用 }, Promise.resolve())}handlePromiseList(arr) TODO: 循环的思路 for in 和 for of 区别 两者在循环数组时，前者循环出的是 key, 后者循环出的是 value 后者是用来迭代可迭代对象(Array, Map, Set, String, TypedArray, arguments)，但不包括对象 Object for in 可以迭代出原型上的属性 for in 和 Object.keys 的区别 Object.keys 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for in 循环遍历该对象时返回的顺序一致。 它们的区别在于 Object.keys 只循环对象的可枚举属性。 for in 则循环对象的可枚举属性和对象的原型链上的可枚举属性。 浅比较和浅拷贝的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 这里的 shallowEqual 就是浅比较，这个方法经过小部分的扩展，也可以实现 Object.assign 方法，后续补充上// 内部实现其实主要依赖于 es6 的一个方法 Object.is// 它类似于 === 的功能，但补充了 === 在比较时的不足，// 例如 +0 === -0 和 NaN === NaN 这两种特殊情况// 这里做一个模拟 Object.is 的实现/** * [is 其实就是 Object.is] * @param {Any} a [description] * @param {Any} b [description] * @return {Boolean} [description] */function is(a, b) { if (a === b) { // 处理 +0 === -0 返回为 true return a !== 0 || b !== 0 || 1 / a === 1 / b } else { // 处理 NaN === NaN 为 false 的情况 return a !== a &amp;&amp; b !== b }}/** * [shallowEqual 浅比较] * @param {Any} obj1 [description] * @param {Any} obj2 [description] * @return {Boolean} [description] */function shallowEqual(obj1, obj2) { // 对基本数据类型的比较 if (is(obj1, obj2)) return true // 这里是对上述遗漏的基本类型的对比的补充，但暂时没想到在哪些情况下会进入到此逻辑中 if (typeof obj1 !== &apos;object&apos; || obj1 === null || typeof obj2 !== &apos;object&apos; || obj2 === null ) { return false } const keys1 = Object.keys(obj1) const keys2 = Object.keys(obj2) // 如果长度不等，直接返回不等 if (keys1.length !== keys2.length) return false // 相等时，再做遍历的比较 for (let i = 0; i &lt; keys1.length; i++) { let key = keys1[i] // 使用 hasOwnProperty 来判断在 obj2 中是否有 obj1 的方法 if (!Object.hasOwnProperty.call(obj2, key) || !is(obj1[key], obj2[key])) { return false } } // 到此结束，也就是说，无法在对象的属性里再比较对象类型的数据 // 如果要深比较，则涉及到递归遍历，下次再拓展 return true} TODO 深拷贝的实现实现 Array.prototype.map 方法 链接中的方法更完善，此为简易版。 12345678910Array.prototype.map = function (callback) { if (!Array.isArray(this)) { throw new TypeError(&apos;Param must be Array&apos;) } if (typeof callback !== &apos;function&apos;) { throw new TypeError(&apos;callback is not a function&apos;)} let res = [] let len = this.length for (let i = 0; i &lt;= len - 1; i++) { res[i] = callback(this[i], i, this) } return res} 12345678910const a = [1, 2, 3, 4, 5]a.multiply() // [1, 4, 9, 16, 25]function multiply() { if (!Array.isArray(this)) { throw new Error() } return this.map((item) =&gt; { return item * item })}Object.assign(a.__proto__, { multiply }) jsonp实现原理及具体实现 蚂蚁面试时被问到了 jsonp 的实现原理，虽然答出了原理，但具体的实现逻辑有所遗忘，这里做一个简易版但是是完整的实现。 利用 script 标签可以跨域请求资源的原理。 1234567891011121314151617181920/* * 回调函数，服务端响应数据后执行 */function handleCallback(res) { console.info(res.data)}function handleJsonp() { let script = document.createElement(&apos;script&apos;) script.src = `http://justexample.com?callback=handleCallback` script.type = &apos;text/javascript&apos; document.body.appendChild(script)}handleJsonp()// 服务端的返回应当是这样，这里是 nodejs 的写法// `${callback}(${callbackData})`// handleCallback({ data: &apos;bad view&apos; })// 然后客户端执行 handleCallback 函数，打印出结果 import 和 require 的区别 规范: import: ES6 的语法规范——模块化方案。仅在现代浏览器上支持，在其他浏览器上需转成 ES5 运行，也就是说其实仍然是转成 require 的方式运行。 require: nodejs 提供的社区方案，遵循 CommonJS/AMD 规范。 调用时间： import: 编译时执行。因此必须放在文件开头。 require: \b运行时加载。当首次调用时，会执行请求的文件的脚本代码，执行后生成一个对象在内存中。之后再引用时，并不会重新执行代码，而是从缓存中读取对象。 循环取值的情况。 官方文档 阮一峰解读 本质： import: 值引用，所取的值仅仅是可读的。见下文。数据无法重新赋值，基础数据类型无法更改，对象类型无法赋值，但可以定义属性。在React中查看 require: 值拷贝，浅拷贝。基础类型相当于直接赋值。对象类型，相当于获取了值，并浅拷贝给当前的值。123456789// a.jsmodule.exports = 0// b.jsexport const b = 0// main.jslet a = require(&apos;a.js&apos;)import b from &apos;b.js&apos;++a // 1++b // 报错，因为这个值是 read-only 的 写法：1234567891011121314151617// import 的方式较多import React from &apos;react&apos;import * as React from &apos;react&apos;import { default as React } from &apos;react&apos;import React, { Component } from &apos;react&apos;import { Component } from &apos;react&apos;import { PureComponent as PC } from &apos;react&apos;// exportexport default fsexport const fsexport * from &apos;fs&apos;export { readFile, writeFile }export function readFile// require 方式很少const fs = require(&apos;fs&apos;)module.exports = () =&gt; { console.info(&apos;A&apos;) }exports.fs = {} window.open 的使用 - by 丁香园 window.open 该方法接受三个参数： strUrl: url 地址。\b设置的值没有 http 时，打开的新窗口是当前 url 的相对地址。 strWindowName: 窗口名称，不是窗口标题，\b并不会显示。如果已存在同名的 strWindowName 的窗口，就不再打开新窗口，而是在那个窗口中加载。除非将它设置为 ‘_blank’. strWindowFeature: 窗口的属性，字符串形式，以逗号分隔。 window.open(&apos;http://www.google.com&apos;, &apos;newWindow&apos;, &apos;resizable,scrollbars&apos;) this 指向 window - by 丁香园123456789101112131415161718192021222324const obj = { name: &apos;james&apos;, show: function(name) { console.info(name) }}obj.show(this.name) // 空，因为当前的 this 指向 window// TODO 不知道这题的意义const result = (function (){ return &apos;1&apos;;}, function() { console.info(2) return 2;})()typeof result // &quot;number&quot; result 是 2document.body.addEventListener(&apos;click&apos;, function(e) { console.info(e.target, this) // this 指向 body, 绑定对象时指定了 this}, false)document.body.addEventListener(&apos;click&apos;, (e) =&gt; { console.info(e.target, this) // this 指向 window}, false) ReactcomponentWillMount TODO: 为什么不推荐该生命周期，以及为什么不推荐在这里使用 ajax. componentWillMount 内的报错会阻塞后续生命周期的执行，即 DOM 的挂载等等。 如果异步请求后续有涉及 DOM 的操作，可能会因为 DOM 还未生成而找不到 DOM 而报错。 存疑：v16+ 的版本里，在 fiber 的机制下，开启 async rendering, render 之前的生命周期函数可能会执行多次，导致发送多次 ajax。 服务端渲染 SSR，componentWillMount 也会触发？ CSSBFC 块级格式化上下文: 布局过程中生成的块级盒子区域。规定了内部块级元素的布局规则，默认情况下只有 body 一个 BFC 块级上下文. 规则： 盒子块会在垂直方向上放置。 相邻的盒子块在垂直方向上的 margin 会合并。 \b\b每个元素的 margin box 左边，与包含 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。（这部分不太理解）Demo BFC 区域不会与 float box 重叠。Demo BFC 是页面上隔离的独立的容器，容器内部的子元素不会受外部影响，也不会影响外部元素。 计算 BFC 的高度时，浮动元素也参与计算。 触发条件： 根元素或包含根元素的元素。 行内块元素：display 为 inline-block. 浮动元素：float 有值(不为 none). overflow 不为 visible 的块元素. 绝对定位元素：position 为 fixed 或 absolute. 弹性元素：display 为 flex 或 inline-flex 元素的直接子元素。 网格元素：display 为 grid 或 inline-grid 元素的直接子元素。 等等。 实际应用：很多 CSS 的布局方案都是通过创建 BFC 来解决的。 不使用 BFC 实现文字环绕效果。使用 BFC 实现排列效果。在线 Demo 例如解决 margin 合并的问题，方案就是创建两个 BFC。使元素处在不同的 BFC 中。在线 Demo 例如清除浮动，父元素添加了 overflow: hidden 属性后，生成了一个 BFC，而 BFC 的高度计算是包括浮动元素在内的，因此计算后的父元素高度包括了浮动元素，当前的原本脱离了文档流的浮动元素又被包括在父级 BFC 内。在线 Demo display: inline-block;float: left;position: absolute; 等等能创建 BFC 的方式都可以清除浮动，但还是要看具体的应用场景。 border-box 和 content-box 区别 box-sizing123456789101112131415161718.parent { box-sizing: border-box; width: 200px; height: 200px; margin: 20px; padding: 10px; border: 10px solid pink; background: red;}.child { width: 100%; height: 100%; background: yellow;}/* 说明各区域颜色及 child 宽高. *//* * border-box 是 width 包括 border, padding，但不包括 margin */ 用 css 实现子元素宽度为父元素宽度一半的正方形 - by 头条 在线 Demo 12345678910111213// 父元素大小未知，这里假定.parent { width: 720px; height: 420px; background: red;}// 使用 padding 将其撑开.son { width: 50%; padding-top: 25%; padding-bottom: 25%; background: lightgreen;} 行内元素 行内元素例如 &lt;span&gt; 是可以设置宽高的，但是设置无效，除非将 display 的值修改为 inline-block 或 block。 在线 demo 浏览器同源策略 浏览器的同源策略规定，协议相同，域名相同，端口相同(该条 IE 除外)。 影响： Cookie, LocalStorage, IndexDB 无法读取。 无法使用 AJAX. 无法获取 DOM. 但是有几个标签的请求是绕过同源策略的。 &lt;img src=&apos;&apos; /&gt; &lt;link href=&apos;&apos; /&gt; &lt;script src=&apos;&apos; /&gt; 跨域方案 JSONP CORS：比较常规的解决方案。 access-control-allow-origin 这个参数添加域名或设置为 *. 简单请求浏览器直接发送。 非简单请求，浏览器自动先发送预检请求 options, 然后再发送非简单请求。 window.postMessage：个人理解比较适用于 iframe 间的通信。 window.postMessage(message, targetOrigin, [transfer]) 接收三个参数。 message: 消息内容，会被自动序列化，无需手动序列化。 targetOrigin: 要发送的域名。 transfer: TODO 手动接收事件 window.addEventListener(&apos;message&apos;, receiveMessage, false) message: 包括 data, origin, source data: 传过来的数据对象。 origin: 发送方的源地址。 source: 发送方窗口的引用。 receiveMessage: 回调函数。 node 中间件代理 思路是 node 服务端获取到客户端请求，再从 node 服务器发出，请求后数据再返回给客户端。 这样从服务端发起请求，没有同源策略影响。 TODO: nginx 反向代理 类似 node 中间件代理，搭建一层服务器作为中转。 ssh 登录上服务器，修改 nginx 的配置文件。然后重启 nginx. nginx -s reload 在 nginx.conf 文件里修改12345678server { listen 80; server_name www.domain1.com; location / { proxy_pass www.domain2.com:8080; #反向代理 index index.html; }} TODO: websocket 前端安全 TODO：https://github.com/riotkkwok/blog/issues/8,https://zhuanlan.zhihu.com/p/31553667https://tech.meituan.com/fe_security.html XSS: CSRF 其他 在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。假设： A：每次只有一只老虎可以吃羊，而且一旦他吃了羊，他自己就变成羊。 B：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 问最后这只羊会不会被吃？- 头条的骚题。 从一只老虎开始分析，当一只老虎一只羊时，老虎必定吃羊。 当两只老虎时，老虎不敢吃羊，因为一旦吃了羊，变成了羊，就会被剩下的老虎吃了。 三只老虎时，头一只老虎可以吃了羊，然后问题回到两只老虎的状态，都不敢吃羊。 四只老虎时，老虎如果吃羊，就会回到三只老虎的状态，因此任一老虎都不会吃。 综上所述，老虎数量为奇数时，老虎会吃，为偶数时，不会吃。 单双向数据流的理解 TODO 单向数据流： 简单的理解，可认为水（数据）往低处流。高处是用户，低处是视图。用户的交互行为使得动作发生变更，派发后触发回调函数，进而引起视图的监听事件的调用，最终导致视图的更新。换句话说，视图的变更不会引起数据的变化，否则这就是双向数据绑定了。当然，目前谈论到的数据变化，是以 UI 控件为前提。 user interaction =&gt; dispatch(action) =&gt; callback =&gt; store(update) =&gt; change events =&gt; view(react component) 双向数据流：","link":"/2018/06/11/the-questions-in-interview-part2/"},{"title":"跳槽面试小结——那些在我下次面试前我想知道的事","text":"不久前，我做了一个较为艰难但对我以后的发展绝对有利的决定——从前公司离职。这是我呆的第一家互联网公司，也是我作为前端的第一份工作。一年多的工作经历并没有特别多的感慨，但我想记录下相关的事，来避免以后所走的弯路。 那些在我下次面试前我想知道的事不久前，我做了一个较为艰难但对我以后的发展绝对有利的决定——从前公司离职。这是我呆的第一家互联网公司，也是我作为前端的第一份工作。一年多的工作经历并没有特别多的感慨，但我想记录下相关的事，来避免以后所走的弯路。 有关离开和前公司的许多要好的同事一样，在这家公司开始“发力”，“改变”的时候，我有了一些关于离开的念头。 最初是和薪资有关。当无意中得知同行业其他人的薪资水平时，我确实吃了一惊。因为当你在一家公司，独自撑过曾经有四五个人维护过的项目超过个把月时，你应该得到一些报酬。但这种事，我天真以为应由公司方面主动，可我忍了很久也无动于衷，在自己提出后，最终得到了一定的涨幅。尽管过程较长，至少得到了较好的结局。 但如果仅仅因为薪资而离开，对一个刚开始工作的人而言这样的想法是幼稚的，所幸我最终没有那么做。我选择继续等待，等着接下来会发生什么。平淡的几月过去，然而接下来的事仍然无法打消一些不时间涌上来的念头。我想，很多人都会或多或少有过离开的念头，不论在哪家公司，只要年轻，就会有冲动，但即使年轻，也要学会衡量利弊，学会压下冲动。所以，我理清楚了一些事，当你离开时，你至少得注意几件事： 离开的决定是在理智的时候决定的，职场上，不要在任何冲动的情况下做决定。 如果决定离开，试着想想曾经来到这里的原因，再想想离开的原因。 列一张留下和离开相关利弊的表格，衡量各种利弊关系。 给自己一个沉淀期，等这段时间过去，再来看看接下来会发生什么，再做决定。 是否真的做好了下个地方的准备，去接受新的环境，建立新的人际关系。如果没有，除非现在的地方糟透了，否则一定要谨慎。 是的，针对第一条，是因为我自认在上一家公司，接受过许多不平等的、使人不愉快的事，那些事总会让我的脑海里浮现离开的场景。但最终我忍了下来，加上第四条的缘故，而且这样的选择是对的。在职场上，这其实是很简单的道理，只不过大部分人并没有幸运到会有个人来告诉你这些事。所以，自己把握吧。 我也在很多时候回顾了来这里的原因。来这里纯粹是机缘巧合，但从后来来看，在这里开始是个很好的选择，作为前端，我接触了很多新奇有趣的东西。虽然那只占据了这份工作的不多的部分，但我仍然为此心存感激。也一直感谢着招我入职的前辈。关于离开，除了那些会使我冲动和不愉悦的事外，我也试着去罗列那些相关的利弊，那会使我冷静下来。 我并不知道是否有关于沉淀期真正的名词说法，这是我自己随意取的。我只是在工作的初始阶段意识到，对于大多数人的第一份工作，他们应当有一个时间段，去熟悉这份工作，尤其这像我这样非科班出身的程序员，需要有一定时间去缓冲，去沉淀。不论在这时间段里发生什么，只要没有发生过分的事，就继续下去，这是一个信念，让你保持你的专注，吸收有关技术的知识，远离那些冲动和纷扰。当我回顾的时候，我发现我并没有非常坚定地执行这个信念，特别是在接近一年期满的时候，仍然会被其他事情所打扰，也许是因为年轻的缘故，但我最终坚持下来了。我庆幸这点。有的人把这个沉淀期定为一年，或者二年，或者更久。我把它定为一年。 一年期满后，当我再去看那些有关利弊的分析，已经是恍然大悟的状态——完全没有任何留下的理由——而我虽然没有做好充分的准备，但至少认可了自己。这使我最终选择离开。 跳槽对很多来说，骑驴找马是再正常不过的事。不过对我来说，很遗憾，我只能专注于一件事。我无法在一边工作的情况下，一边寻找机会，这直接导致了我的裸辞。 尽管很多朋友劝我不要选择裸辞，也不要选择年前离职，但我还是这么做了。从现在来看，也许是有遗憾，不过我不会因此而后悔或想选择再来一次。对我来说，裸辞并没有问题。问题是裸辞后应当有一段缓冲期，这缓冲期用来放松、出去走走，用来回顾总结。然而我几乎失去了这段时间，原因有部分也来自于离职的原因——没有年终奖导致了没有较多的积蓄，而平时也几乎月光。所以，这点没有办法。直到现在，我仍无法相信在一家公司超过一年的员工，会在一年结束时没有任何实际的奖励。现在我可以肯定地说，如果以后任一家公司发生相似的事，除非它的产品极具吸引力，或是平时月薪达到了超出同行业很多水准的高度，否则我会立即考虑离职这件事。 除了没有缓冲期外， 我觉得自己在离职时机上也没有问题。年底前一周，如果非要挑刺的话，希望再晚两周左右。因为从现在回顾去，确实接近过年时涌现了大批机会。不过在我离开的那时，机会已经足够多，错失的是自己没有把握住，而且那时候自己的心态，已经不适合继续——当毕业不久的你遇到相同的事，相信很多人会做比我更早离开的选择——我没法再当那更少数人了。 面试与准备如果要说这次跳槽，最大的败笔是什么，无疑是我的简历，我最初的简历十分糟糕——因为几乎没有准备——更别提精心准备。这使我在面试早期错过了很多好的机会，这点我最需要反思。一个重大原因似乎是没有对比，我几乎没有见过好的技术简历，所以不知道自己写的到底有多差。另一个原因，是我自己本身的优势，没有很好的在简历中体现。截止下笔时间，有无数好的机会就错过在了简历上。也许根本上还是自己的懒散导致，所以希望在下一次——最好至少在一年后——一定要准备好简历，这会让一切都开始地容易的多。 另一个不足的地方，在于基础知识的巩固。我在这一年里确实接触了很多，有各式各样的框架，还有各种打包工具。但最原始的html,css,js却忘了在面试前回顾。因为那些框架和工具，只能显示出你表面的功夫，底子里，面试问几个问题就一目了然，而许多我没能答上来的问题，却早就在自己的笔记里了。所以，前端最原始的那些基础知识，是在面试时最需要回顾的。 然后是面试时需要做的事——表现自己的自信和能力。自信体现在态度上，能力体现在技术上。有许多次，我并没有休息好就参加面试，加上自己心理素质相对不足，完全没有体现自己的优势，反而劣势被无限放大。在我面试的十五次左右里，最想去的那几家这点体现地很明显。最终导致了自己面试结束开始怀疑人生。有关这点，还有一些体会——非科班出身的人去面试，就好像背后插了把刀子。一旦面试官问起为什么选择前端，就好像拔出了那把刀子，再痛一次。另外，对那些出言不逊或者面试时令人不舒服的面试官，除非公司好的让人流口水，不然还是给否定答复或尽早放弃吧，我实在无法想象在面试短短几十分钟就令人不悦的人，以后还要以月以年来计算地继续相处。面试是交流和考察，不是欠你钱或者死了妈。 那些较好的机会，也可以试试。虽然也许自己还没到那薪资水平，但有些公司存在缺人的情况，这点大概是可遇不可求了，但也许面多了，也会有一定的直觉来判断。 总结这段不长的三周面试经历，一共十多次显得有些密集——最好仍是维持一两天一次，一周两三次这样的密度。现在看来，那些小公司的面试经历有些是不必要的，有些面试官做作的姿态反而令人不悦，费心费神。希望之后的面试，可以更专注的想去某个地方，提前订好目标。就现在来看，我想去的那些地方，大概是这样： mbp标配，双屏显示，最好带机械键盘，工程师座椅。 4-7前端的小团队，交流快捷迅速，喜欢追求，喜欢前端，有些geek，还有个各方面受认可的leader。 做较好的产品，那种你不会在需求讨论阶段就在心里wtf的产品。 较为规范的开发流程。代码规范是必须的。 定期的分享会，且在会上有更多新奇的东西，在code review时少些wtf. 对自己的能力认可的话，薪资按涨幅50%起加吧。 对了，我还做了一份自己看重公司的要点的表格，将拿到的offer和面试所知信息进行全部对比，优劣一目了然。它不会花你很多时间，但却会有很好的效果。 以后的机会对绝大多数人来说，漫长的职业生涯的跳槽经历都远不止一次。我也属于这其中一员，所以我希望在这里留下一些再次遇到相似情况时——最好不要再发生类似的事但万一发生的话——该注意的地方(顺序进行): 如果仍然习惯专注一件事，可以再选择裸辞。但有点要注意，部分城市转移户口需要连续交满一定时间的社保，裸辞的话，需要段时间寻找，很可能没办法延续，这个坑以后要记住。 时间接近年前，最好在年后。最差是11月底，12月初或月底(如果过年晚的话)。 有一些积蓄，去较远的地方走一趟——最好是国外。 回顾前端三驾马车，基础必须扎实。 非常认真的准备简历。 面试时自信，相信自己的能力(只要面试官不刻意刁难，这点我有时接近了)。 减少面试次数，先确定想去的地方，再去面试5-10家，最好五个以内。 好的机会，尽量去试试，不用在意招聘要求。 末尾写在2017年初，去下一个公司报到前一天晚。","link":"/2017/01/17/the-summary-of-interview/"},{"title":"初识 Three.js(上) —— 基础概念一览","text":"近期在项目中有规划 3D 组件的需求。在发现 echarts-gl 不能满足需求后，我在d3等一众第三方库中无所适从。最终我决定挑战一下 Three.js. 当然在一开始，我遇到了很多麻烦，所幸到了临近最后时，我解决了绝大多数的问题。我在未学习 webgl 的情况下直接使用 threejs, 其实并不是个较好的方案，却是能较快出结果的方案。这篇文章记录了我使用 Three.js 的痛苦和收获。 索引 [简单介绍](#Three.js 是什么) 基础概念 Scene(场景) Renderer(渲染器) Camera(相机) Geometry(几何模型) Material(材料) Light(光源) Animation(动画) Demo Three.js 是什么 我在初次见到 Three.js 的时候并不理解它是一种怎样的存在。只知道使用它可以做出各式各样炫酷，无所不能的 3D 效果。当时我的同事提醒了我，他说这是一个类似 jquery 的库，封装了 webgl 的各式各样的 api. 因此更加友好，也更加方便。它让你可以绕过 webgl 基础这部分，直接创建 3D 效果。但你仍然要知道，这是一个捷径，是临时的方式。如果要切实使用好 Three, 还是必须得学好 webgl. 即使里面所有的基础 api 可能不会在 Three 中体现出来，但 webgl 的实现思路，里面的知识点仍然是值得借鉴和学习的。 Three.js 基础概念 一定有人迫不及待地跃跃欲试了。但是且慢，在我尝试写代码之前，Three 的中文文档的寻找就耗去我不少时间。就目前而言，似乎还未找到官方的中文文档，教程之类的地方。只有部分翻译的文档。我最终只好硬着头皮阅读英文文档。所以若是理解有出入，请大胆指出。 Scene 就像 canvas.getContext(&apos;2d&apos;)获取上下文 一样，创建 3D 组件也需要一个上下文环境。 通常情况下，这个场景不需要做什么配置。 const scene = new THREE.scene() 源码 Renderer WebGLRenderer 渲染器使用 WebGL 来绘制场景。这个渲染器比 CanvasRenderer有着更好的性能。 const renderer = new THREE.WebGLRenderer() 使用 webgl 来渲染。 WebGLRenderer Camera Three 为我们提供了多个相机，包括正交相机，透视相机，还有立方体相机等等。 正交相机，则是类似一个长方体，我们透过这个长方体去看事物。此时，看到的事物是平面的，也就是没有立体感。和我们看 2d 的 canvas 类似。 const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000) 每个参数分别代表相机视锥体左面，右面，上面，下面，前面，后面。 透视相机，遵循近大远小的原则。和人肉眼所见相似。我们用以下方法来创建一个视角为 75°，占满屏幕大小，并且从离相机 1 个单位处开始渲染，到 500 的地方停止。 const camera = new THREE.PerpestiveCamera(75, window.innerHeight/window.innerWidth, 1, 500) 四个参数的含义分别为相机视锥体垂直视角，相机视锥体宽高比，相机视锥体近裁剪面，相机视锥体远裁剪面。 源码 Geometry 模型是构成物体的基本元素。它决定物体的形式。每个几何模型都基于基础类Geometry. 常见的几何模型有球模型(SphereGeometry)、盒子模型(BoxGeometry)、平面模型(PlaneGeometry)、环状模型(RingGeometry)、文本模型(TextGeometry)等等。 我们可以使用const sphereGeometry = new THREE.SphereGeometry(1, 1, 8) 来创建一个球体模型或使用const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)立方体模型。 Geometry Material 材料用来描述物体的外观和构成部分。用于决定一个物体以何种形式来渲染。例如球体的颜色，表面光滑度。 Material是材料的基础类。其他材料都基于此类。 常用的材料有基础网孔材料(MeshBasicMaterial)、兰伯特网孔材料(MeshLambertMaterial)、Phong网孔材料(MeshPhongMaterial)等等。 使用const sphereMaterial = new THREE.MeshBasicMaterial({color: &apos;0x000000&apos;}) 来渲染黑色的表面。 当形状和材料两项都创建好的时候，就可以来创建一个完整的物体。 const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial) 源码 Light 光源通过光照的强度和范围去影响场景中的部分对象，主要是对不同材质的对象产生影响。 Light是光源的基础类。其他光源都基于此类。 常见的光源有环境光源(AmbientLight)、平行光源(DirectionLight)、点光源(PointLight)等。 环境光源对所有对象产生影响。 平行光仅对MeshLambertMaterial和MeshPhongMaterial材质的对象产生影响。 点光源同上，仅对MeshLambertMaterial和MeshPhongMaterial两种材质产生影响。 以点光源为例，我们创建一个简单的点光源。 123let light = new THREE.PointLight(0xffffff, 1, 100) // 光照颜色，光照强度，光照范围light.position.set(50, 50, 50)scene.add(light) 源码 Animation 最后，让这一切动起来，需要动画来运行。 12345function animation() { window.requestAnimationFrame(animation) renderer.render(scene, camera) // do something} Demo 在了解所有基本的要素之后，让我们来实现一个简单的动画吧——一个旋转的立方体。 12345678910111213141516171819202122232425262728293031import * as THREE from &apos;three.js&apos;const body = document.bodyconst scene = new THREE.Scene()// 新建渲染器并设置大小const renderer = new THREE.WebGLRenderer()renderer.setSize(window.innerWidth, window.innerHeight)body.appendChild(renderer.domElement)// 设置相机和位置，并将视线转向场景中央const camera = new THREE.PerspectiveCamera(75, window.innerHeight / window.innerWidth, 1, 1000)camera.position.set(0, 0, 10)camera.lookAt(scene.position)// 新建一个立方体const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x123abc })const cube = new THREE.Mesh(cubeGeometry, cubeMaterial)scene.add(cube)// 旋转立方体function animation() { window.requestAnimationFrame(animation) renderer.render(scene, camera) cube.rotation.z += 0.01 cube.rotation.y += 0.01}animation() 中文文档","link":"/2017/11/23/the-usage-of-threejs/"},{"title":"ES6改写cookies.js及分析","text":"cookies.js是前阵子在github上很火的一个超轻量级的库，发布当天就获得了2k+的star数。最初只有80行，到现在也不过一百多行。而里面的写法很值得借鉴学习，在这里我尝试用ES6改写，边改边学习。目前还留下了小部分不理解的地方，这些坑留待之后理解了再回来填。 ES6改写cookies.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/** * [cookies cookies.js] * @param {Object} data [description] * @param {Object} opt [description] * @return {Object} [description] */// 用ES6改写cookies// cookies 不会变化,所以用const定义const cookies = function(data, opt) { /** * [defaults 源码中的合并对象属性函数 这里采用ES6的Object.assign替代,是否会引起错误？] * @param {Object} obj [原始对象，如果没有则默认新建一个] * @param {Object} defs [用来合并的对象] * @return {Object} [description] */ // function defaults(obj={}, defs) { // for (let key in defs) { // if (obj[key] === void 0) { // obj[key] = defs[key]; // } // } // return obj; // } // 初始化 // defaults(cookies, { Object.assign(cookies, { expires: 365 * 24 * 3600, // 设置默认的过期时间，一年 path: &apos;/&apos;, // 路径 secure: window.location.protocol === &apos;https:&apos;, // Advanced Options 不推荐更改的一些默认选项 nulltoremove: true, // 设置cookie的值为null时即移除它, autojson: true, // encode or decode 转码成json autoencode: true, // 安全编译 encode: (str) =&gt; { return encodeURIComponent(str); }, decode: (str) =&gt; { return decodeURIComponent(str); }, error: (error, data, opt) =&gt; { throw new Error(error); }, fallback: false // 如果cookies失效时启用的回调 // 更改时需要在全局环境下 // cookies.nulltoremove = true; // cookies.autojson = true; // cookies.autoencode = true; // cookies.encode = (str) =&gt; { // return encodeURIComponent(str); // }; // cookies.decode = (str) =&gt; { // return decodeURIComponent(str); // }; // cookies.error = (error, data, opt) =&gt;{ // throw new Error(error); // }; // cookies.fallback = false; }); // 将 cookies 复制到 opt 上, 用于后面的保存 // opt = defaults(opt, cookies); opt = Object.assign(opt, cookies); /** * [expires 将时间格式转化为UTC格式] * @param {Date || Number} time [可能是以秒为单位的时间，或是Date对象] * @return {Date} [description] */ function expires(time) { let expires = time; // 假如传入的时间不是Date对象 if (!(expires instanceof Date)) { expires = new Date(); expires.setTime(expires.getTime() + (time * 1000)); } return expires.toUTCString(); } // 查询cookie,注意这里采用了链式写法,函数式编程风格 if (typeof data === &apos;string&apos;) { // 依据分号间隔将字符串cookie转成数组 let value = document.cookie.split(/;\\s*/) // 如果autoencode为true,则将数组中的每个cookie通过decode进行处理 .map(opt.autoencode ? opt.decode : (d) =&gt; {return d}) // 数组的map方法返回的是数组，所以可以进行链式调用 .map((part) =&gt; { // 再将每个cookie 分割成 [key, value] 的结构,得到一个二维数组 return part.split(&apos;=&apos;); }) .reduce((parts, part) =&gt; { // 将数组中的 [[key1, value1], [key2, value2]] // 转化为 {key1: value1, key2: value2}的格式 // parts[part[0]] = part[1]; // 作者后来改为下面 parts[part[0]] = part.splice(1).join(&apos;=&apos;); return parts; }, {})[data]; // 获取指定的cookie值，将该值赋给value // 是否支持转化成json的object if (!opt.autojson) { return value; }; let real; // json格式化 try { real = JSON.parse(value); } catch (e) { real = value; } // 假如当前值是undefined,切存在回调函数，则返回调用毁掉函数后的返回值 if (((typeof real) === &apos;undefined&apos;) &amp;&amp; opt.fallback) { real = opt.fallback(data, opt); } return real; } // 新增cookie for (let key in data) { let val = data[key]; // expired 涉及两个判断 // 一个data[key]的值是否为undefined // 第二个是 nulltoremove的值为true, 且设置的值为null // 当满足这二者之一的条件时，expired 的值为true // 这个写法简洁明了 let expired = typeof val === &apos;undefined&apos; || (opt.nulltoremove &amp;&amp; val === null); let str = opt.autojson ? JSON.stringify(val) : val; let encoded = opt.autoencode ? opt.autoencode(str) : str; // TODO: 这里为什么不放在encoded判断之前 if (expired) { encoded = &apos;&apos;}; // 这段略复杂、、保存各种数据，以分号相隔 // 如果存在则保存，不存在则以空字符串标识 // TODO: 如果过期的话默认值为-10000？ let res = `${opt.encode(key)}=${encoded} (${opt.expires} ? (;expires=${expires(expired ? (-10000) : opt.expires)}) : &apos;&apos;) ;path=${opt.path} (${opt.domain} ? (;domain=${opt.domain}) : &apos;&apos; (${opt.secure} ? ;secure : &apos;&apos;)`; // 如果opt中有测试方法 if (opt.test) { opt.test(res); } // 保存cookie document.cookie = res; // TODO: 待理解。获取属性值，对其编码，并获取? let read = (cookies(opt.encode(key))) || &apos;&apos;; // TODO: 待理解。当当前值存在，且未过期，且过期时间大于0，且 ? if (val &amp;&amp; !expired &amp;&amp; opt.expires &gt; 0 &amp;&amp; (JSON.stringify(read) !== JSON.stringify(val))) { // 查看浏览器是否开启了cookies,布尔值 if (navigator.cookieEnabled) { // 如果存在回调函数 if (opt.fallback) { opt.fallback(data, opt); } else { opt.error(`Cookie too large at ${val.length} characters`); } } else { opt.error(`Cookies not enabled`); } } } // 这个cookies // cookies({ token : 14})({ token: &apos;14&apos; }) // const token = cookies({ token: &apos;14&apos; })(&apos;token&apos;) // token === &apos;14&apos; return cookies;}// TODO: 需更熟悉// 如果在webpack中配置output的libraryTarget设置为umd,就会在打包时自动添加这段// 然后就可以通过多个方式引入(AMD, commonjs, global)// [具体配置](https://webpack.github.io/docs/configuration.html#output-librarytarget)// 或者可以直接加载模块末尾(webpackUniversalModuleDefinition(root) =&gt; { // CMD写法: common.js 的 module.exports 暴露 if (typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) { module.exports = cookies; } else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) { // AMD规范的define写法 define(&apos;cookies&apos;, [] , cookies); } else if (typeof exports === &apos;object&apos;) { // ES6写法 export出cookies exports[&apos;cookies&apos;] = cookies; } else { // 全局配置 this[&apos;cookies&apos;](global.cookies) root[&apos;cookies&apos;] = cookies; }})(this); 参考: 1. [源码分析之：cookies.js](https://gold.xitu.io/entry/57dfa28c0e3dd90069771c2c) 2. [cookies.js](https://github.com/franciscop/cookies.js)","link":"/2016/12/19/transform-cookies-into-es6/"},{"title":"「翻译」16 个理由说明为啥 Jira 工作流这么难用","text":"呕心沥血翻译的国外小哥吐槽 jira。他从用户交互来体会，了解 jira 的同时理解为什么它这样难用。(提示：部分图片需要科学上网才能显示)原文链接 以下是正文： 多年来，我一直是多个网页应用的开发者和使用者，同时参与了很多软件服务。 很多时候我使用像 Asana 或者 Trello 这样的工具来管理项目任务。 我最近被要求使用 Jira。我加入了一个组织的新项目组。他们用了很久的 Jira 了。 我去，这次使用经历真是变成了冒险。 和 Jira 闲逛第一周的时候，我感觉像是回到了 90 年代。每件事情开展的都如此之慢。这里面的 UI 是如此臃肿。这玩意问了我无数次毫无意义的“你确定吗”来确认。我感觉像是回到了 windows 95 的时代。（而且 windows 还比它更好） 第二周我经常问：“伙伴们，我们可以切换到 Asana 吗” 我和我的同事甚至接近创建了一个自由度很高的 Asana 面板，用它来创建任务，而不是 Jira.不幸的是，完全切换是不可能的。我们不得不用这个团队已经坚持了很久都在用的工具。 第三周和接下来的几个月，我意识到我别无选择。我不得不习惯它。像句老话说的，假如你不能改变它，那就适应它。那就意味着要习惯它来推动任何事，尤其是高效的项目管理和敏捷开发。 Jira 唯一鼓舞你的是花尽可能少的时间来使用它。我的很多同事仍然习惯在笔记本上来记录待办清单。他们觉得 Jira 太低效了，又花时间。奇怪的是，当我和其他人使用 Asana 和 Trello 时, 没人会用笔记本记录。他们觉得在应用里记录就足够直观了。 有人会说，你根本就不会用 Jira. Jira 已经做了很多重要的升级了。我说少废话，我已经用了九个月了，我还是觉得它和我刚开始用它时一样难用。在这个时间里，Asana 和 ClickUp 已经可能更新了十个新特性了。 我很惊讶于这么流行又这么重要的项目组织工具，竟然这么糟糕。 Jira 应该是一个让你更简单的管理项目的网页应用。目前为止，它显然很失败。 我的有些朋友对我解释 jira 这么难用的反应是这样的：我理解你，它是可以再好用一点，但是其他工具的集成度和反馈都没有 jira 好。 这算个什么回答？ Asana 缺少反馈功能，那又怎样？你有没有考虑过 Jira 给项目带来的缺点？以现在的用户体验来说，它带来的是更糟的。让其他工具有这些功能而不牺牲可用性，只是时间问题。反而让你的组织使用 JIra 对项目和与你一起工作的人来说是种巨大缺陷。 我来给你一些例子来验证我的观点。 Jira 交互为了这篇文字，我注册了一个新的试用免费帐号，包括 Jira 和文档包。这样的用户场景，让我们想象我刚刚创建了一个新公司，然后我创建了一个新项目，它会作为项目管理中心，当作是接下来项目的首页。 在创建项目之后，我觉得创建我的第一个任务，在这里叫做 issue. 1. 为啥会有 Issue Type 这玩意？在 jira 里第一件你学到的事情，就是问题不只是问题。新的问题默认可以是故事，任务，缺陷，需求。或者是子任务，但是待会再说这个。 为什么会有这些分类存在？它们之间的区别在定义（“它们的用途不同”）和实践（“故事的工作流与Bug的工作流”不同）中都有解释。 简要来说它们是同一回事，都是待办事项。 就这样，每次你创建一个问题，你需要去想它属于哪一类。是史诗？故事？还是任务？或者全都是？就像，我应该新建初次发布史诗，接着创建 Bootstrap 项目的故事，然后在它里面创建新建代码仓库的任务？ 嗯…我就先建一个创建首页任务暂时，待会再写其他任务。 2. 怎样创建新问题？在新建第一个问题之后，我马上就想新建另一个。可是，因为我已经有了一个问题，新建问题的占位符消失了。于是我开始找一个新建的按钮。 在哪呢？ 我点了这个更多按钮，只看到了这些。 然后我点击添加项目在左侧的边栏，只看到这些： 噢，在这里！在远远的左侧，蓝色边栏里，这个一点也不属于我当前项目视图里的地方。真是 UI 设计师们有趣的决定。 3. 任务可以创建子任务，但是任务不能是另一个任务的子任务。我用 Jira 9 个月了，但是当我看到子标题的时候还是会忍不住笑。Jira 的问题可以是一个任务或者任务子任务。但是，已存在的任务不能是任务的子任务。你需要转化已存在的任务为子任务才能够如此操作。 我的场景：我已经创建了第二个任务，叫做 “Prepare Graphic Design” ，然后我想让他变成另一个 “Create landing page” 任务的子任务。 于是我进入 “Create landing page” 然后尝试添加子任务。 不幸的是，在输入完另一个项目的名字，它创建了一个新的子任务： 这不是我想要的，还是移除吧。可是我在这子任务列表里的子任务元素旁边找不到任何移除按钮。为什么，我至今不知道。于是我点击子任务界面，看看也许这里有移除按钮。 我一定是眼瞎了。没有任何删除按钮，即使在点击主页的更多按钮之后。可能还有别的更多按钮？ 还是没有。可能到父页面视图里，点击在子任务旁边的更多按钮，我就可以删除子任务了？ 还没有！我期待着这里会有选择删除的选项，但这里唯一可能接近的就是批量操作按钮。于是我点了它。 然后页面重定向到了另一个完全不同的叫批量操作的页面。跳转花了 6 秒钟。可我只是想要删除我刚刚创建的子任务啊！此时我只希望它能记住我的最后视图，当我完成当前页面的操作的时候。 有点奇怪，我是这个项目里唯一一个人，我创建了问题和项目，但我不能删除他们？为什么？我开始搜索。 好吧，这是个特性，不是 bug. 行，我知道了，这可能是保护性措施，防止用户删除任何问题。即使是几秒钟前创建的用户也不行？！ 得了吧。这是像 Atlassian这样的大公司能想到的最好的办法吗？ 为什么他们从没想过放一个归档按钮？几乎每一个网页集成工具现在都有方式来归档文件，图片和文字。这和删除差不多，但有个撤销功能。 不管怎样，我不会改变权限，我没时间做那个。有没有可能我让这个子任务跳过或这别的什么？ 没可能。我只能移开它。我把它重命名成归档的作为临时解决方案。 4. 让一个任务变成另一个任务的子任务不管怎样，让我们回到 “Create landing page” 这个问题。我想让一个任务变成它的子任务。 我注意到界面上有个按钮可以让我连接问题。看来起不错，我想，可是它好像不是任务-子任务的连接。 为什么任务都可以互相连接，那子任务还有什么存在的必要呢？ 子任务通常都会阻塞父任务，不是吗？ 既然不能让已存在的任务和别的任务形成任务和子任务的关系，或许我可以把任务转化成子任务？查查看。 好吧，但是转化子任务的地方在哪里？是我在哪里错过了吗？ 在点击更多按钮之后，我发现了转化为子任务的连接。点击它之后，页面加载了大概 5-10 秒，下面的页面出现了。 选择问题之后点击下一步，它让我接着进入下一步。 在点击下一个毫无意义的下一步之后，继续往前 在最后一次点击完成时，又来了一次 8 秒的页面跳转等待，我终于把一个任务转化为子任务。 不过，你注意到顶部的提示了吗？ 它说我现在在一个新的问题视图。一般这是个页面来通知用户新特性的。但我是个新用户，我不知道哪些功能是新的哪些是旧的。 而且，你发现了吗，它没有关闭按钮？！点击所有的连接加上刷新页面都不能隐藏它，我很确认。让我们往前看把，这个恼人的提示可能待会会消失。实际上并没有，我看了它九个月了。 5. 拆分任务成独立的发布在意识到转化已存在的任务成子任务是这么复杂后，我就直接从任务视图里创建子任务。我还创建了一些其他任务，就像 “寻求反馈”，“搜索优化”，那应该在网站初次发布后做好。 现在，我想以某种方式组织一些其他问题到功能性发布或者别的，这样它们不会在我初次发布的时候影响到我。 我在看板里看到一个发布按钮，它让我来创建发布。 我觉得创建两个新的发布，1.0 和 2.0. 不幸的是，在创建第一个发布之后，我不能再创建第二个了。 在反馈之前，我注意到这里有个发布按钮连接在边栏。我点了它，却只看到一个 Jira 欢迎页面，就像这样 这让我提出了三个问题 不能找到版本 —— 什么？什么版本？我甚至还没开始找特定版本。 发布和版本是同一回事吗？那为什么你们不坚持用同一个命名？ 我已经创建的版本/发布在哪里？ 在更新筛选的未发布到已发布条件后，我明白了发布已经存在了，它被标记为已发布。可我刚刚设置了它的发布日期在未来。搞什么？ 无语，为了改正我更新了它的状态。在那之后，在同一个视图内，我创建一个新版本 2.0. 现在我的计划发布创建了，我决定回到看板然后分配已存在的问题到相应的发布里。 （为啥每次我都要猜着去用呢？） 当来到问题视图的时候，第四次尝试分配了它们到一个特定版本之后，我感觉这是个乏味的任务。我想让它自动化一点。我可以选中多个然后一次性批量编辑吗？ 我回到看板，因为我想看到有个什么批量操作的动作会在这里。不出意外的，它没出现。 它会在哪呢？我们搜索一下。（再次） 我咋搜索呢？ 我以为看板已经是个搜索视图了，它里面有搜索筛选条件。 我点了边栏上的搜索按钮。 打开了这玩意 我点了问题的更多搜索。在十秒的网页加载之后， 臘 ‍为啥你们要把不显示任何问题的视图作为默认视图呢？ 要改变当前状况，我只能点击所有问题。终于显示出来些东西了 但是批量操作按钮在哪儿？或许在这个筛选旁边的更多按钮里？ 并没有。或许它们在我点击搜索输入框旁边的“更多”按钮之后会出现 也没有，它只是改变了输入框的样子。可能在顶部右边角落的另一个更多按钮里？ 是的。在这里。但。。我不想改变所有的 16 个问题，我只想改变其中的一部分。怎么搞？ 我改变了搜索条件来减少问题数，现在页面只显示几个主要的问题，我来批量操作它们。 幸运的是，在页面加载了 5 秒之后，jira 列出了所有问题，但这次，它有了选择框，我可以选择哪些是我想编辑的。（就不能在之前的视图里加上这操作吗？） 对了，如果你想在选择问题之前预览，你猜怎么着，不行。如果你直接点问题，页面会离开视图，直接跳转。如果看板视图可以在对话框里预览问题，为啥不搞一个呢？ 在选了三个问题，点了四次下一步按钮之后（每一步都有页面跳转），我最终看到了这个页面 6. 只能浏览特定版本的问题在拆分我的发布到两个独立的发布之后，我现在终于可以专注于 1.0 版本的问题。至少那是我希望的。我回到了看板视图。 在我脑海里的第一个问题，我怎样才能过滤只显示 1.0 版的问题呢？ 寻找筛选按钮…… 如果我点了右上角的发布按钮，只会显示一个下拉框，让我添加或者移除问题到一个已存在的版本。(对了，从视图上来说很难说明它确切是什么。你不得不自己创建一个发布，观察它来学会使用它，或者从文档里学习。这个对话框并不是很清楚的说明它的作用。) 如果我点了右上角的三个点的更多按钮，我也不会看见任何筛选操作。替代的，我注意到两个链接叫做“面板设置”，“创建面板”，它们可能会帮助我。 面板设置，那是什么？我们试试看。 这看起来就是我需要的。可能看板就是设计成只显示看板问题，如果你要筛选，必须先编辑面板或者创建一个新的？（在问题视图想过滤问题的时候，不得不想到这些复杂的想法。） 但是那真的很奇怪。有多少应用是要新建视图仅仅是为了筛选它？（假如你想要过滤邮件，你会要新建一个邮件面板吗？不用的。） 不过，我还是从 1.0 版本创建了一个新面板。在创建之后，Jira 用下面这个对话框欢迎我 假如我想在 sprint 里但又想使用一个看板视图会怎样？它们会互相排斥吗？经过深思熟虑，我决定通常更喜欢在 Sprint 和截止日期方面保持灵活性。我选择看板。 我的第一想法是，想要一个已存在的筛选条件的看板，因为我要看一个带过滤条件的问题的搜索结果。可是，什么是已保存的筛选条件。对一个简单筛选来说听起来有点复杂。于是我选择了从已存在的项目导入（因为我确实想为现有项目创建面板）。 擦，我又创建了一个和先前一模一样的面板。 他们没有想到我要显示现有项目中的问题并同时过滤它们。 （这是谁的错？我还是Jira UI设计师？） 让我们回到面板设置。可能我可以自己创建搜索条件给这个已创建的面板。 不确定我是否都理解这些，但或许这就是过滤查询？我们来编辑它。 我被重定向到熟悉的高级搜索视图。 我已经熟悉过滤条件，因此很快设法添加了“修复版本”过滤条件。 在这之后，过滤条件旁边有一个保存按钮。我点了，神奇的是，Jira 重定向到我刚刚编辑的项目页面。噢，等一下，不是的。 它实际上只是显示了一条即时消息，说过滤条件保存好了。它是否已经保存成面板的过滤器了呢？樂 回到我刚刚的位置然后确认我刚刚的操作是否真的生效了，我不得不做以下： 点击左侧蓝色边栏的回到主页按钮， 点击项目（又一次的页面跳转） 点击 “Indri Landing” 看板名。 在又一次的页面刷新后，我终于到了我想看到的页面——在特定版本里的已过滤的看板页面。我为我能做到而感到自豪。  7. 在过滤好的面板里创建问题我现在有一个专注在 1.0 发布的面板，让我们开始工作把 —— 移动一些子任务到处理中，然后开始处理它们。 但是…我的子任务呢？ 在一个全局项目视图中我看到了任务和它们的子任务，但是现在我只看到主任务。 看起来这个新创建的面板和之前创建的默认面板设置是不一样的。 在面板设置里找外加谷歌五分钟后，看起来这是不可能的了。jira，你真牛，你毁了我刚刚完成的面板。 在又谷歌了五分钟后。我知道了。这大概是即使我移动了任务到一个特定发布里，但是它们的子任务，没有随之移动，现在是不属于任何发布里，所以它们不显示了。 所以我不只要移动任务，还要移动它们的子任务到 1.0 发布版本。（很遗憾，Jira 没有建议我在该操作中也更改任务的子任务。）让我们这样做吧： 到高级搜索页面 -&gt; 找到子任务 -&gt; 批量操作 -&gt; 编辑所有问题 -&gt; 分配到 1.0 版本 -&gt; 是的我确认 -&gt; 等待操作… -&gt; … -&gt; 是的我知道 -&gt; 回到项目 -&gt; 回到 sprint -&gt; 回到面板 我终于看到子任务了！ (They should pay me for doing this Jira work.) 8. 在过滤好的面板里创建任务在使用1.0版开发板时，我意识到我需要为发布1.0版做更多的事情。因此，我决定创建一个任务： 创建问题的结果是“问题当前不可见”警告。为什么？！嗯。也许有一个“修复版本”字段尚未填写（即使我在版本视图中），这就是为什么它没有出现的原因？ 回到高级搜索视图，找到问题，是的，它确实没有修复版本。（即使我实在一个修复版本的面板里创建它的。） Jira 为什么不允许你专门为当前面板创建问题，以及为什么无论你当前的问题视图显示了什么，它都会迫使你始终预填所有字段？别问我。 简要说明其他问题我们可以继续下去，但是这篇文章已经花了太长时间。我将给您提供一些糟糕交互的最新示例，但这一次是简短的形式。这些例子将来自我的日常工作。 9. 创建问题很耗时在我们的组织中，有多个项目和团队在一个Jira工作区上进行协作。因此，无论何时创建问题，我们都有义务填写： 修复版本（计划在哪个版本修复） 组件 (团队将会修复) 史诗 (新功能) 不幸的是，Jira 并不会帮助我们输入这些字段： 它从不会记住最后的值，也不会让我定义默认值，也不会让我定义一个模板或者别的什么。（那样的话我只要点一下就可以创建任务了） 有些需要我创建的字段，却藏在离新建问题对话框很远的地方。即使我可以隐藏它们，但不能改变它们出现的顺序。 结果就是： Jira 应该是所有项目任务的中心，但事实上常常不是。新建一个任务至少需要一分钟。因为我需要集中注意来填写那么多重要字段，每一次它都要求我 切换上下文。 很多时候，我们最终完全避免使用Jira，只是为了“节省我们的时间”，从而导致任务和知识由于无休止的Slack聊天而不是项目管理中心而白白浪费了。 问题常常白白浪费掉。如果有人忘记填写这些字段中的至少一个，则很有可能我们面板的过滤器查询无法搜到问题，而且没人会发现。 大家都抗拒着用替代 的 Jira 客户端 , 可能因为这原生的实在是太糟了。就比如我, 我正在用 CLI 客户端 来创建和浏览 Jira 问题. 我不得不花费很多小时来对它自定义，这样它就可以满足我的所有需求。幸运的是，现在创建任务只需单击两次 ENTER 并输入问题标题即可，就像从一开始就应该这样做一样。 （这个工具太可怕了，以至于我不得不求助于配置 CLI 客户端。你信吗？例如，你会使用 CLI 在 Slack 上聊天吗？当然不是。对于Jira来说，这听起来很合理。） 10. 分为新和旧视图从“旧问题”视图可以访问的某些功能，却在“新问题”视图不能访问，反之亦然。他们发布了一个“新问题视图”，该视图缺乏旧视图中的重要功能。同时，它引入了新功能，仍然使用旧视图的客户又无法使用这些新功能。 比如: 你可以在新视图里浏览工作日志，但不能在旧视图里这样做。 你不能在旧视图里编辑问题的预估时间，但是在新视图里可以这么做。 结论: 我经常要在新旧视图中切换。（当然，这事情做起来不简单）加入你想要切换，你必须到你的账户设置里，并且重载你所有打开的问题视图。 11. 移动视图到另一个状态是非常麻烦的当我切换问题的状态，比如从处理中到已解决，常常我还有义务要填写一些额外的字段，就像解决类型。这里有很多不同的值，比如结束，阻塞，跳过。你知道我们怎么点吗？在 99% 的情况下，只是“结束”。它被设置成了默认值吗？当然没有。它总是要你去点一下那额外的。（鼠标点击，因为键盘导航通常不起作用） 12. 不同的视图说明同一件事，总是不同的看这里 老实讲，每次我打开 Jira 的视图，我真不知道它会展示出什么样子。 13. 邮件通知骚扰Jira 会在任何问题的状态变更的时候都用邮件通知你。这很好。可是，在做诸如 jira 这样的仪表盘应用时，你会注意到 “某个东西更新” 的邮件会更新的非常频繁，数量众多，以至于邮件会非常大。于是你做了一个简单的处理，批量发送通知。（不要打扰我，五分钟左右，然后再一次性把所有变更在同一邮件里给我） Atlassian 大概根本没想到过这一点。 (或者它们的系统太臃肿所以没办法去做这样的改变。) 因此, 你还是会收到上百封邮件通知。 (除非你完全关掉。但同时，这可能会让你的同事恼怒，因为你没有对他们做出的更新作出相应的回应。) 更糟的是，如果你用了 jira 的集成服务，很可能会导致 jira 发送更多的邮件。例如，我们用 Aha! 集成服务 . 只要我创建了 jira 问题, Aha! 就会链接它到 Aha 的某项!.，然后就导致额外的邮件：“Aha! 集成服务改变了问题 XXX. 字段改变: Aha 集成链接到 YYYY.” 谢谢, 很高兴知道这些… 14. 无形的应用通知有些人可能会更加烦恼于应用通知而不是邮件。 可是，有人想出了个点子，把通知藏在屏幕左下角。真谢谢你了，我一直都不知道直到有人告诉我，还是在我使用 jira 三个月后。 即使在那之后，我也很少观察到“你有新通知”的消息点。消息通知在屏幕的这么个位置，我不得不提醒自己通知在这里，让自己记住这个位置。（难道不应该是相反的吗——通知应该时刻提醒我？） 15. 性能!!! Jira 最 痛苦 就是它的性能. 几乎每一次点击都会带来长大十秒的页面刷新跳转。意味着，假如你要快速浏览一个问题列表，阅读其中的四个，然后编辑，你大概要等待页面加载 7 次。简单的操作就像“我的问题然后开始工作”通常要花费 1 到 2 分钟，然后让你完全失去对当前工作的专注。 16. 工作流也垃圾它自己标榜自己是 “团队工作流软件” TL;DR: 这是一个嵌套的文档目录，可以在线阅读和编辑。 但是，你知道可以在Google文档，Microsoft Word Online，Dropbox Paper，Hackpad中做什么，但是在Confluence中不能做什么？同时阅读和编辑！ 如果你想要编辑，你必须要到一个独立的编辑页面。（再一次需要页面加载）然后等待 15 秒左右让它加载完毕。 从理论上讲，有可能同时在几个人中进行文档协作。但是实际上，在编辑过程中所做的任何更改都不会在“阅读模式”下显示，除非您真正单击“保存”。而且，当您这样做时，我敢打赌，首先你会看到一个巨大且令人困惑的警报“你确定要发布XXX所做的更改吗？”。这是因为，如果有人在你之前进行了某些更改，但尚未发布，则在发布自己的更改时也必须提交它们。 （即使有人只是意外更改了空白，也会显示该通知。） 我去! 我只想更新我自己的变更。抱歉了老兄，在工作流中你不能这么做。 你知道在一个公司里保持一个优良的文档文化 最大的问题是什么吗？让大家懒于创建和更新文档，使得最终丢失文档或文档太老。 对人抱怨很容易，它也很少有生产力。使人们更有生产力的是用工具把工作做的更好。一个好的文档工具应当使得阅读和编辑都尽可能的简单无缝。 工作流在这点上很失败。 小结我可以接着一直一直谈论 UI，但觉得我们应该已经够了。 你知道现在还有些工作专门聘请 “jira 管理员” 的岗位吗？在用了这么久之后，我不感到意外了。这个工具需要仅负责处理该工具的人员，因此其他人可以至少完成其假定的实际工作的一部分，而不必与 Jira 混在一起。 为啥 jira 这么糟糕，却还这么流行？ 为什么像 Atlassian 这么一个注重软件的公司会这么忽视它们的核心产品？他们以这种方式冒险。如果 Jira 无法使用并且阻止人们做它应该做的主要事情（管理项目），那么竞争对手（例如 Asana，ClickUp 或其他东西）将利用它，构建一个不那么糟糕的工具，这只是一个时间问题来接管他们的顾客。 这就是为什么我写了这篇文章。 告诫你远离 Jira 如果你可以的话。 告诫 Atlassian: 烦请你修好你的产品。— 对了，你在找帮你找到并修复问题的网页应用的交互设计吗？?  看我的 主页 and 发消息给我. 乐于帮助。","link":"/2019/10/25/translate-jira-suck-article/"},{"title":"理解JavaScript中的类","text":"整理了部分类的知识点。类的定义，如何实现一个类，类有哪些特点，等等。基于ES3, ES5. 理解JavaScript中的类 类的作用：让每个对象都共享某些属性。 类的实现：基于JavaScript的原型继承机制。 类的特性：动态可继承(编程哲学——鸭式辩型)。 类的核心：原型对象。所有类的实例都会从同一个原型对象中继承。属性 类的定义：通常使用构造函数: 调用构造函数会自动创建一个新对象，构造函数只需初始化这个新对象的状态，而新对象的原型正是构造函数的prototype 意味着同一个构造函数创建的所有对象都继承自一个相同的对象,因此他们都是同一个类的成员 构造函数可看做是类的’外在表现’ 为方便标识，字符串相关部分使用了ES6的模板字符串。 编程约定：构造函数(类名)首字母大写:构造函数就是用来构造新对象的，必须通过关键字new调用，开发者可以通过命名约定来判断是否是构造函数。 12345678910111213141516/** * [Girl 定义一个拥有几个属性的妹子类] * @param {[String]} pretty [可爱属性，以字符串标识] * @param {[Number]} sexualLow [性感属性，以数字标识] * @param {[Number]} sexualHigh [性感属性，以数字标识] */function Girl(pretty, sexualLow, sexualHigh) { // 类型检查 if (isNaN(sexualHigh) || isNaN(sexualLow)) { throw new TypeError(); } this.pretty = pretty; this.sexualLow = sexualLow; this.sexualHigh = sexualHigh;} 在原型对象上定义类方法。 该prototype是每个JavaScript函数都自动拥有的,它本身的值就是一个对象，这个对象包含一个唯一一个不可枚举的属性constructor。 constructor的值是一个函数对象。 12345678910111213141516171819202122232425262728293031/** * [foreach 传入方法处理每个属性] * @param {[type]} f [description] * @return {[type]} [description] */Girl.prototype.foreach = function(f) { f.call(this, this.pretty, this.sexualLow, this.sexualHigh);};/** * [include 是否在Girl的性感区间内(判断妹子是否性感)] * @param {[type]} sexual [description] * @return {[type]} [description] */Girl.prototype.include = function(sexual) { return sexual &gt; this.sexualLow &amp;&amp; sexual &lt; this.sexualHigh;}/** * [toString 查看这个妹子类的平均水平] * @return {[type]} [description] */Girl.prototype.toString = function() { console.info(`This girl: ${(this.sexualLow + this.sexualHigh) / 2}${this.pretty}`);};// 声明一个妹子类的实例var lisa = new Girl(&apos;B&apos;, 32, 36);lisa.include(34); // 查看该妹子是否在区间内lisa.foreach(console.warn); // 打印出该妹子实例的各个属性lisa.toString(); // 查看该妹子平均指标 12345678var p = Girl.prototype; // 定义一个原型对象var c = p.constructor; // 该原型对象的构造函数c === Girl; // true Girl.prototype.constructor === Girl 原型对象的构造函数指向其本身// 对实例对象来说，它的构造函数就是它的类lisa.constructor === Girl; // truelisa.__proto__ === Girl.prototype; // __proto__指向构造函数的原型对象lisa instanceof Girl // true 继承自Girl类 构造函数对象：用于生成类的函数，为JavaScript的类定义了名字。 原型对象：类的唯一标识————原型对象的属性被所有实例所继承。如果某个属性是函数的话，就会作为类的实例的方法来使用。 实例对象：类的实例，每一个都是独立的对象。在该实例上添加属性是不会影响其他实例的，但在原型对象上添加方法会影响所有实例。 定义在实例上的非函数属性，实际上是实例字段。 下面定义一个函数，分三步定义一个类。 我们将定义类的步骤封装成一个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 需要提前声明一个函数/** * [extend 合并对象属性，复制p中对象属性到o中] * @param {[type]} o [description] * @param {[type]} p [description] * @return {[type]} [description] */function extend(o, p) { for (prop in p) { // 并不会覆盖对象中原有属性 if (o[prop] === void 0) { o[prop] = p[prop]; } } return o;}/** * [defineClass 定义类的函数] * @param {[type]} constructor [构造函数] * @param {[type]} method [在原型对象上添加属性，可继承] * @param {[type]} static [直接在类上添加属性， 不可继承] * @return {[type]} [返回构造函数] */function defineClass(constructor, method, static) { if (method) { extend(constructor.prototype, method); } if (static) { // static 在严格模式下是保留字，之后请谨慎使用 extend(constructor, static); } return constructor;}// 调用该方法生成另一个类var Girl2 = defineClass( function(pretty, sexualLow, sexualHigh) { if (isNaN(sexualLow) || isNaN(sexualHigh)) { throw new TypeError(); } this.pretty = pretty; this.sexualLow = sexualLow; this.sexualHigh = sexualHigh; }, { foreach: function(f) { f.call(this, this.pretty, this.sexualLow, this.sexualHigh); }, include: function(sexual) { return sexual &gt; this.sexualLow &amp;&amp; sexual &lt; this.sexualHigh; }, toString: function() { console.info(`This girl: ${(this.sexualLow + this.sexualHigh) / 2}${this.pretty}`); } }, // 随机生成一个性感的妹子 { random: function() { var min = new Date().getMinutes(); var type = (min % 3) === 0 ? &apos;A&apos;: (min % 3) === 1 ? &apos;B&apos; : &apos;C&apos;; return `${Math.ceil(Math.random() * 10) + 30}${type}`; } })// 生成一个Girl2的实例var monika = new Girl2(&apos;D&apos;, 34, 38);monika.foreach(console.info); // D 34 38monika.include(31); // falsemonika.include(35); // truemonika.toString(); // [object Object] 因extend不会覆盖原方法，所以这里仍然是Object.prototype.toString自带方法, 如果要去掉，将extend中的if条件判断去除即可monika.random(); // 报错 Uncaught TypeError: monika.random is not a function(...) 因为monika实例未继承类自身的方法Girl2.random(); // 随机生成 例如：&apos;36C&apos; 毕竟不是灵魂画手，大概便是这样…… ​","link":"/2016/12/12/understanding-class-in-javascript-part1/"},{"title":"理解 react-router 中的 history","text":"对 react-router 的分析，目前准备主要集中在三点：a. history 的分析。b. history 与 react-router 的联系。c. react-router 内部匹配及显示原理。这篇文章准备着重理解 history. 推荐：★★★☆ 索引 引子 history核心 走进createBrowserHistory history在react-router中 小结 占位坑 参考 引子 一段显而易见出现在各大 react v16+ 项目中的代码是这样的: 123456789101112131415import React, {Component} from &apos;react&apos;import { render } from &apos;react-dom&apos;import { Router, Route } from &apos;react-router&apos;import { createBrowserHistory } from &apos;history&apos;const history = createBrowserHistory()const App = () =&gt; ( &lt;Router history={history}&gt; &lt;div id=&quot;app&quot;&gt; {/* something */} &lt;/div&gt; &lt;/Router&gt;)render(&lt;App/&gt;, document.body.querySelector(&apos;#app&apos;)) 在 react v16+ 版本里，通常 react-router 也升级到了 4 以上。 而 react-router v4+ 通常是配合 history v4.6+ 使用的。 下面就先从 history 开始，让我们一步一步走近 react-router 的神秘世界。 history核心 history源码 history 在内部主要导出了三个方法: createBrowserHistory, createHashHistory, createMemoryHistory. 它们分别有着自己的作用: createBrowserHistory 是为现代主流且支持 HTML5 history 浏览器提供的 API. createHashHistory 是为不支持 history 功能的浏览器提供的 API. createMemoryHistory 则是为没有 DOM 环境例如 node 或 React-Native 或测试提供的 API. 我们就先从最接地气的 createBrowserHistory 也就是我们上文中使用的方法开始看起。 走进createBrowserHistory 话不多说，直接走进 createBrowserHistory源码 1234/** * Creates a history object that uses the HTML5 history API including * pushState, replaceState, and the popstate event. */ 在该方法的注释里，它说明了是它基于 H5 的 history 创建的对象，对象内包括了一些常用的方法譬如 pushState,replaceState,popstate 等等。 history 对象 那么它具体返回了什么内容呢，下面就是它目前所有的方法和属性: 1234567891011121314const globalHistory = window.history;const history = { length: globalHistory.length, // (number) The number of entries in the history stack action: &quot;POP&quot;, // (string) The current action (`PUSH`, `REPLACE`, or `POP`) location: initialLocation, // (object) The current location. May have the following properties. createHref, push, // (function) Pushes a new entry onto the history stack replace, // (function) Replaces the current entry on the history stack go, // (function) Moves the pointer in the history stack by `n` entries goBack, // (function) Equivalent to `go(-1)` goForward, // (function) Equivalent to `go(1)` block, // (function) Prevents navigation listen} globalHistory.length 显而易见是当前存的历史栈的数量。 createHref 根据根路径创建新路径，在根路径上添加原地址所带的 search, pathname, path 参数, 推测作用是将路径简化。 location 当前的 location, 可能含有以下几个属性。 path - (string) 当前 url 的路径 path. search - (string) 当前 url 的查询参数 query string. hash - (string) 当前 url 的哈希值 hash. state - - (object) 存储栈的内容。仅存在浏览器历史和内存历史中。 block 阻止浏览器的默认导航。用于在用户离开页面前弹窗提示用户相应内容。the history docs 其中，go/goBack/goForward 是对原生 history.go 的简单封装。 剩下的方法相对复杂些，因此在介绍 push, replace 等方法之前，先来了解下 transitionManager. 因为下面的很多实现，都用到了这个对象所提供的方法。 *transitionManager 方法介绍* 首先看下该对象返回了哪些方法：123456const transitionManager = { setPrompt, confirmTransitionTo, appendListener, notifyListeners} 在后续 popstate 相关的方法中，它就应用了 appendListener 和与之有关的 notifyListeners 方法，我们就先从这些方法看起。 它们的设计体现了常见的订阅-发布模式，前者负责实现订阅事件逻辑，后者负责最终发布逻辑。 1234567891011121314151617181920212223242526let listeners = [];/** * [description 订阅事件] * @param {Function} fn [description] * @return {Function} [description] */const appendListener = fn =&gt; { let isActive = true; // 订阅事件，做了函数柯里化处理，它实际上相当于运行了 `fn.apply(this, ...args)` const listener = (...args) =&gt; { if (isActive) fn(...args); }; // 将监听函数一一保存 listeners.push(listener); return () =&gt; { isActive = false; listeners = listeners.filter(item =&gt; item !== listener); };};/** * [发布逻辑] * @param {[type]} ..args [description] */const notifyListeners = (..args) =&gt; { listeners.forEach(listener =&gt; listener(..args))} 介绍了上面两个方法的定义，先别急。后续再介绍它们的具体应用。 然后来看看另一个使用的较多的方法 confirmTransitionTo. 123456789101112131415161718192021222324const confirmTransitionTo = ( location, action, getUserConfirmation, callback) =&gt; { if (prompt != null) { const result = typeof prompt === &quot;function&quot; ? prompt(location, action) : prompt; if (typeof result === &quot;string&quot;) { if (typeof getUserConfirmation === &quot;function&quot;) { getUserConfirmation(result, callback); } else { callback(true); } } else { // Return false from a transition hook to cancel the transition. // 如果已经在执行，则暂时停止执行 callback(result !== false); } } else { callback(true); }}; 实际上执行的就是从外部传进来的 callback 方法，只是多了几层判断来做校验，而且传入了布尔值来控制是否需要真的执行回调函数。 transitionManager 调用 再然后我们来看看上述方法 appendListener, notifyListeners 的具体应用。前者体现在了 popstate 事件的订阅中。 那么就先简单谈谈 popstate 事件。 当做出浏览器动作时，会触发 popstate 事件, 例如点击浏览器的回退。也就是说，popstate 本身并不是像 pushState 或 replaceState 一样是 history 的方法。 不能使用 history.popState 这样的方式来调用。 而且，直接调用 history.pushState 或 history.replaceState 不会触发 popstate 事件。 在事件监听方法 listen 中涉及了 popstate 的使用，在源码中可以看到以下两个方法 listen 和 checkDOMListeners. 它们就是上述订阅事件的具体调用方。 12345678910111213141516171819202122232425262728293031323334353637// 首先自然是初始化const transitionManager = createTransitionManager();const PopStateEvent = &quot;popstate&quot;;const HashChangeEvent = &quot;hashchange&quot;;// 当 URL 的片段标识符更改时，将触发 hashchange 事件（跟在 # 后面的部分，包括 # 符号）// https://developer.mozilla.org/zh-CN/docs/Web/Events/hashchange// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchangeconst checkDOMListeners = delta =&gt; { listenerCount += delta; if (listenerCount === 1) { // 其实也是最常见最简单的订阅事件, handlePopState 对应的内容在下文有说明 window.addEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange); } else if (listenerCount === 0) { window.removeEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange); }};/** * [订阅事件的具体调用方] * @param {Function} listener [description] * @return {Function} [description] */const listen = listener =&gt; { // 返回一个解绑函数 const unlisten = transitionManager.appendListener(listener); checkDOMListeners(1); // 返回的函数负责取消 return () =&gt; { checkDOMListeners(-1); unlisten(); };}; 简言之，调用 listen 就是给 window 绑定了相应方法，再次调用之前 listen 返回的函数则是取消。 然后来看看发布事件的具体调用方 setState。它在 createBrowserHistory.js 中定义，在 popstate 、 push 与 replace 中均有调用。 12345678910/** * 在该方法中发布 * @param {*} nextState [入参合并到 history] */const setState = nextState =&gt; { Object.assign(history, nextState); history.length = globalHistory.length; // 执行所有的监听函数 transitionManager.notifyListeners(history.location, history.action);}; 以上是 setState 的定义。我们来看看它在 popstate 中的使用。 上文有许多代码，以此关键代码为例： window.addEventListener(PopStateEvent, handlePopState); 12345678910111213141516171819202122const handlePopState = (event) =&gt; { handlePop(getDOMLocation(event.state))}let forceNextPop = falseconst handlePop = (location) =&gt; { if (forceNextPop) { forceNextPop = false setState() } else { const action = &apos;POP&apos; transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) =&gt; { if (ok) { setState({ action, location }) } else { revertPop(location) } }) }} 浏览器注册了 popstate 事件，对应的 handlePopState 的方法则最终调用了 setState 方法。 翻译成白话就是浏览器回退操作的时候，会触发 setState 方法。它将在下文以及后一篇博文里起到重要作用。 下面的方法则应用了 confirmTransitionTo. push, replace 这两个上文提到的重要方法，是原生方法的扩展。它们都用到了上述分析过的方法，都负责实现跳转，因此内部有较多逻辑相同。 后面会以 push 为例, 它其实就是对原生的 history.pushState 的强化。 那么这里就先从原生的 history.pushState 开始熟悉了解。 history.pushState 接收三个参数，第一个为状态对象，第二个为标题，第三个为 Url. 状态对象：一个可序列化的对象，且序列化后小于 640k. 否则该方法会抛出异常。（暂时不知这对象可以拿来做什么用，或许 react-router 用来标识页面的变化，以此渲染组件） 标题(目前被忽略)：给页面添加标题。目前使用空字符串作为参数是安全的，未来则是不安全的。Firefox 目前还未实现它。 URL(可选)：新的历史 URL 记录。直接调用并不会加载它，但在其他情况下，重新打开浏览器或者刷新时会加载新页面。 一个常见的调用是 history.pushState({ foo: &apos;bar&apos;}, &apos;page1&apos;, &apos;bar.html&apos;). 调用后浏览器的 url 会立即更新，但页面并不会重新加载。例如 www.google.com 变更为 www.google.com/bar.html. 但页面不会刷新。 注意，此时并不会调用 popstate 事件。只有在上述操作后，访问了其他页面，然后点击返回，或者调用 history.go(-1)/history.back() 时，popstate 会被触发。 让我们在代码中更直观的看吧。 12345678910111213141516// 定义一个 popstate 事件window.onpopstate = function(event) { console.info(event.state)}const page1 = { page: &apos;page1&apos; }const page2 = { page: &apos;page2&apos; }history.pushState(page1, &apos;page1&apos;, &apos;page1.html&apos;)// 页面地址由 www.google.com =&gt; www.google.com/page1.html// 但不会刷新或重新渲染history.pushState(page2, &apos;page2&apos;, &apos;page2.html&apos;)// 页面地址由 www.google.com/page2.html =&gt; www.google.com/page2.html// 但不会刷新或重新渲染// 此时执行history.back() // history.go(-1)// 会触发 popstate 事件, 打印出 page1 对象// { page: &apos;page1&apos; } 介绍完 pushState 后，看看 history 中是怎样实现它的。 1234567891011121314151617181920212223242526272829const push = (path, state) =&gt; { const action = &quot;PUSH&quot;; const location = createLocation(path, state, createKey(), history.location); // 过渡方法的应用 transitionManager.confirmTransitionTo( location, action, getUserConfirmation, ok =&gt; { // 布尔值，用于判断是否需要执行 if (!ok) return; const href = createHref(location); const { key, state } = location; // 在支持 history 的地方则使用 history.pushState 方法实现 if (canUseHistory) { globalHistory.pushState({ key, state }, null, href); if (forceRefresh) { window.location.href = href } else { // 如果是非强制刷新时，会更新状态，后续在 react-router 中起到重要作用 // 上文提到过的发布事件调用处 setState({ action, location }) } } else { window.location.href = href; } } );}; 关键代码：globalHistory.pushState({ key, state }, null, href); 和上文分析的一致。 pushState 和 push 方法讲完，replaceState 和 replace 也就很好理解了。 replaceState 只是把推进栈的方式改为替换栈的行为。它接收的参数与 pushState 完全相同。只是方法调用后执行的效果不同。 补：本来如果仅仅是介绍当前的 history. 我之前以为找到 pushState 这个核心就已经足够了。但当我继续深入，探究 react-router 原理的时候，才发现这里遗漏了重要的一点。那就是 setState 方法。 那么这个方法具体做了什么呢。在上文中已经做了简单介绍，这里再重申一遍：就是将当前 state 存入 history, 同时发布事件，也就是调用之前订阅时的保存的所有方法。参数则是 [history.location, history.action]. 或许现在，我们可能对该方法的重要性没有那么深的理解，当你再结合后一篇分析 react-router 的文章，就知道它起的作用了。 history在react-router中 这篇文章快完成的时候，我才发现 react-router 仓库里是有 history 的介绍的。此时我一脸茫然。这里面内容虽然不多，却非常值得参考。这里做部分翻译和理解，当作对上文的补充。 原地址 history is mutable 在原文档中，说明了 history 对象是可变的。因此建议在 react-router 中获取 location 时可以使用 Route 的 props 的方式来替代 history.location 的方式。这样的方式会确保你的流程处于 React 的生命周期中。例如： 1234567891011class Comp extends React.Component { componentWillReceiveProps(nextProps) { // 正确的打开方式 const locationChanged = nextProps.location !== this.props.location // 错误的打开方式，因为 history 是可变的，所以这里总是不等的 // will *always* be false because history is mutable. const locationChanged = nextProps.history.location !== this.props.history.location }}&lt;Route component={Comp}/&gt; 更多内容请查看the history documentation. 小结 一句话形容 history 这个库。它是一个对 HTML5 原生 history 的拓展，它对外输出三个方法，用以在支持原生 api 的环境和不兼容的环境，还有 node 环境中调用。而该方法返回的就是一个增强的 history api. 写这篇文章的时候，第一次有感受到技术栈拓展的无穷魅力。从最初试图分析 react-router，到发现它依赖的主要的库 history. 再进行细化，到 history 主要提供的对象方法。里面涉及的发布订阅设计模式、思路、以及具体的实现使用了柯里化方式。一步一步探究下去可以发现很多有趣的地方。似乎又唤起往日的技术热情。 下一篇文章将会继续介绍 react-router. 占位坑 下面两个方法返回的内容和 createBrowserHistory 基本一致，只是具体的实现有部分差别。有时间补上。 createHashHistory createMemoryHistory 参考react-router 的实现原理react-router 源代码学习笔记 Javascript设计模式之发布-订阅模式","link":"/2018/07/29/understanding-history-in-react-router/"},{"title":"浅谈 react-router 实现原理","text":"从上篇文章可以知道，react-router 本质上，利用了 history api 的 pushState, replaceState 方法来控制路由地址，然后使用 popstate, hashchange 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。推荐：★★★★ 索引 引子 组件 Link Router Router Route Switch withRouter react-router与react-router-dom 小结 遗留的坑 参考 引子 如上所说，其实在 history 与 react-router 之间，核心就差了视图如何变化的逻辑部分。 在了解到内部原理之前，我理解的流程图是这样的。 接下来我们来慢慢找出这剩余的部分。然后来看看和最初的印象有什么不同。 注意：这里的所有代码均基于 react-router 的 v4+ 版本。 组件 我最初的想法是查看调用栈来观察路由和视图的变化关系。于是写了一个组件，点击事件调用 pushState/replaceState 方法来手动更新浏览器地址，但是却发现，不会有什么变化。其实这符合预期，这个方法本身就只会更新地址，而不会更新页面，不会让页面重新加载。 因此，让我们还是从组件入手。 从这里可以看到有许多组件。我们着重分析其中的 Link、Router、Route、Switch. 剩余的也就顺理成章去理解了。 Link Link 是 react-router-dom 提供的一个组件。用来实现路由间的切换。至于 react-router-dom 和 react-router 的关系后文会说。 那为什么 Link 就可以轻松做到跳转呢。让我们一步步来看 Link 里都有什么。 打印出 Link，简化后，主要是以下的部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * The public API for rendering a history-aware &lt;a&gt;. */class Link extends React.Component { static defaultProps = { replace: false } // 参数都是必传的 static contextTypes = { router: PropTypes.shape({ history: PropTypes.shape({ push: PropTypes.func.isRequired, replace: PropTypes.func.isRequired, createHref: PropTypes.func.isRequired }).isRequired }).isRequired } handleClick = (event) =&gt; { if (this.props.onClick) this.props.onClick(event) if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore right clicks !this.props.target &amp;&amp; // let browser handle &quot;target=_blank&quot; etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) { event.preventDefault() const { history } = this.context.router const { replace, to } = this.props if (replace) { history.replace(to) } else { history.push(to) } } } render() { const { replace, to, innerRef, ...props } = this.props // eslint-disable-line no-unused-vars const href = this.context.router.history.createHref( typeof to === &apos;string&apos; ? { pathname: to } : to ) return &lt;a {...props} onClick={this.handleClick} href={href} ref={innerRef}/&gt; }} 可以很明确的看到，Link 标签本质上返回的是 a 标签。只是对 onClick 方法做了处理。 而在 click 方法里，最主要的处理就是禁用默认事件，也就是阻止 a 标签默认的跳转 href 的行为。避免直接跳转页面。然后使用 history 的 push(pushState) 和 replace(replaceState) 方法进行跳转。 push 方法里除了核心的 pushState 逻辑，还有另一个核心操作 setState. 详情可见 在它的逻辑里，它调用了之前注册的方法。后文会提到。 这里的 history 就是上篇文章分析的 history，只不过在 react-router 库里，它被当成 props 的部分，由最上层往下传递。至于为何这样做，是可以更好的管理 history, 和在组件里进行 diff 比对从而去做其他处理。上篇文末有说明。 然后观察传入给 a 的参数 to. 它接受 String 或者 Object. 通常我们会以 String 的形式传入。但最终它会被包装成类似 { pathname: to } 这样的格式。 其实这个组件本质上做的事情，和我们在引子里理解的内容类似。基于 history 的操作，那么接收方是如何去根据变化而渲染组件的呢。来看看其他的重要组件。 Link 文档 Router Router 是 react-router 里最常用的组件之一，它接收 history 和 children 两个参数。 这个组件属于较底层的组件，实际应用的时候可能会使用基于它扩展后的组件，来应对不同场景下的需求。例如在官方文档里，列举了以下几个具体的组件。 &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; BrowserRouter 是在现代浏览器里使用较多的组件，它在支持 HTML5 的 history API 的地方使用。通过独立的包 react-router-dom 提供。其余组件做的事情类似，只是使用方式略有不同，这里不再赘述。 这里是具体的文档 通常情况下，Router 作为父组件，包裹着 Route 和 Switch 等组件。 观察它的源码。它本质上也是 React 组件。在渲染的时候，注册监听了事件。下文细说。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * The public API for putting history on context. */class Router extends React.Component { static propTypes = { history: PropTypes.object.isRequired, children: PropTypes.node } static contextTypes = { router: PropTypes.object } static childContextTypes = { router: PropTypes.object.isRequired } getChildContext() { return { router: { ...this.context.router, history: this.props.history, route: { location: this.props.history.location, match: this.state.match } } } } state = { match: this.computeMatch(this.props.history.location.pathname) } computeMatch(pathname) { return { path: &apos;/&apos;, url: &apos;/&apos;, params: {}, isExact: pathname === &apos;/&apos; } } componentWillMount() { const { children, history } = this.props // Do this here so we can setState when a &lt;Redirect&gt; changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a &lt;StaticRouter&gt;. this.unlisten = history.listen(() =&gt; { this.setState({ match: this.computeMatch(history.location.pathname) }) }) } componentWillUnmount() { this.unlisten() } render() { const { children } = this.props return children ? React.Children.only(children) : null }}export default Router 在静态 props 里可以看到，history 是必须的。印证了我们的常规用法。生成 history 后再作为上下文传入组件内，向下传递给子组件。&lt;Router history={history}&gt; 然后在生命周期 componentWillMount 里，使用 history.listen 注册了 setState 事件。当路由变化时，会自动触发 history 内的 setState 事件，进而触发当前传入的更新 state 的事件。原理就是上文的 Link 的内部逻辑，加上之前分析的 history 的 push 方法里的逻辑和事件订阅发布逻辑。 注意这里，使用箭头函数保证 this 的指向仍是 Router. 当 Link 点击事件触发时，实际上调用的是当前的 this.setState({ match: this.computeMatch(history.location.pathname) }) 方法。 此时返回的 match 是形如 { path: &apos;/&apos;, url: &apos;/&apos;, params: {}, isExact: pathname === &apos;/&apos;} 的对象。 return { router: { route: { match: this.state.match } } } 通过 getChildContext 方法以上下文 context 的方式传给子组件 route. 这就一部分解释了为什么 Link 里，点击后的事件，会导致当前 Router 的 state 的变化，进而改变 context.router 里的内容。然后将此传递给子组件 Route. 然后它返回一个解绑函数。在组件卸载 componentWillUnmount 时调用 unlisten 卸载。 到这里，这就是动作变化引起视图变化的核心逻辑了。接下来是，视图如何根据传入的值匹配应当显示的组件。 context.router 的简单介绍 Route 首先了解下基本的用法。Route 组件是允许传入几种不同类型的值的。 文档 component: 直接将组件传入。当路由匹配的时候才会渲染，将 props 作为参数传入，然后创建元素。 &lt;Route path=&apos;/&apos; exact component={Main}/&gt; 创建方式：React.createElement(props) render: 返回一个函数，可以直接是包装后的组件，或者直接是元素。直接调用。 &lt;Route path=&apos;/home&apos; render={() =&gt; &lt;Home/&gt;} /&gt; 创建方式：render(props) children: 一个函数，和 render 类似。但它在任何情况下，只要传入值就会渲染。它接收的 props 和其他方式相同，除了在不匹配的情况下，match 的值为 null 这点不同。它的业务场景，可能是用于一些固定显示在页面的组件，然后通过 match 的值来控制样式。 以下是简化的 Route 源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import matchPath from &apos;./matchPath&apos;/** * The public API for matching a single path and rendering. */class Route extends React.Component { static contextTypes = { router: PropTypes.shape({ history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object }) } getChildContext() { return { router: { ...this.context.router, route: { location: this.props.location || this.context.router.route.location, match: this.state.match } } } } state = { match: this.computeMatch(this.props, this.context.router) } computeMatch({ computedMatch, location, path, strict, exact, sensitive }, router) { if (computedMatch) return computedMatch // &lt;Switch&gt; already computed the match for us const { route } = router const pathname = (location || route.location).pathname return path ? matchPath(pathname, { path, strict, exact, sensitive }) : route.match } componentWillReceiveProps(nextProps, nextContext) { this.setState({ match: this.computeMatch(nextProps, nextContext.router) }) } render() { const { match } = this.state const { children, component, render } = this.props const { history, route, staticContext } = this.context.router const location = this.props.location || route.location const props = { match, location, history, staticContext } return ( component ? ( // component prop gets first priority, only called if there&apos;s a match match ? React.createElement(component, props) : null ) : render ? ( // render prop is next, only called if there&apos;s a match match ? render(props) : null ) : children ? ( // children come last, always called typeof children === &apos;function&apos; ? ( children(props) ) : !isEmptyChildren(children) ? ( React.Children.only(children) ) : ( null ) ) : ( null ) ) }}export default Route 在 Route 组件里，首先我们看到 render 里，由组件的内容类型来决定渲染是 component 或 render 或 children. 然后由 this.state.match 这个字段决定了当前的元素是否渲染。 接着在上述源码里，this.state.match 字段是在 componentWillReceiveProps 和初始化里可以看到。而这个变量，由一个比较重要的函数 computeMatch 返回。它是用来对比当前路由是否匹配，依此来决定渲染组件或者不渲染。它的具体的值下文会讲到。 computeMatch 接收 nextProps 和 context.router 作为参数。首先判断是否处于 Switch 组件中，如果在其中，则直接走 Switch 安排的逻辑，它有着自己的一套计算匹配逻辑。否则，则继续判断。 接下来的核心判断，是获取 pathname, 通过 props.location || context.router.route.pathname 获取。然后将其作为参数，传入另一个重要方法 matchPath 中，做计算匹配的逻辑。 当然，有一些参数作为辅助判断，例如 exact、sensitive、strict等。 matchPath 是外部引入的，独立的一个文件包装的方法。可以直接看源码。 matchPath源码和文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import pathToRegexp from &apos;path-to-regexp&apos;const patternCache = {}const cacheLimit = 10000let cacheCount = 0const compilePath = (pattern, options) =&gt; { const cacheKey = `${options.end}${options.strict}${options.sensitive}` const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {}) if (cache[pattern]) return cache[pattern] const keys = [] const re = pathToRegexp(pattern, keys, options) const compiledPattern = { re, keys } if (cacheCount &lt; cacheLimit) { cache[pattern] = compiledPattern cacheCount++ } return compiledPattern}/** * Public API for matching a URL pathname to a path pattern. */const matchPath = (pathname, options = {}) =&gt; { if (typeof options === &apos;string&apos;) options = { path: options } const { path = &apos;/&apos;, exact = false, strict = false, sensitive = false } = options const { re, keys } = compilePath(path, { end: exact, strict, sensitive }) const match = re.exec(pathname) if (!match) return null const [ url, ...values ] = match const isExact = pathname === url if (exact &amp;&amp; !isExact) return null return { path, // the path pattern used to match url: path === &apos;/&apos; &amp;&amp; url === &apos;&apos; ? &apos;/&apos; : url, // the matched portion of the URL isExact, // whether or not we matched exactly params: keys.reduce((memo, key, index) =&gt; { memo[key.name] = values[index] return memo }, {}) }}export default matchPath matchPath 通过返回一个对象，来确定路由是否匹配。(官方文档有关于这个对象的介绍match)如果匹配，则返回一个包含 path, url, isExact, params 等属性的对象。否则，则返回 null. 判断的主要逻辑是通过正则。 引入了外部的独立的库 path-to-regexp 来将地址转化成正则。 compilePath 方法里： const re = pathToRegexp(pattern, keys, options) const { re, keys } = compilePath(path, { end: exact, strict, sensitive }) const match = re.exec(pathname) 这里的返回对象，最终在 Route 组件的 render 中起到了决定性的作用。每一个 Route 都会根据这个 match 对象来判断，符合则渲染，不符合则返回 null. compilePath 中可以看到，除了上述常规判断以外，加了一层缓存逻辑。cache[pattern] 保存了上次的记录，可以直接从缓存中读取。只是属性名比较奇怪，类似 truefalsefalse 的形式。这里不确定只是幽默还是有意义的设计。 Switch 观察 Switch 的源码可以发现，它本质上也是调用了 matchPath 来判断匹配结果。 { computedMatch: match } 作为入参传入，呼应了上文的判断。 这里是文档 1234567891011121314151617181920212223242526272829303132333435import matchPath from &apos;./matchPath&apos;/** * The public API for rendering the first &lt;Route&gt; that matches. */class Switch extends React.Component { static contextTypes = { router: PropTypes.shape({ route: PropTypes.object.isRequired }).isRequired } render() { const { route } = this.context.router const { children } = this.props const location = this.props.location || route.location let match, child React.Children.forEach(children, element =&gt; { if (!React.isValidElement(element)) return const { path: pathProp, exact, strict, sensitive, from } = element.props const path = pathProp || from if (match == null) { child = element match = path ? matchPath(location.pathname, { path, exact, strict, sensitive }) : route.match } }) return match ? React.cloneElement(child, { location, computedMatch: match }) : null }}export default Switch withRouter withRouter 是一个高阶组件。个人理解，它比较像是 react-redux 的 Provider 组件。它将原生的组件传入，然后通过 Route 包装，沿用 props 当前的组件，返回这个包装后的组件。 12345678910111213141516171819202122232425import hoistStatics from &apos;hoist-non-react-statics&apos;import Route from &apos;./Route&apos;/*** A public higher-order component to access the imperative API*/const withRouter = (Component) =&gt; { const C = (props) =&gt; { const { wrappedComponentRef, ...remainingProps } = props return ( &lt;Route render={routeComponentProps =&gt; ( &lt;Component {...remainingProps} {...routeComponentProps} ref={wrappedComponentRef}/&gt; )}/&gt; ) } C.displayName = `withRouter(${Component.displayName || Component.name})` C.WrappedComponent = Component C.propTypes = { wrappedComponentRef: PropTypes.func } return hoistStatics(C, Component)}export default withRouter 目前在项目中我还没有用到它，等用到的时候，再来补充下具体的使用场景。 这里是文档 react-router与react-router-dom 好了，现在来补充这两个库的不同。 react-router 是一个底层的库，任何其他的基于 React 的路由库都基于它。但是在实际应用中，我们可能要对不同的场景做一些细分，以便更好地使用它们。 于是，就有了为现代浏览器提供的 react-router-dom. 观察代码可以发现，它的核心组件，例如 Route、Switch、withRouter 都是从 react-router 直接引入的。 另外，例如 BrowserRouter 这个组件则是在内部自己创建了 history, 从而略去了手动创建。它本质上仍然是 Router, 外加一个自给自足的过程。 history = createHistory(this.props) 除此之外，自然还有在 React-Native 中使用的 react-router-native, 以及结合 redux 使用的 react-router-redux 等等。 小结 在了解完这么多组件的内容和原理后，相信我们对于 react-router 的实现，有了一定的清晰思路了。我们会发现，最终总结的和最初理解的不一样。其实就是自己的理解在一开始是不完善的，甚至有些误解。这个时候，让我们再把流程图再重新梳理，画一遍。下面是简略的更新逻辑过程。 下面是一张调用栈的图，或许可以更直观地展示调用了哪些方法以及它们的执行顺序。以 Link 的点击事件流程为例。 遗漏的坑 到此，主要的逻辑就解释完毕了。 以下是遗留的几个待完成的 TODO. 可能会马上补上也可能需要点时间，但最终，我会补上的。 react-router 或 history 在 node 中的应用。 path-to-regexp 的原理及为何使用缓存。 使用缓存来节约内存空间。2019-06 补坑。 popstate 和 hashchange 最后到底在哪些地方进行了调用和应用。 在上篇 history 的文章已有说明。2019-06 补坑。 参考[译]简明React Router v4教程前端路由实现及 react-router v4 源码分析","link":"/2019/01/03/understanding-react-router/"},{"title":"项目中 React hooks + context + ts 实战及体会","text":"引言：随着小伙伴们使用 hooks 越来越多，项目的复杂度也随之变化。有必要考虑下实际业务中，当前的 mobx 是否还能坚挺的适配 hooks + ts 的组合。推荐：★★★★ 索引 如何选择 考量维度 最佳实践 业务实战 小结 如何选择个人对于数据流方案的考虑，出于以下几点，不分先后顺序，只是作为考虑的维度，来探索有什么数据流方案，可能会比当前的更适合；或者其他的方案，虽然当下不适合，但却能够提供给我们更多的选择空间和思考。 引入包的成本。 学习成本。 和 hooks 的适配能力，以及是否兼容 class 写法。 与 ts 的支持能力。 可维护性。 当前以及未来可能的生态，扩展能力。 考量维度引入成本 这个其实比较好理解，这个包的大小，以及压缩后的大小是考量的维度，这里自然是越小越好的。尤其是，某些库需要考虑的不仅仅是它本身，还有它与 React 结合所需要引入的库。 学习成本 就目前而言，学习成本最低的自然是项目中已经用到的 mobx。大家已经熟悉了它的运作方式和写法。与 hooks 的结合相对来说也是容易上手的。 适配能力，兼容 class 在实际的生产环境项目里，class 和 hooks 还是混合使用的。已存在的项目大多数还是以 class 写法运行，因此这个数据流方案最好能够兼容 class 写法，以便我们还是可以方便的更新和维护它。 支持 ts 现在我们组内的新项目必须是 ts 项目，所以这一点不可或缺。 可维护性 我理解的这一点，是指异常捕获方面，可调试性。当我遇到非期望的错误时，我是否可以很快的调试，定位到问题。 还有一点即是说，这个库是否长期有效，这点很重要。因为一个项目，很重要的是稳定。大多数项目并非是朝生暮死的。长期运行的项目，使用了某个库，结果一年后这个库没有人维护了，那是万万不可的，后续迁移的成本，维护的成本都是成倍增长的。 生态以及扩展能力 生态就是上手成本和解决问题的速度。 前者是说，有一个比较好的文档社区，例子浅显易懂好上手。 后者则是，踩坑，填坑的速度。具体比如说，当你遇到一个问题的时候，你在这个社区里搜索，你的坑有人踩过，并且有方案解决，或者即使没有现成的解决方案，你提出来，社区里的小伙伴们也能愉快地协助你来解决完成。这就是一个比较好的生态。 我所理解的生态还包括一点，就是它的扩展能力，时下 ts 是比较流行的 js 扩展方式，那么未来是否还有其他可能呢，就像当年的 coffeescript 而来的过渡。或者与其他组件库搭配，形成更强大的能力。 最佳实践的选择 有关方案的选择——最好是，根据不同的项目规模，业务复杂度，来结合使用不同的数据流方案，当然，一种方案能解决所有问题自然是最好的。 目前的实际情况mobx 的结论 目前看下来，mobx 结合 hooks 还是完全可以应付的了实际业务的。兼容 hooks 和 class 的写法，应该也支持 ts 写法（这个我自己还没实践，并不完全确认） 那么为什么还是要考虑其他方案呢，因为 mobx 还是有点大了。这个插件展示了具体大小，mobx 与 mobx-react 加起来有近 70k 的大小。 而且，个人觉得，mobx 对于数据变更的溯源并不是那么清楚，它是订阅式的。在使用 hooks 的情况下，推崇函数式编程，这不是与某个数据流理念很符合么，没错，就是 redux。 新的选择 实际上，hooks 的能力使得原生的 context 可以发挥出近似 redux 的效果了。 相比 redux，它最大的好处是不用再引入 redux 相关的库，大大减少了包体积，以及不需要使用繁琐的 connect, mapStateToProps 等方法。因为是原生的，所以可以即插即用，兼容性良好，无缝衔接 ts。 学习成本较低，因为几乎和 redux 一致，使用过 redux 就一定会使用它。 当然，缺点也是有的，就是相比而言，它继承了 redux 样板代码多的特性。但同时却也保证了数据的流向是清楚的，可追溯的。 具体的优缺点，下面会引入一个具体的案例。各位可以自行判断。 其他选择 其他方案当然也有，社区里 pullstate 、 constate、recoil 等。但这些无一不是生态不够完善，就是不能完美兼容 hooks 现有的和旧有的 class 写法兼容，或者不能很好和 ts 适配，又或者方案本身还不够成熟，达不到能在生产环境里使用的程度。 业务实战 下面我们以一个实际案例，来看看两者有什么区别，以及如何使用它们。 背景介绍 现在有一个列表页面，包含条件搜索，权限操作，弹窗处理等等。 页面地址 - 需内网访问 这里我们有一个很常见的场景，就是在一个列表页面内。搜索条件组件和表格展示组件是平级的两个页面子组件，它们会共享搜索参数 searchParams 这个数据，且搜索参数需要传递给他们的子组件，在这里，就是对应到表格的子组件——弹窗。 搜索的逻辑很好理解了，特别说明一下弹窗这里就是需要将当前搜索条件中的一部分也带过来，用在默认的查询参数上。 现在我们结合原有的代码，对它进行一些改造。先来看一下原始代码。 现有逻辑 这是页面中， 组合搜索和表格的入口页面。这里我们统统使用原生的 hooks 和 ts 实现。 12345678910111213141516171819const TeamBuilding: React.FC&lt;MyProps&gt; = props =&gt; { const [searchParams, setSearchParams] = useState(null); /** * 请求团建费数据 * @param values */ const onSearch = (values) =&gt; { setSearchParams(values); // do sth... }; return ( &lt;div className=&quot;remind-main&quot;&gt; &lt;Search onSearch={onSearch} handleSearchData={setSearchParams} /&gt; &lt;AdminTable searchParams={searchParams} /&gt; &lt;/div&gt; );}; 我们将 searchParams 这个搜索条件保存在最上层，也就是页面层级，供表格和搜索两个组件共用，其中搜索组件负责修改这个参数，而表格则仅仅是使用这个参数，当前这里是通过 props 的方式传递给表格。 setSearchParams 方法则是提供了修改它的能力。 表格的核心逻辑： 12345678910111213141516171819202122232425262728const AdminTable: React.FC&lt;TableProps&gt; = ({ onSearch, tableData, searchParams = {} }) =&gt; { const { year, deptId } = searchParams || {}; /** * 团队核销 */ const handleUseWalfare = () =&gt; { const data = { type: WALFARE_TYPE, deptId, year, }; handleUseWalfareApi(data) .then((res) =&gt; { res.code === 200 &amp;&amp; message.success(&apos;核销成功&apos;); onSearch(searchParams); }); }; // 注入该方法，供表格内部使用 const columns = columnsFn(handleUseWalfare); return &lt;&gt; &lt;div className=&quot;admin-table&quot;&gt; &lt;Table columns={columns} bordered pagination={false} rowKey=&quot;month&quot; size=&quot;small&quot;/&gt; &lt;/div&gt; &lt;PersonalWelfareModal year={year} /&gt; &lt;/&gt;;}; 可以看到，上述所说的搜索条件参数，是提供给一个实际操作交互里作为参数使用的，需要获取其中的某些字段当作参数，同时操作成功后又需要以同样参数进行刷新。 然后会将其中的属性 year, 继续传给弹窗组件使用。因为弹窗组件内的搜索也需要默认参数年份。 整体大概就是这么个样子 这里的繁琐就是在处理的时候，需要将状态抽离到最上层，然后层层传递 props。 改造代码 下面我们使用原生 context，和 hooks 中的 useReducer 的能力，来将这段逻辑改造成类 redux 的效果。 原始上下文需要初始值，这里因为用到了 ts. 所以我们用 ts 的方式定义初始值，并建立上下文。这部分是完全新增的一个文件。 12345678910111213141516171819202122232425262728export interface IState { searchParams?: { year?: string, deptId?: number };}const initialState: IState = { searchParams: {}};interface IContextProps { state: IState, dispatch: Dispatch&lt;TAction&gt;;}export const TeamBuildingContext = createContext&lt;IContextProps&gt;({ state: initialState, dispatch: () =&gt; {} });const TeamBuildingProvider: React.FC&lt;MyProps&gt; = props =&gt; { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;TeamBuildingContext.Provider value={{state, dispatch}}&gt; {props.children} &lt;/TeamBuildingContext.Provider&gt; );};export default TeamBuildingProvider; 可以看到，这个文件的作用是建立上下文，以及给这个上下文传入一个初始状态和更新方法。 注意上下文 TeamBuildContext 是需要导出的，然后需要维护的值以 value 的形式传入。 这里面只有 reducer 是外部导入的，我们一步步来看。 为了方便演示，而且这次只是以一个数据为例子，我就把 action 和 type 以及 reducer 的定义，通通放在一个文件里了。下面就是： 123456789101112131415161718192021222324252627import { Reducer } from &quot;react&quot;;export const UPDATE_PARAMS = &apos;UPDATE_PARAMS&apos;;export type UPDATE_PARAMS = typeof UPDATE_PARAMS;export interface IDispatch { type: UPDATE_PARAMS; payload: object; }export const updateParams = (payload: object): IDispatch =&gt; ({ payload, type: UPDATE_PARAMS });export type TAction = IDispatch;export const reducer: Reducer&lt;IState, TAction&gt; = (prevState: IState, action: TAction): IState =&gt; { const { type, payload } = action; switch (type) { case UPDATE_PARAMS: return { ...prevState, loading: false, searchParams: payload }; default: return prevState; }}; 可以看到，这是一个很经典的 reducer 写法。根据不同 type，匹配不同操作，并将操作后的新状态进行返回。 由于我们这里只对一个参数进行操作，所以相应的 action 和 type 也只写了一个。 然后接下来看看使用的地方，需要对原来的代码进行一些修改。为了方便，我重新定义了一个入口文件 index.js，把原先的入口组件改造成了 TeamBuildContainer.js 作为容器。这样就可以将提供上下文的能力与业务组件进行解耦。 这是入口文件 index.js 12345678910111213import React from &apos;react&apos;;import TeamBuildingProvider from &quot;./TeamBuildContext&quot;;import TeamBuildContainer from &apos;./TeamBuildContainer&apos;;const TeamBuildingHooks: React.FC = props =&gt; { return ( &lt;TeamBuildingProvider&gt; &lt;TeamBuildContainer {...props} /&gt; &lt;/TeamBuildingProvider&gt; );};export default TeamBuildingHooks; 很简单，只做了一件事，就是引入刚刚新增的上下文 TeamBuildingProvider 组件，进行包裹。 这样我们就可以在子组件内使用导入的 TeamBuildingContext 上下文，获取我们所需的 dispatch 方法和 state 值。 下面是改造后的 TeamBuildContainer.js 123456789101112131415161718192021222324import TeamBuildingProvider from &quot;./TeamBuildContext&quot;;const TeamBuildingContainer: React.FC&lt;MyProps&gt; = props =&gt; { const {dispatch} = useContext(TeamBuildingContext); const dispatchCb = (payload = {}, type) =&gt; dispatch &amp;&amp; dispatch({payload, type }); /** * 请求团建费数据 * @param values */ const onSearch = (values) =&gt; { dispatchCb(values, UPDATE_PARAMS); // do sth... }; return ( &lt;div className=&quot;remind-main&quot;&gt; &lt;Search onSearch={onSearch} /&gt; &lt;AdminTable onSearch={onSearch} /&gt; &lt;/div&gt; );};export default Form.create()(TeamBuildingContainer); 在这个页面中，我们需要使用 dispatch 来更新数据，但不需要直接使用状态，所以只用取出 dispatch 。 useContext 方法为我们提供了这样的能力。 可以明显的看到，这里不需要使用 props 的方式传递数据了。 再看看 adminTable 中是怎么取用数据的吧。 1234567891011121314151617181920212223242526272829303132import { TeamBuildingContext } from &quot;./../../TeamBuildContext&quot;;const AdminTable: React.FC&lt;TableProps&gt; = ({ onSearch }) =&gt; { const { state } = useContext(TeamBuildingContext); // 这里要设置初始值，不然会报错，主要是因为自动生成的接口字段对应的 ts 接口没有设置可选项，具体见 useWelfare.ts const { year = &apos;2020&apos;, deptId = 67 } = state.searchParams || {}; /** * 团队核销 */ const handleUseWalfare = () =&gt; { const data = { type: WALFARE_TYPE, deptId, year, }; handleUseWalfareApi(data) .then((res) =&gt; { res.code === 200 &amp;&amp; message.success(&apos;核销成功&apos;); onSearch(state); }); }; const columns = columnsFn(handleUseWalfare); return &lt;&gt; &lt;div className=&quot;admin-table&quot;&gt; &lt;Table columns={columns} bordered pagination={false} rowKey=&quot;month&quot; size=&quot;small&quot;/&gt; &lt;/div&gt; &lt;PersonalWelfareModal/&gt; &lt;/&gt;;}; 表格中取用的逻辑是完全类似的，这次 useContext 中我们只需要 state。 以此类推，在表格内的弹窗 PersonalWelfareModal 组件中，我们可以以完全一样的方式来取用 state 中我们所需的字段，而无需 props 传递。 以上，就是我们对原始逻辑的一次完整改造了。 我们使用了先前就有的 context, 和这次 hooks 新提供的 useContext, useReducer 等 api，达到了类似 redux 处理的效果。 这里我列举的只是一个比较常见的例子，不一定是最恰当的。这次业务里只是涉及到两层 props 的传递，实际业务中肯定有更多层级的传递，或是跨层级的共享。但最终，我们使用它的方式和理念一致的。 使用体验 相较于原生的组织方式，使用 context + ts 使得我们在创建时就约束好了数据格式 —— initialState。 然后在需要取用数据的地方，或者需要更新数据的地方，使用 useContext 取出，进行预期的操作。 至于具体的更新数据逻辑，则统一在 reducer 里定义。实现了展示层和逻辑层的解耦。当然，这里的例子十分小，具体业务里要实现这样的解耦，还需要做其他的统筹管理的努力。但从最终效果来说，理应是明显的。 这里我并没有很深入的去使用，但至少在目前的场景里，我理解使用 context 的状态管理是模块化的。只要创建 context 得当，那么每个模块都是独立分割的，很适合在一个模块里去统筹管理。它不像 redux 是在全局的顶层进行注入，需要使用的地方去 connect 连接；也不像 mobx，尽管也可以做到模块化，但通常会在顶层入口注入所有 store. 小结 事到如今，我们再来回顾一下，它在我自己总结的上述考量维度里，哪些是做的好的，哪些是做的不好的。以及怎么去权衡。 引入包的成本： 这点上，它无疑是最好的，因为它是天生内置，自带可以使用的，没有任何冗余依赖。 学习成本： 在仅仅使用过 mobx 数据管理方案的小伙伴身上，确实需要一点学习成本，不过它本身函数式的思想，和 hooks 的写法一脉相承，相信这点成本是相对容易克服的。 至于已经写过 redux 的小伙伴，自然是可以无缝衔接了。 适配能力，兼容能力： 这在上文已经体现很明显了，hooks 中是无须担心的。至于还在 class 的业务，可以使用 context ，但方式并不是类 redux 的方式了，这算是一个小缺憾把。不过，在使用 class 的项目中，基本上我们已经内置了 mobx 的方案了。 支持 ts 的能力： 上述例子中我们也可以看到了，这显然是无须担心的。 可维护性： 显而易见，只要 hooks 还在，这个方案就会一直随着它的更新而存在，不必担心有一天它突然不能使用了。 生态以及扩展能力： 由于是官方的亲生儿子，所以相信这一块的社区必定不少，我也是从网上搜索到了类似的例子，才能在生产项目里快速写出以上的无缝衔接代码。而且因为是天生的，它的扩展能力，例如我们对它的定制也应当是容易的，方便的。 综上，个人推荐在新的 hooks + ts 项目里，完全可以使用这个方案来实践。前提当然是我们没有非常巨大的量的数据需要处理，控制。 至于现有的项目，可以仍然使用 mobx，并同时在写 hooks 的时候使用这套方案。 也可以按项目大小的类型来区分，如下： 参考 State Management with React Hooks in TypeScript","link":"/2020/06/30/usecontext-with-typescript-in-reacthooks/"},{"title":"webpack实用插件安利之webpack-dashboard","text":"在github上explore的时候偶然发现这款插件，非常火爆，推出没多久就收货了几千stars。我在踩了几个坑后成功引入到公司的项目里。 webpack-dashboard是什么 它是webpack的一个面板，显示webpack在编译时的各种配置和提示信息。 在wd(webpack-dashboard这里简称为wd)引入之前，我们的命令行是这样显示的。 而使用了wd之后，就有了封面的效果。显示上不仅酷炫了很多，各种配置信息，文件大小，占用空间，语法检查也一目了然。 它的使用也非常简单，虽然我在引入时踩了一个不大不小的坑。在这里我要引以为戒。 以我的webpack.config.js为例，这是未加wd之前的js。 12345678910111213141516171819202122var webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;);var root_path = path.resolve(__dirname);var build_path = path.resolve(root_path, &apos;build&apos;);module.exports = { entry: { &apos;page/homepage/index&apos;: &apos;./src/page/homepage/index.js&apos; }, output:{ path: build_path, filename: &apos;[name].js&apos; }, module: { loaders: [ { test: /\\.css$/, loader: &apos;style!css&apos; }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)}, { test: /\\.less$/, loader: &apos;style!css!less&apos;, exclude: /node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader!less-loader&apos;)}, { test: /\\.(png|jpg)$/, loader: &apos;url?limit=8192&amp;name=img/[name].[ext]&apos; }, { test: /\\.js$/, loaders: [&apos;babel?presets[]=es2015&apos;], exclude: /node_modules/ } ] }}; 我运行webpack-dev-server --inline --devtool eval来进行webpack-dev-server的实时编译。 得到的效果如下，即和第二张图类似。 (请自动忽略那些低级报错) 虽然有log,但这些列表琳琅满目，让人无所适从。密密麻麻的给人里压迫感，使人窒息。 下面来试试wd。 webpack-dashboard使用 install : 在项目目录下npm install webpack-dashboard --save-dev 这里主要说明的是配合webback-dev-server使用的方式。 首先，引入dashboard和插件。 123var Dashboard = require(&apos;webpack-dashboard&apos;);var DashboardPlugin = require(&apos;webpack-dashboard/plugin&apos;);var dashboard = new Dashboard(); 其次，在配置部分加入实例化的插件。 1new DashboardPlugin(dashboard, setData); 然后，更新webpack-dev-server的配置。 123456new devServer{ publicPath: setting.output.publicPath, // 输出路径 inline: true, port: 2333, // 端口设置 quite: true // 必要参数} 最后，运行命令就可以看见炫酷的效果了。 12345package.json里配置&quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server&quot;}再运行`npm start`即可。 ​ Q&amp;A 补充下我运行时发现的一些问题 。 首次运行时有报错,如下。 找了很久，才意识到这是语法错误。它使用了ES6规范。而我当前的node版本是0.10.30,对ES6的支持很差。当我切换到0.12.x的时候，编译就成功了。最终我选择了0.12.10。 npm start时quiet配置会不生效，导致出现的dashboard面板上有重复的log信息。解决办法是运行时添加参数--quiet 最后再来看看配置文件和效果图。 12345678910111213141516171819202122232425262728293031323334353637383940414243var webpack = require(&apos;webpack&apos;);var path = require(&apos;path&apos;);var root_path = path.resolve(__dirname);var build_path = path.resolve(root_path, &apos;build&apos;);// dashboardvar Dashboard = require(&apos;webpack-dashboard&apos;);var DashboardPlugin = require(&apos;webpack-dashboard/plugin&apos;);var dashboard = new Dashboard();module.exports = { entry: { &apos;page/homepage/index&apos;: &apos;./src/page/homepage/index.js&apos; }, output:{ path: build_path, filename: &apos;[name].js&apos; }, // webpack-dev-server devServer: { inline: true, port: 2333, // quite: true // 拼写错误 quiet: true // Add quiet option for webpack dashboard }, module: { loaders: [ { test: /\\.css$/, loader: &apos;style!css&apos; }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)}, { test: /\\.less$/, loader: &apos;style!css!less&apos;, exclude: /node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader!less-loader&apos;)}, { test: /\\.(png|jpg)$/, loader: &apos;url?limit=8192&amp;name=img/[name].[ext]&apos; }, { test: /\\.js$/, loaders: [&apos;babel?presets[]=es2015&apos;], exclude: /node_modules/ } ] }, plugins: [ new DashboardPlugin(dashboard.setData) ] };package.json... &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack-dev-server --quiet --content-base src/&quot;, }... Draft for Now赏","link":"/2016/09/23/webpack-plugin-webpack-dashboard/"},{"title":"微信内置浏览器兼容性问题汇总","text":"本文列举了个人在微信公众号里开发时所遇到的浏览器兼容性问题。不定期更新。 1.ios内置微信浏览器不支持active伪类。 解决办法：添加触摸事件： 1document.body.addEventListener(&apos;touchstart&apos;,function(){}) 2.百度地图api在微信内不生效，应当是微信做了屏蔽工作 3.ios端微信浏览器会给input框加上自带的样式，例如圆角和内阴影。是因为-webkit-appearance这个属性的影响 appearance CSS规范*解决办法：给input添加以下样式 12345input { appearance: none; -webkit-appearance: none; /* safari */ -moz-appearance: none;} 4.ios端微信浏览器，包括ios上所有使用Safari内核的浏览器，都会有该问题—— 直接在window, document, body下绑定click事件，点击body不会触发 几个解决办法 使用touch事件，但在弹出层上会有点透问题 避免bug触发：不要委托事件在body结点上。可以指定任何除了上述元素外的父元素，给该元素下的元素绑定事件。 已触发情况：safari对事件的解析比较特殊，事件有响应过，则会一直冒泡（捕获）到根节点，对于大规模触发的情况，只要在body元素的所有子元素绑定一个空事件，如： 1$(&apos;body &gt; *&apos;).on(&apos;click&apos;, function() {}); 5.ios系统下的浏览器，会自动识别疑似电话号码的数字，将其添加自动拨号功能： 18878898922会被自动修改为&lt;a href=&quot;tel:18878898922&quot;&gt;&lt;/a&gt;,就有了自动拨号功能。 但有时是不需要这个鸡肋功能的，解决办法是在页面顶部添加一行&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;禁用该功能。 format-detection决定启用或禁用该功能 6.微信分享的缩略图 微信中分享网页时会有缩略图，该缩略图默认是网页中的第一张图片，无论显不显示 但是图片大小小于400px * 400px 时，或者直接将图片隐藏会导致无法显示 所以较好的解决方案是在标签 img 外面加父元素 div ,给 div 设置: 1&lt;div style=&quot;margin: 0 auto;width: 0;height: 0; overflow: hidden&quot;&gt;&lt;/div&gt; 而图片无需处理，最终可写成如下: 123&lt;div style=&quot;margin: 0 aut0; width: 0; height: 0; overflow: hidden;&quot;&gt; &lt;img src=&quot;./images/pic.png&quot;/&gt;&lt;/div&gt;","link":"/2016/11/01/wechat-compatible-problems/"},{"title":"Jasin Yip 计蒜客前端知乎 Live 笔记","text":"一次知乎 Live 听讲的笔记记录。 1. 如何成为高效率的工程师 减少重复工作：学会使用git alias，熟练使用命令行；熟练工具，武装自己。 时间管理：日程表安排——倒三角安排工作，周一满，周二缺一小时，周三减2个小时。 2. 有效的沟通方式 减少面对面交流，使用工具，邮件等。 一次说明一件事，完整的一件事。 3. 正确的提问方式 反面教材： 不直接了当——最好一次说清来意，表名问题。 方向问题，问前程——信息量少，难以说清。 减少他人理解问题的成本, 业务代码写成demo.例如去 jsbin、jsfiddle 等网站写 demo. 付费提问。 4. 计算机基础和方法论 计算机基础: 算法，操作系统，计算机网络，内存的使用…(内存泄漏)。 算法(解决问题的思路): 递归问题——文件树。 方法论：设计模式，编程范式。 设计模式：单例模式。 编程范式：OOP面向对象编程，面向过程，函数式编程。 函数式编程：pure function(思维转变), 可维护， 可扩展，可测试，闭包提高了函数的内聚性,不依赖外部条件，更容进行单元测试。 《大话设计模式》(C#)。 5. 前端的多样化的技术 学框架是理解一种思想，理解解决问题的思路: react 的组件化思想, angular的双向数据绑定。 6. 如何写优雅的代码 命名规范，制定团队规范， 参考大厂的规范，向大厂学习。 7. 公司代码不完美 部分代码与业务相关。 查看是否有发挥空间，是否可以改进，以自己的能力去推动改进，和上级沟通表达，锻炼表达能力，提高技术能力。 8. 代码质量差 引入一些检查lint: pre-commit、aslant? 、csslint、facebook-flow typescript. 任何的代码都可以 code review. 9. 提升个人影响力 影响力就是话语权(权利)（职位职级）, 决定框架，决定选型。 影响力来自能力，时刻准备着，当机会出现时把握住。推销自己的机会，让大厂关注自己的机会。 《程序员的自我营销》。 10. 前端工程师接触的其他领域 计算机基础原理是必要的。 增加技术的广度。 学习编程语言传达的思想。 11. 框架技术选型 考虑学习成本。 对各种框架的优缺点有所了解。 12. 初学者的建议 注重基础知识。 成长：一年之内多写业务，累积经验。 刷题：算法题之类，基础题。 《JavaScript设计模式与开发实践》。 13. 提升英语 可以参与掘金翻译计划。 多看英语类的技术文章，强迫自己去接触英语，感受英语的氛围。","link":"/2017/02/05/zhihulive-Jasin-Yip/"},{"title":"webpack小试牛刀","text":"近段时间公司要做一个h5的小项目。一开始我不知道从哪儿下手。在一位前辈的指导下，我用了webpack来打包整理项目。 经过不断的入坑尝试之后终于搭建起了一个小项目，虽然还有部分小坑，不过至少跑起来还可以，这里做一个简单总结。 webpack是近期比较火的一款模块加载器兼打包工具，能把各种资源，包括图片，js，样式等都作为模块来处理。官网点这里 优势： 资源管理功能强大 以commonJS的形式来书写脚本，也兼容AMD/CMD 模块化思想。可生成公共模块或者按需加载 能替代部分gulp/grunt的工作 支持开发过程中实时打包 插件机制完善，扩展性强 安装： npm install webpack -g 或者一般把依赖写入package.json 依次运行npm init npm install webpack --save-dev 目录结构 1234567891011121314151617buildnode_modulessrc-page -home -home.html -home.less -index.js -img-img-common-index.js-index.html-all.lesspackage.jsonwebpack.config.jsreadme.md src下是开发文件，用于开发环境 page下的是各个模块，每个模块内有自己的js、img、html、less img存放公用的图片 common存放公用的js build下是src的文件编译好的文件，用于生产环境 项目设计思路 这是个比较简单的项目，没有使用像angularjs，react这样的框架，只用了jQuery，最初的构想就是简单，上手快 基于现在流行的模块化思想，将所有模块放在src下的page里，每个文件夹即一个模块，也就是一个页面 一个common存放公用的方法和配置文件等 index.html是入口页面，all.less是共用的样式，每个页面(模块里)都自己独立的css样式，只是先在每个样式文件里先引入all.less 配置： 通常项目下会配置一个webpack.config.js的文件，作用类似gulp中的gulpfile.js ，这是默认配置文件，当然也可以修改，这是我的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var webpack = require(&apos;webpack&apos;);var fs = require(&apos;fs&apos;);var fse = require(&apos;fs-extra&apos;); //引入nodejs相关fse.copySync(&apos;./src&apos;, &apos;./build&apos;);var dirnames = {};var dirs = fs.readdirSync(&apos;./src/page&apos;);// 判断是否是生产环境，不是的话则是开发环境，判断缘由是调试时的入口和要上线时是不一样的var isProduction = function() { return process.env.NODE_ENV === &apos;production&apos; || process.env.NODE_ENV === &apos;development&apos;;};// 监听所有js文件变化dirs.forEach(function(ele, index){ var dir = &apos;./src/page/&apos; + ele; var status = fs.statSync(dir); dirnames[&apos;page/index&apos;] = [&apos;./src/page/index.js&apos;]; if (status.isDirectory()){ dirnames[&apos;page/&apos; + ele + &apos;/index&apos;] = []; dirnames[&apos;page/&apos; + ele + &apos;/index&apos;].push(dir + &apos;/index.js&apos;); } return dirnames;});// 修复低版本node编译时报错的问题var Promise = require(&apos;es6-promise&apos;).Promise;require(&apos;es6-promise&apos;).polyfill();// 将内部样式改为外部样式的插件，暂时不用// var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);var path = require(&apos;path&apos;)module.exports = { entry: dirnames, output:{ path: path.resolve(__dirname + &apos;/build&apos;), filename: &apos;[name].js&apos; }, module: { loaders: [ { test: /\\.css$/, loader: &apos;style!css&apos;, exclude:/node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)}, { test: /\\.less$/, loader: &apos;style!css!less&apos;, exclude:/node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader!less-loader&apos;)}, { test: /\\.(png|jpg)$/, loader: &apos;url?limit=8192&apos;, exclude:/node_modules/ }, { test: /\\.js$/, loader: &apos;babel&apos;, exclude:/node_modules/ }, { test: /\\.json$/, loader: &apos;json-loader&apos;, exclude:/node_modules/ } ] }, resolve: { // 自动扩展文件后缀名，在文件中可以直接require模块而不写后缀名 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;], // 模块别名定义，方便直接引入文件 alias: { // page: &apos;src/page&apos;, page: path.resolve(__dirname, &apos;src/page&apos;), feed: path.resolve(__dirname, &apos;src/common/feed&apos;), config: path.resolve(_dirname, &apos;src/common/config&apos;) } }, plugins: [ new webpack.DefinePlugin({ &apos;process.env&apos; : { &apos;NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV || &apos;dev&apos;) } }), new webpack.optimize.CommonsChunkPlugin(&apos;vendors.js) ], externals: { &apos;jquery&apos;: &apos;jQuery&apos; // 将jQuery赋值为jquery }}; 这个项目最初的考虑是利用模块化思想，将每个页面都分割成一个个模块，然后每个模块有着自己独立的js和img还有样式文件 entry：入口可以是一个或多个资源合并而成。接受数组和对象，这里以对象的形式放入。然后这里因为加入了实时刷新的webpack-dev-server插件，所以加了生产环境还是线上环境的判断.webpack-dev-server下文详细述说 chunk:被entry所依赖的额外的代码块，也可以包含一个或多个文件 webpack的入口文件是多个的。这里引用了nodejs的方法，利用nodejs可以操控文件的优势，先复制不需要编译的文件，节约编译时间。然后找出所有index.js来编译并存放在各自的文件夹下。这里要说明是一开始的思路可能没有考虑全面，用复制文件的方式来写会导致html无法随编译刷新，用html-webpack-plugin也无济于事，日后再解决 ——已解决，看最下。 123456789101112131415161718192021var dirnames = {};var dirs = fs.readdirSync(&apos;./src/page&apos;);// 监听所有js文件变化dirs.forEach(function(ele, index){ var dir = &apos;./src/page/&apos; + ele; var status = fs.statSync(dir); dirnames[&apos;page/index&apos;] = [&apos;./src/page/index.js&apos;]; if (status.isDirectory()){ dirnames[&apos;page/&apos; + ele + &apos;/index&apos;] = []; dirnames[&apos;page/&apos; + ele + &apos;/index&apos;].push(dir + &apos;/index.js&apos;); } return dirnames;});// 修复低版本node编译时报错的问题var Promise = require(&apos;es6-promise&apos;).Promise;require(&apos;es6-promise&apos;).polyfill();var path = require(&apos;path&apos;)module.exports = { entry: dirnames, ......} output: 指输出到哪个目录下，我的项目里就是每个模块对应有着自己的index.js文件，path指的是生成文件的存放目录，filename文件赋值[name].js，会生成相应的文件名，最终存放在build/下 1234output:{ path: path.resolve(__dirname + &apos;/build&apos;), filename: &apos;[name].js&apos;} loaders: 这是webpack比较重要的一部分，模块加载器，因为是小项目，在这里我使用的插件并不多，css文件用style-loader和css-loader来处理，less用less-loader来处理，图片用url-loader来处理，目前还支持es6，有babel-loader支持。其中-loader可以省略 所有加载器还是通过npm来下载。例如url-loader，通过npm install url-loader --save-dev下载，它会根据需要将样式中引用的图片转化为base64编码 再如less-loader,它会从右向左寻找文件并进行编译，最终将生成的css放在页面的style里 其中exclude参数表示需要排除的查找目录,include是包含的查找目录，让webpack只编译包含的目录或排除掉部分目录，可以大大加快它的编译速度 123456789module: { loaders: [ { test: /\\.css$/, loader: &apos;style!css&apos;, exclude:/node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)}, { test: /\\.less$/, loader: &apos;style!css!less&apos;, exclude:/node_modules/ }, // ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader!less-loader&apos;)}, { test: /\\.(png|jpg)$/, loader: &apos;url?limit=8192&apos;, exclude:/node_modules/ }, { test: /\\.js$/, loader: &apos;babel&apos;, exclude:/node_modules/ }, { test: /\\.json$/, loader: &apos;json-loader&apos;, exclude:/node_modules/ } ] } resolve则看注释即可 definePlugin插件，用于判断是生产环境还是线上环境，在部署时或者切换环境时非常有用 12345new webpack.DefinePlugin({ &apos;process.env&apos; : { &apos;NODE_ENV&apos;: JSON.stringify(process.env.NODE_ENV || &apos;dev&apos;) }}) providePlugin: 通常情况下我们都需要先require相关资源，并赋值给变量才可以使用，比如要在js顶部引入var $ = require(&apos;jquery&apos;)才可以使用$,而在每个页面都这样操作很繁琐。于是可以利用该插件一次定义，处处使用。无须再在页面顶部引入。 123456new webpack.ProvidePlugin({ $: &apos;jquery&apos;, jQuery: &apos;jquery&apos;, &apos;window.jQuery&apos;: &apos;jquery&apos;, &apos;_&apos;: &apos;lodash&apos;}) alias:别名(请求重定向)。定义别名可以方便文件快速查找并加快编译速度。文件查找的时间大大缩减。之前我是这么写的 123456var feed = require(&apos;../../common/feed/index&apos;); // 一个存放公用方法的文件,每个页面都写长长的这么一句然而现在是这样var feed = require(&apos;feed/index&apos;);或者它会去找该文件夹下面的index.js，所以可以更简单var feed = require(&apos;feed&apos;);不只是书写方便了，而且webpack的编译也更快了 commonsChunk:将公共模块提取出来,利用浏览器缓存机制提高页面加载效率。避免每个文件都引用一次，影响加载速度 1new webpack.optimize.CommonsChunkPlugin(&apos;vendors.js) uglifyjs:将生产环境中的js代码进行压缩和混淆,缩小文件加快请求速度 1webpack.optimize.UglifyJsPlugin({minimize: true}) externals:为避免第三方库或框架被合成或打包成公共模块浪费资源。可以采用cdn引入的方式。这就需要进行一些设置 首先在页面的html里引入cdn上的文件 1&lt;script src=&quot;https://code.jquery.com/jquery-1.11.1.min.js&quot; integrity=&quot;sha256-VAvG3sHdS5LqTT+5A/aeq/bZGa/Uj04xKxY8KM/w9EE=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 然后在webpack.config.js里设置 123externals: { &apos;jquery&apos;: &apos;jQuery&apos; // 将jQuery赋值为jquery} 运行 webpack 可以直接运行webpack执行一次性编译，建议运行时加上以下参数 --display-error-details 方便查看出错时的报错信息 --progess --color 输出呈彩色，进度条显示编译进度 -p 生产环境压缩代码 HTML页面引入 直接在html里加入 &lt;script type=&apos;text/javascript&apos; src=&apos;index.js&apos;&gt;即可 index.js HTML中不引入样式，是因为在这里就引入了。在页面顶部加上require(&apos;../[name].less&apos;) [name]指代当前less的文件名，我的做法是在每个less里引入一个公用的all.less,然后不同页面的js里引入各自的less，webpack会自动编译less并放在页面的style里 其实还尝试过使用ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css-loader&apos;)} 插件，将页面顶部的样式改为外部文件引入，但因为开始时设计的偏差，改动起来比较麻烦，最后作罢 这是个小项目，只引入了jquery和自己的公用的一个库 reqiure(&apos;feed&apos;) 通过process.env.NODE_ENV的值判断开发环境的接口，是引用测试的接口还是线上的接口，它的值不同时会引用不同的js文件 所以最终每个index.js的顶部会有这么几行 12345require(&apos;./style.less&apos;);var feed = require(&apos;feed&apos;);var url = require(&apos;config/env/&apos; + process.env.NODE_ENV);// 执行该页面的逻辑代码...... 如何自动刷新 使用webpack-dev-server webpack-dev-server是一个静态轻量的express资源服务器，只用于开发环境 它的作用就是把编译后的静态文件全部保存在内存里，而不会写到文件目录内 安装:npm install webpack-dev-server --save-dev 这里采用了双服务器模式，一个后端服务器和一个资源服务器 运行 NODE_ENV=local webpack-dev-server --inline --hot --devtool --content-base build/ 得到的entry应当是这样的 12345678entry: { &apos;page/index&apos;: [ &apos;webpack-dev-server/client?http://localhost:8080&apos;, &apos;webpack/hot/dev-server&apos;, &apos;./src/page/index.js&apos; ] } NODE_ENV 作为环境变量，决定启用使用测试接口或是线上接口 –hot 选项的工作其实就是把webpack/hot/dev-server加到了entry中，如果成功了，运行命令后的控制台里会有以下信息 12[HMR] Waiting for update signal from WDS...[WDS] Hot Module Replacement enabled. 采用 –inline 模式，它的工作其实就是把webpack-dev-server/client?http://localhost:8080加到entry中 –content-base 把build/下的内容作为静态资源服务 –devtool eval 配置devtool的值为eval，用于查看编译后的源代码，eval 不支持生产环境查看源代码，但编译速度快，另一个常用的值是source-map，支持生产环境，但相对慢 打开 localhost:8080/webpack-dev-server/page/index.html查看 package.json 配置1234script: { &quot;dev&quot;: &quot;rm -rf build &amp;&amp; NODE_ENV=local webpack-dev-server --inline --hot --devtool eval --progress --colors --content-base build/&quot;, &quot;web&quot;: &quot;NODE_ENV=development webpack --progress --colors --display-error-details&quot;,} 运行npm run dev 开发环境下 npm run web 测试环境下 目前遗留问题 hot热加载未生效 html文件更改无法刷新同步到页面 该问题已解决。出现问题的原因是加载在页面上的是编译好的build下面的文件，但html支持的监听刷新是开发文件，所以只要更改运行脚本即可——将build改为src，如下： &quot;dev&quot;: &quot;rm -rf build &amp;&amp; NODE_ENV=local webpack-dev-server --inline --hot --devtool eval --progress --colors --content-base src/&quot; 多页面项目没有很好的方案去构建自动化 小结 这是自己的第一个独立项目，绝大部分工作都是自己完成的，前辈指导了一部分，后来就全部自己做了。当然还是并不太成熟，遗留几个问题目前找不到解决办法。webpack给我的体会是编译速度非常快，或许也和现在项目中的依赖比较少有关。不管怎样，这个项目目前还会维护下去，会不定期更新，解决遗留问题。","link":"/2016/07/03/webpack-trytry/"},{"title":"小爝前端自我提升知乎 Live 笔记","text":"记录一次知乎 Live 的笔记，加上部分自己的理解。 1. 初级前端起步 制定小目标。 通过目标制定计划。 寻找实现目标所需的资源。 和比自己水平高一两个level的人交流，直接和大牛交流也许会有障碍，水平相差较多，水平高的人习以为常的东西，新手也许并不难理解，造成沟通低效。 写技术日记(技术博客)。 鼓励意识、荣誉感——去社区里回答问题。 2. 在成熟公司中成长 成熟公司：内部有大牛，体系完善，体量大，多人开发，协同管理机制完整。 始终关注新技术的内容。 在阿里：勤奋——花时间去阅读，写代码。下班之余，晚9点至12点，早起4点至8点。 如何高效阅读英文文档：上手指南 =&gt; API大类 =&gt; 插件整体概览 =&gt; 了解框架的功能——解决的问题和不能解决的问题 =&gt; 定位相应的插件，查看具体插件的示例代码。 不能让自己太舒服，克服惰性；习惯开发节奏；了解公司框架结构；熟悉公司业务。 公司内高级前端的要求：熟悉工程化，组件化，模块化开发；有创新，创新的内容可以影响业务线；可以为公司业务带来收益；可以提供讲座；有一定的带人经验，是合格甚至优秀的导师。 在新浪： 待过多个部门，在新浪博客，手机新浪网等部门，有实现自己的打包工具供内部使用。 找到公司痛点，解决痛点，带领大家来解决痛点，是提升自己的一种好的方式。 对待问题和知识点刨根揪底、精益求精的态度。 3. 团队与个人，谁在起进步作用 相辅相成。 成为技术 leader，有担当，主动接手复杂的项目，解决疑难杂症，解决其他人解决不了的问题。 团队不代表个人，当自己离开团队的时候同样有自己的能力。 有自己的方向，技术栈，不断进步。 4. 没有参与过0-1的前端项目怎么办 不断创新，开发新的插件，新的系统，新的工具。 有自己的个人项目。 参加黑客马拉松。 有一定产品思维。 5. 前端人员对后端需要掌握到什么程度 了解：可以使用后端语言做动态网站，完成基本的增删改查、数据库的安装、服务器的配置。 进阶：使用 nodejs 等开发静态服务器；可以开发 web 应用，开发 web 框架开发；解决并发问题；了解服务器；了解 shell. MVC MVP MVVM 6. 前端技术如何做到精益求精 找到学习的平衡点，避免过度设计。在已有的水平上一步一步、脚踏实地发展。 提高自己的眼界，去看经典，学习经典，感受好的代码，营造一个好的代码氛围。 每天解决一个小问题，当天解决。积少成多，慢慢积累。 7. 未来的前端工程师应该如何发展，怎么看待不断更新的框架和各种技术概念 关注本质。新技术是否是能解决当前公司的痛点，解决某个场景的问题。大而全、可以解决所有问题的框架一般活不久。 发展趋势是客户端化。很多思想(MVVM)是客户端引入到前端中的。 移动端迭代非常快。保持和移动端设备规范的一致性。 未来的几种可能：浏览器内置组件，解析编译的代码。浏览器不更新，热更新。增量更新。 关注 web 条件，硬件变化。 混合式开发：React-Native.适当学习客户端，后端。 Q&amp;A高效自学 js 看书：《JavaScript 语言精粹》《DOM 编程艺术》。 查看网站的部分功能，思考如何实现同样的功能。 如果可以实现，在脑海里理清思路过一遍。不能实现，则找出实现的方法，熟悉并理解。 清理客户端缓存方法 在 js 等文件后加时间戳。 更改 js 文件名字。 如何快速上手大型项目 找到大型项目的文件入口。 找到每个页面对应的 js。 package.json. readme.md. test(单元测试，测试用例). src(开发目录). dist(编译目录). 制定小目标 学会使用一些抓包工具, 例如 fiddler(windows), charles(mac). 如何实现自己不会的动效 查看别人的源码，找到引用的开源插件。 学习使用该开源插件，或是学习源码。","link":"/2017/02/05/zhihulive-xiaojue/"},{"title":"前端 vczero 三年从前端小工到架构分享","text":"知乎 live：三年从前端小工到架构分享的笔记及感悟 0-3 年工程师发展，快速成长概览 技能：js，css——追求新技术。 能力：编程能力，实现一个功能的能力，抽象能力。 技能—&gt;思考—&gt;能力。 提高认知，提升格局，拓展眼界。 避免狭隘认知。理解片面——在没有深入了解一个框架时就妄加评判。 在巩固基础的同时拓展眼界。 财富积累：资源调度和资本运作（例如买房）。 内容 起步阶段： 踏实看完基础书籍。 深入理解基础语法。(练习，不依靠文档独立完成) 心情浮躁时完成 demo 来提升成就感。 记录，思考。建立一套良好的笔记系统。 注重方法论，长时间无法实现一个任务或功能时注意学会变通。 书籍推荐：《DOM 编程艺术》《JS高级程序设计》《CSS权威指南》 注重原生语法，底层知识。 了解服务端的开发模式。横向拓展知识。 学习算法与数据结构。 学习打包工具的底层原理。 快速成长： 找一个导师，向导师学习工作方式，思考方式，思维方式。 培养职业素养。邮件发送，抄送格式。建立一个工作群组，要分清楚需要邀请哪些人。跨部门协作时能要提高协调资源的能力。 技术发散和聚合。跨界、横向、广度。扩展技术边界，横向发现。 安排的工作专注完成，至少完成百分之百。如果在技术上难以突破，在其他方面加强，例如文档完善，邮件发送。 感恩。圈子很小。建立良好的人际关系。 个人的成长与团队的成长是密不可分的。个人的价值在团队中才能充分发挥体现。能力越大，责任越大，承担的事越多。 技术管理和前端架构 前端架构：技术选型到运维，整个技术体系。负责整个项目的可扩展性，可维护性。 技术 or 管理： 三五年后的发展，选择技术方向的在国内有一定瓶颈。小型公司内难做，没有这一职位。 选择管理方向的不能脱离代码。建立较好的人际关系，具有一定的产品思维。 提升技术影响力 公司内影响力。 社区内影响力。 提问时要有诚意，问完整的问题，提供完善的开发环境。问问题时带上自己的思考，引起大牛的注意。 个体的差异化，给自己贴上一些标签，给人留下印象。 在 github 上管理的代码是完善的，不是纯测试用的。有产品思维，当做产品来管理。每个项目都是完善的产品。 加入圈子的时候表现自己的诚意，放出自己的深层思考。 将碎片化的知识整理成系统化的知识。 个人总结 个人而言，觉得这次 live 并不太适合自己。虽然自己处在 0-3 年这个区间内，但提到的不太适用或者是属于已知的。 这次的 live 相对比较空，难以具象化。个人感觉大部分说的是要做什么，不要做什么，而不是要具体做什么，具体不做什么。或许自己听的也不够清楚，总之不适用自己。 Q&amp;A 环节的体验，和前两次 live 的差不多，对个体而言干货较少。那些问题其实问其他人也会有相似的回答，只是处在迷茫阶段的提问者难以看清。这里对自己而言有价值的部分不多，有部分自己确实已经意识到了，而在实践上可以更下一些功夫。 其实每次听 live，技术上的收获是不多的。较多的是扩展一些眼界，开拓思路的地方。看看在技术上有一定成就的人是怎么做分享，怎么在技术这条路上越走越好的，他们的成功经历是否可以给自己一些启示。虽然这次分享的标题写着三年的发展，但其实在这三年的第 0 年，也就是作者毕业的那年，基础已经超过绝大多数人了，这是在毕业前就已经准备了的。所以三年后能做到架构师这一步，不是这三年的积累成果，而是五年甚至更多年积累的成果。分享者提到，在大学阶段，每周有固定的时间用于写代码和思考。只这一点，已经拉开了差距。现在当我处在工作一年多、毕业近两年的阶段，其实落后了很多。但重要的是，时刻提醒自己这一点，然后让这点鞭挞自己不断前进。 于我而言，另一个听 live 的好处是提高自己对技术的积极性。近段时间因为适应新工作，对技术方面的热情有所下降。通过 live 和大牛近距离接触，可以唤起自己的积极性。尽管因为听讲被分成了片段式效果没有那么好，但至少记录下了部分内容，在这里做一个简单的总结和回顾。整理依旧比较碎片化，成了分享里的反例，部分内容加上了些自己的想法和理解。但整体我觉得没有再更进一步整理的必要，如果后续再想到，再对上面的一些内容加些其他的感悟和思考。 不管怎样，感谢这些在技术上有一定地位的人拿出他们的时间来做分享。也许这些分析并不对每个人都适用，但总有一部分是能给予初入前端的人一些帮助的。谢谢他们。","link":"/2017/04/01/zhihulive-vczero/"}],"tags":[{"name":"ES2015","slug":"ES2015","link":"/tags/ES2015/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"wepay","slug":"wepay","link":"/tags/wepay/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"WebGl","slug":"WebGl","link":"/tags/WebGl/"},{"name":"Parcel","slug":"Parcel","link":"/tags/Parcel/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"Unit-Testing","slug":"Unit-Testing","link":"/tags/Unit-Testing/"},{"name":"sublime","slug":"sublime","link":"/tags/sublime/"},{"name":"Notes","slug":"Notes","link":"/tags/Notes/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"interview","slug":"interview","link":"/tags/interview/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"compatibility","slug":"compatibility","link":"/tags/compatibility/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"WebGL","slug":"WebGL","link":"/tags/WebGL/"},{"name":"translate","slug":"translate","link":"/tags/translate/"},{"name":"React-Router","slug":"React-Router","link":"/tags/React-Router/"},{"name":"兼容性","slug":"兼容性","link":"/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"zhihu live","slug":"zhihu-live","link":"/tags/zhihu-live/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"Library","slug":"Library","link":"/categories/Library/"},{"name":"Browser","slug":"Browser","link":"/categories/Browser/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Wechat","slug":"Wechat","link":"/categories/Wechat/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"threejs","slug":"threejs","link":"/categories/threejs/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Shell","slug":"Shell","link":"/categories/Shell/"},{"name":"Unit-Testing","slug":"Unit-Testing","link":"/categories/Unit-Testing/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Interview","slug":"Interview","link":"/categories/Interview/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"DOM","slug":"DOM","link":"/categories/DOM/"},{"name":"macos","slug":"macos","link":"/categories/macos/"},{"name":"Zhihu Live","slug":"Zhihu-Live","link":"/categories/Zhihu-Live/"}]}