{"pages":[{"title":"","text":"// TODO 点击展示 var starwar = document.querySelector('#starwar') var block = document.body.querySelector('#regular') var $starwar = $(starwar) var $block = $(block) var scene = new THREE.Scene() var earthRect = starwar.getBoundingClientRect() var renderer = new THREE.WebGLRenderer() var camera = new THREE.PerspectiveCamera(75, earthRect.width / earthRect.height, 1, 500) renderer.setSize(earthRect.width, earthRect.height) /** * [initEarth earth part] * @return {Object} [description] */ var initEarth = function() { // var earthPic = 'https://kyriejoshua.github.io/jo.github.io/about/satelite.jpg' var earthPic = './satelite.jpg' var textureEarth = new THREE.TextureLoader().load(earthPic || '') var sphereGeometry = new THREE.SphereGeometry(5, 32, 32) var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xfafaf6, map: textureEarth }) var earth = window.earth = new THREE.Mesh(sphereGeometry, sphereMaterial) earth.position.set(0, -1, -3.2) scene.add(earth) return window } /** * [initStars stars] * @return {Object} [description] */ var initStars = function() { var starPic = './star.png' var textureStar = new THREE.TextureLoader().load(starPic) var starsGeometry = new THREE.Geometry() for (var i = 0; i < 200; i++) { var star = new THREE.Vector3() star.x = THREE.Math.randFloatSpread(50) star.y = THREE.Math.randFloatSpread(50) star.z = THREE.Math.randFloatSpread(50) starsGeometry.vertices.push(star) } var starsMaterial = new THREE.PointsMaterial({ color: 0xcfee90, map: textureStar, size: 1, transparent: true, opacity: 1, blending: THREE.AdditiveBlending, depthTest: false }) var starField = new THREE.Points(starsGeometry, starsMaterial) scene.add(starField) return window } /** * [initLight light part] * @return {Object} [description] */ var initLight = function() { var light = new THREE.PointLight(0xfafaf6, 1.5, 100) light.position.set(-2, 3, 10) scene.add(light) return window } initEarth().initStars().initLight() // text part var textMaterial = new THREE.MeshBasicMaterial({ color: 0xF5C236 }) // var textMaterial = new THREE.MeshLambertMaterial({ color: 0xF5C236 }) var fontLoader = new THREE.FontLoader() var textGroup = new THREE.Group() var tipsGroup = new THREE.Group() var texts = ['Mac deep user', 'ES6 && Typescript', 'React && Redux', 'Git && Github', 'Nodejs', 'Webpack && Gulp', 'WebGL'] var tips = ['show me more!'] texts = texts.reverse() tips = tips.reverse() var textsMesh = {} var tipsMesh = {} // 放在本地有毒，解析会出现问题 // fontLoader.load('./helvetiker_regular.typeface.json', function(font) { // fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) { fontLoader.load('https://raw.githubusercontent.com/kyriejoshua/jo.github.io/gh-raw/source/about/helvetiker_regular.typeface.json', function(font) { var textParams = { font: font, size: 0.5, height: 0.02, curveSegments: 12, bevelEnabled: false, bevelThickness: 10, bevelSize: 8, bevelSegments: 5 } texts.map(function(text, index) { var textGeometry = new THREE.TextGeometry(text, textParams) textsMesh[index] = new THREE.Mesh(textGeometry, textMaterial) textsMesh[index].name = text textsMesh[index].position.set(-2.5, -10.5 + index * (0.5 + 0.25), 3.2) textGroup.add(textsMesh[index]) }) var tipsParams = Object.assign({}, textParams, { size: 0.32, height: 0, bevelThickness: 1, bevelSize: 0.8 }) var tipMaterial = new THREE.MeshBasicMaterial({ color: 0xF5C236 }) tips.map(function(tip, index) { var textGeometry = new THREE.TextGeometry(tip, tipsParams) tipsMesh[index] = new THREE.Mesh(textGeometry, tipMaterial) tipsMesh[index].name = tip tipsMesh[index].position.set(8.4, -7.2 + index * (0.12 + 0.32), 0) tipsGroup.add(tipsMesh[index]) }) tipsGroup.visible = false tipsGroup.name = 'tips' }) textGroup.rotation.x -= Math.PI * 0.24 scene.add(textGroup) scene.add(tipsGroup) // TODO: 因为鼠标事件点击文字获取不到对象，暂时采用该方式来解决。 // var cubeGeometry = new THREE.BoxGeometry(1, 1, 1) // var cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff9d }) // var cube = new THREE.Mesh(cubeGeometry, cubeMaterial) // cube.position.set(10, -7.2, -1) // cube.name = 'tips' // scene.add(cube) starwar.appendChild(renderer.domElement) camera.position.set(0, 0, 10) camera.lookAt(scene.position) // threejs events var raycaster = new THREE.Raycaster() var mouse = new THREE.Vector2() var onMouseDown = function (event) { event.stopPropagation() event.preventDefault() mouse.x = (event.clientX - $starwar.offset().left - $starwar.width() / 2) / ($starwar.width() / 2) mouse.y = (event.clientY - $starwar.offset().top - $starwar.height() / 2) / ($starwar.height() / 2) raycaster.setFromCamera(mouse, camera) $block.slideDown() var intersects = raycaster.intersectObjects(scene.children, true) if (intersects.length > 0) { if (intersects[0].object instanceof THREE.Mesh && intersects[0].object.name === 'tips') { // block.style.display = 'block' $block.slideDown() } } } starwar.addEventListener('mousedown', onMouseDown) var threeAnimation = function() { window.requestAnimationFrame(threeAnimation) renderer.render(scene, camera) earth.rotation.y += 0.003 earth.rotation.z += 0.0001 var pos = textGroup.position if (pos.y > 0.56 && !tipsGroup.visible) { tipsGroup.visible = true } textGroup.position.set(pos.x, pos.y + 0.003, pos.z - 0.002) } threeAnimation() // events block.addEventListener('click', function() { starwar.style.display = 'block' })","link":"/jo.github.io/about/index.js"},{"title":"Categories","text":"","link":"/jo.github.io/categories/index.html"},{"title":"","text":"About Me 平淡无奇的前端攻城狮。 偏爱美好的设计，注重用户体验。 遵循简洁的代码规范，拥有良好的代码习惯。 #Mac 重度用户 #ES6 &amp;&amp; Typescript &amp;&amp; Coffeescript #React &amp;&amp; Redux #Git &amp;&amp; Github #Nodejs 入坑中 #Webpack &amp;&amp; Gulp &amp;&amp; Parcel #WebGL 会一点点点 #Scss #Less #Jade 更多的在这里 0. 对一切事物充满好奇心。 1. 凡事怎么能不折腾。 2. Geeeeek 一点，再 Geeeeek 一点。 3. 能用键盘搞定的事，绝不动鼠标。 欢迎交流 – kj2046@outlook.com github: https://github.com/kyriejoshua","link":"/jo.github.io/about/index.html"},{"title":"","text":"{\"glyphs\":{\"0\":{\"x_min\":73,\"x_max\":715,\"ha\":792,\"o\":\"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 \"},\"1\":{\"x_min\":215.671875,\"x_max\":574,\"ha\":792,\"o\":\"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 \"},\"2\":{\"x_min\":59,\"x_max\":731,\"ha\":792,\"o\":\"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 \"},\"3\":{\"x_min\":54,\"x_max\":737,\"ha\":792,\"o\":\"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 \"},\"4\":{\"x_min\":48,\"x_max\":742.453125,\"ha\":792,\"o\":\"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 \"},\"5\":{\"x_min\":54.171875,\"x_max\":738,\"ha\":792,\"o\":\"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 \"},\"6\":{\"x_min\":53,\"x_max\":739,\"ha\":792,\"o\":\"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 \"},\"7\":{\"x_min\":58.71875,\"x_max\":730.953125,\"ha\":792,\"o\":\"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 \"},\"8\":{\"x_min\":55,\"x_max\":736,\"ha\":792,\"o\":\"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 \"},\"9\":{\"x_min\":53,\"x_max\":739,\"ha\":792,\"o\":\"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 \"},\"ο\":{\"x_min\":0,\"x_max\":712,\"ha\":815,\"o\":\"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 \"},\"S\":{\"x_min\":0,\"x_max\":788,\"ha\":890,\"o\":\"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 \"},\"¦\":{\"x_min\":343,\"x_max\":449,\"ha\":792,\"o\":\"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 \"},\"/\":{\"x_min\":183.25,\"x_max\":608.328125,\"ha\":792,\"o\":\"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 \"},\"Τ\":{\"x_min\":-0.4375,\"x_max\":777.453125,\"ha\":839,\"o\":\"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 \"},\"y\":{\"x_min\":0,\"x_max\":684.78125,\"ha\":771,\"o\":\"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 \"},\"Π\":{\"x_min\":0,\"x_max\":803,\"ha\":917,\"o\":\"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 \"},\"ΐ\":{\"x_min\":-111,\"x_max\":339,\"ha\":361,\"o\":\"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 \"},\"g\":{\"x_min\":0,\"x_max\":686,\"ha\":838,\"o\":\"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 \"},\"²\":{\"x_min\":0,\"x_max\":442,\"ha\":539,\"o\":\"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 \"},\"–\":{\"x_min\":0,\"x_max\":705.5625,\"ha\":803,\"o\":\"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 \"},\"Κ\":{\"x_min\":0,\"x_max\":819.5625,\"ha\":893,\"o\":\"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 \"},\"ƒ\":{\"x_min\":-46.265625,\"x_max\":392,\"ha\":513,\"o\":\"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 \"},\"e\":{\"x_min\":0,\"x_max\":714,\"ha\":813,\"o\":\"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 \"},\"ό\":{\"x_min\":0,\"x_max\":712,\"ha\":815,\"o\":\"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 \"},\"J\":{\"x_min\":0,\"x_max\":588,\"ha\":699,\"o\":\"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 \"},\"»\":{\"x_min\":-1,\"x_max\":503,\"ha\":601,\"o\":\"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 \"},\"©\":{\"x_min\":-3,\"x_max\":1008,\"ha\":1106,\"o\":\"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 \"},\"ώ\":{\"x_min\":0,\"x_max\":922,\"ha\":1030,\"o\":\"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 \"},\"^\":{\"x_min\":193.0625,\"x_max\":598.609375,\"ha\":792,\"o\":\"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 \"},\"«\":{\"x_min\":0,\"x_max\":507.203125,\"ha\":604,\"o\":\"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 \"},\"D\":{\"x_min\":0,\"x_max\":828,\"ha\":935,\"o\":\"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 \"},\"∙\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 \"},\"ÿ\":{\"x_min\":0,\"x_max\":47,\"ha\":125,\"o\":\"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 \"},\"w\":{\"x_min\":0,\"x_max\":1009.71875,\"ha\":1100,\"o\":\"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 \"},\"$\":{\"x_min\":0,\"x_max\":700,\"ha\":793,\"o\":\"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 \"},\"\\\\\":{\"x_min\":-0.015625,\"x_max\":425.0625,\"ha\":522,\"o\":\"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 \"},\"µ\":{\"x_min\":0,\"x_max\":697.21875,\"ha\":747,\"o\":\"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 \"},\"Ι\":{\"x_min\":42,\"x_max\":181,\"ha\":297,\"o\":\"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 \"},\"Ύ\":{\"x_min\":0,\"x_max\":1144.5,\"ha\":1214,\"o\":\"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 \"},\"’\":{\"x_min\":0,\"x_max\":139,\"ha\":236,\"o\":\"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 \"},\"Ν\":{\"x_min\":0,\"x_max\":801,\"ha\":915,\"o\":\"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 \"},\"-\":{\"x_min\":8.71875,\"x_max\":350.390625,\"ha\":478,\"o\":\"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 \"},\"Q\":{\"x_min\":0,\"x_max\":968,\"ha\":1072,\"o\":\"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 \"},\"ς\":{\"x_min\":1,\"x_max\":676.28125,\"ha\":740,\"o\":\"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 \"},\"M\":{\"x_min\":0,\"x_max\":954,\"ha\":1067,\"o\":\"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 \"},\"Ψ\":{\"x_min\":0,\"x_max\":1006,\"ha\":1094,\"o\":\"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 \"},\"C\":{\"x_min\":0,\"x_max\":886,\"ha\":944,\"o\":\"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 \"},\"!\":{\"x_min\":0,\"x_max\":138,\"ha\":236,\"o\":\"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 \"},\"{\":{\"x_min\":0,\"x_max\":480.5625,\"ha\":578,\"o\":\"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 \"},\"X\":{\"x_min\":-0.015625,\"x_max\":854.15625,\"ha\":940,\"o\":\"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 \"},\"#\":{\"x_min\":0,\"x_max\":963.890625,\"ha\":1061,\"o\":\"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 \"},\"ι\":{\"x_min\":42,\"x_max\":284,\"ha\":361,\"o\":\"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 \"},\"Ά\":{\"x_min\":0,\"x_max\":906.953125,\"ha\":982,\"o\":\"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 \"},\")\":{\"x_min\":0,\"x_max\":318,\"ha\":415,\"o\":\"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 \"},\"ε\":{\"x_min\":0,\"x_max\":634.71875,\"ha\":714,\"o\":\"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 \"},\"Δ\":{\"x_min\":0,\"x_max\":952.78125,\"ha\":1028,\"o\":\"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 \"},\"}\":{\"x_min\":0,\"x_max\":481,\"ha\":578,\"o\":\"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 \"},\"‰\":{\"x_min\":-3,\"x_max\":1672,\"ha\":1821,\"o\":\"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 \"},\"a\":{\"x_min\":0,\"x_max\":698.609375,\"ha\":794,\"o\":\"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 \"},\"—\":{\"x_min\":0,\"x_max\":941.671875,\"ha\":1039,\"o\":\"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 \"},\"=\":{\"x_min\":8.71875,\"x_max\":780.953125,\"ha\":792,\"o\":\"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 \"},\"N\":{\"x_min\":0,\"x_max\":801,\"ha\":914,\"o\":\"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 \"},\"ρ\":{\"x_min\":0,\"x_max\":712,\"ha\":797,\"o\":\"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 \"},\"¯\":{\"x_min\":0,\"x_max\":941.671875,\"ha\":938,\"o\":\"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 \"},\"Z\":{\"x_min\":0,\"x_max\":779,\"ha\":849,\"o\":\"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 \"},\"u\":{\"x_min\":0,\"x_max\":617,\"ha\":729,\"o\":\"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 \"},\"k\":{\"x_min\":0,\"x_max\":612.484375,\"ha\":697,\"o\":\"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 \"},\"Η\":{\"x_min\":0,\"x_max\":803,\"ha\":917,\"o\":\"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 \"},\"Α\":{\"x_min\":0,\"x_max\":906.953125,\"ha\":985,\"o\":\"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 \"},\"s\":{\"x_min\":0,\"x_max\":604,\"ha\":697,\"o\":\"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 \"},\"B\":{\"x_min\":0,\"x_max\":778,\"ha\":876,\"o\":\"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 \"},\"…\":{\"x_min\":0,\"x_max\":614,\"ha\":708,\"o\":\"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 \"},\"?\":{\"x_min\":0,\"x_max\":607,\"ha\":704,\"o\":\"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 \"},\"H\":{\"x_min\":0,\"x_max\":803,\"ha\":915,\"o\":\"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 \"},\"ν\":{\"x_min\":0,\"x_max\":675,\"ha\":761,\"o\":\"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 \"},\"c\":{\"x_min\":1,\"x_max\":701.390625,\"ha\":775,\"o\":\"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 \"},\"¶\":{\"x_min\":0,\"x_max\":566.671875,\"ha\":678,\"o\":\"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 \"},\"β\":{\"x_min\":0,\"x_max\":660,\"ha\":745,\"o\":\"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 \"},\"Μ\":{\"x_min\":0,\"x_max\":954,\"ha\":1068,\"o\":\"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 \"},\"Ό\":{\"x_min\":0.109375,\"x_max\":1120,\"ha\":1217,\"o\":\"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 \"},\"Ή\":{\"x_min\":0,\"x_max\":1158,\"ha\":1275,\"o\":\"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 \"},\"•\":{\"x_min\":0,\"x_max\":663.890625,\"ha\":775,\"o\":\"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 \"},\"¥\":{\"x_min\":0.1875,\"x_max\":819.546875,\"ha\":886,\"o\":\"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 \"},\"(\":{\"x_min\":0,\"x_max\":318.0625,\"ha\":415,\"o\":\"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 \"},\"U\":{\"x_min\":0,\"x_max\":796,\"ha\":904,\"o\":\"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 \"},\"γ\":{\"x_min\":0.5,\"x_max\":744.953125,\"ha\":822,\"o\":\"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 \"},\"α\":{\"x_min\":0,\"x_max\":765.5625,\"ha\":809,\"o\":\"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 \"},\"F\":{\"x_min\":0,\"x_max\":683.328125,\"ha\":717,\"o\":\"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 \"},\"­\":{\"x_min\":0,\"x_max\":705.5625,\"ha\":803,\"o\":\"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 \"},\":\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 \"},\"Χ\":{\"x_min\":0,\"x_max\":854.171875,\"ha\":935,\"o\":\"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 \"},\"*\":{\"x_min\":116,\"x_max\":674,\"ha\":792,\"o\":\"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 \"},\"†\":{\"x_min\":0,\"x_max\":777,\"ha\":835,\"o\":\"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 \"},\"°\":{\"x_min\":0,\"x_max\":347,\"ha\":444,\"o\":\"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 \"},\"V\":{\"x_min\":0,\"x_max\":862.71875,\"ha\":940,\"o\":\"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 \"},\"Ξ\":{\"x_min\":0,\"x_max\":734.71875,\"ha\":763,\"o\":\"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 \"},\" \":{\"x_min\":0,\"x_max\":0,\"ha\":853},\"Ϋ\":{\"x_min\":0.328125,\"x_max\":819.515625,\"ha\":889,\"o\":\"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 \"},\"”\":{\"x_min\":0,\"x_max\":347,\"ha\":454,\"o\":\"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 \"},\"@\":{\"x_min\":0,\"x_max\":1260,\"ha\":1357,\"o\":\"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 \"},\"Ί\":{\"x_min\":0,\"x_max\":499,\"ha\":613,\"o\":\"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 \"},\"i\":{\"x_min\":14,\"x_max\":136,\"ha\":275,\"o\":\"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 \"},\"Β\":{\"x_min\":0,\"x_max\":778,\"ha\":877,\"o\":\"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 \"},\"υ\":{\"x_min\":0,\"x_max\":617,\"ha\":725,\"o\":\"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 \"},\"]\":{\"x_min\":0,\"x_max\":275,\"ha\":372,\"o\":\"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 \"},\"m\":{\"x_min\":0,\"x_max\":1019,\"ha\":1128,\"o\":\"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 \"},\"χ\":{\"x_min\":8.328125,\"x_max\":780.5625,\"ha\":815,\"o\":\"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 \"},\"ί\":{\"x_min\":42,\"x_max\":326.71875,\"ha\":361,\"o\":\"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 \"},\"Ζ\":{\"x_min\":0,\"x_max\":779.171875,\"ha\":850,\"o\":\"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 \"},\"R\":{\"x_min\":0,\"x_max\":781.953125,\"ha\":907,\"o\":\"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 \"},\"o\":{\"x_min\":0,\"x_max\":713,\"ha\":821,\"o\":\"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 \"},\"K\":{\"x_min\":0,\"x_max\":819.46875,\"ha\":906,\"o\":\"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 \"},\",\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 \"},\"d\":{\"x_min\":0,\"x_max\":683,\"ha\":796,\"o\":\"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 \"},\"¨\":{\"x_min\":-109,\"x_max\":247,\"ha\":232,\"o\":\"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 \"},\"E\":{\"x_min\":0,\"x_max\":736.109375,\"ha\":789,\"o\":\"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 \"},\"Y\":{\"x_min\":0,\"x_max\":820,\"ha\":886,\"o\":\"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 \"},\"\\\"\":{\"x_min\":0,\"x_max\":299,\"ha\":396,\"o\":\"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 \"},\"‹\":{\"x_min\":17.984375,\"x_max\":773.609375,\"ha\":792,\"o\":\"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 \"},\"„\":{\"x_min\":0,\"x_max\":364,\"ha\":467,\"o\":\"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 \"},\"δ\":{\"x_min\":1,\"x_max\":710,\"ha\":810,\"o\":\"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 \"},\"έ\":{\"x_min\":0,\"x_max\":634.71875,\"ha\":714,\"o\":\"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 \"},\"ω\":{\"x_min\":0,\"x_max\":922,\"ha\":1031,\"o\":\"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 \"},\"´\":{\"x_min\":0,\"x_max\":96,\"ha\":251,\"o\":\"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 \"},\"±\":{\"x_min\":11,\"x_max\":781,\"ha\":792,\"o\":\"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 \"},\"|\":{\"x_min\":343,\"x_max\":449,\"ha\":792,\"o\":\"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 \"},\"ϋ\":{\"x_min\":0,\"x_max\":617,\"ha\":725,\"o\":\"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 \"},\"§\":{\"x_min\":0,\"x_max\":593,\"ha\":690,\"o\":\"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 \"},\"b\":{\"x_min\":0,\"x_max\":685,\"ha\":783,\"o\":\"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 \"},\"q\":{\"x_min\":0,\"x_max\":683,\"ha\":876,\"o\":\"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 \"},\"Ω\":{\"x_min\":-0.171875,\"x_max\":969.5625,\"ha\":1068,\"o\":\"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 \"},\"ύ\":{\"x_min\":0,\"x_max\":617,\"ha\":725,\"o\":\"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 \"},\"z\":{\"x_min\":-0.015625,\"x_max\":613.890625,\"ha\":697,\"o\":\"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 \"},\"™\":{\"x_min\":0,\"x_max\":894,\"ha\":1000,\"o\":\"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 \"},\"ή\":{\"x_min\":0.78125,\"x_max\":697,\"ha\":810,\"o\":\"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 \"},\"Θ\":{\"x_min\":0,\"x_max\":960,\"ha\":1056,\"o\":\"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 \"},\"®\":{\"x_min\":-3,\"x_max\":1008,\"ha\":1106,\"o\":\"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 \"},\"~\":{\"x_min\":0,\"x_max\":833,\"ha\":931,\"o\":\"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 \"},\"Ε\":{\"x_min\":0,\"x_max\":736.21875,\"ha\":778,\"o\":\"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 \"},\"³\":{\"x_min\":0,\"x_max\":450,\"ha\":547,\"o\":\"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 \"},\"[\":{\"x_min\":0,\"x_max\":273.609375,\"ha\":371,\"o\":\"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 \"},\"L\":{\"x_min\":0,\"x_max\":645.828125,\"ha\":696,\"o\":\"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 \"},\"σ\":{\"x_min\":0,\"x_max\":803.390625,\"ha\":894,\"o\":\"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 \"},\"ζ\":{\"x_min\":0,\"x_max\":573,\"ha\":642,\"o\":\"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 \"},\"θ\":{\"x_min\":0,\"x_max\":674,\"ha\":778,\"o\":\"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 \"},\"Ο\":{\"x_min\":0,\"x_max\":958,\"ha\":1054,\"o\":\"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 \"},\"Γ\":{\"x_min\":0,\"x_max\":705.28125,\"ha\":749,\"o\":\"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 \"},\" \":{\"x_min\":0,\"x_max\":0,\"ha\":375},\"%\":{\"x_min\":-3,\"x_max\":1089,\"ha\":1186,\"o\":\"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 \"},\"P\":{\"x_min\":0,\"x_max\":726,\"ha\":806,\"o\":\"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 \"},\"Έ\":{\"x_min\":0,\"x_max\":1078.21875,\"ha\":1118,\"o\":\"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 \"},\"Ώ\":{\"x_min\":0.125,\"x_max\":1136.546875,\"ha\":1235,\"o\":\"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 \"},\"_\":{\"x_min\":0,\"x_max\":705.5625,\"ha\":803,\"o\":\"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 \"},\"Ϊ\":{\"x_min\":-110,\"x_max\":246,\"ha\":275,\"o\":\"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 \"},\"+\":{\"x_min\":23,\"x_max\":768,\"ha\":792,\"o\":\"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 \"},\"½\":{\"x_min\":0,\"x_max\":1050,\"ha\":1149,\"o\":\"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 \"},\"Ρ\":{\"x_min\":0,\"x_max\":720,\"ha\":783,\"o\":\"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 \"},\"'\":{\"x_min\":0,\"x_max\":139,\"ha\":236,\"o\":\"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 \"},\"ª\":{\"x_min\":0,\"x_max\":350,\"ha\":397,\"o\":\"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 \"},\"΅\":{\"x_min\":0,\"x_max\":450,\"ha\":553,\"o\":\"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 \"},\"T\":{\"x_min\":0,\"x_max\":777,\"ha\":835,\"o\":\"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 \"},\"Φ\":{\"x_min\":0,\"x_max\":915,\"ha\":997,\"o\":\"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 \"},\"⁋\":{\"x_min\":0,\"x_max\":0,\"ha\":694},\"j\":{\"x_min\":-77.78125,\"x_max\":167,\"ha\":349,\"o\":\"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 \"},\"Σ\":{\"x_min\":0,\"x_max\":756.953125,\"ha\":819,\"o\":\"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 \"},\"›\":{\"x_min\":18.0625,\"x_max\":774,\"ha\":792,\"o\":\"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 \"},\"\":{\"x_min\":18.0625,\"x_max\":774,\"ha\":792,\"o\":\"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 \"},\"v\":{\"x_min\":0,\"x_max\":675.15625,\"ha\":761,\"o\":\"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 \"},\"τ\":{\"x_min\":0.28125,\"x_max\":644.5,\"ha\":703,\"o\":\"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 \"},\"ξ\":{\"x_min\":0,\"x_max\":624.9375,\"ha\":699,\"o\":\"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 \"},\"&\":{\"x_min\":-3,\"x_max\":894.25,\"ha\":992,\"o\":\"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 \"},\"Λ\":{\"x_min\":0,\"x_max\":862.5,\"ha\":942,\"o\":\"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 \"},\"I\":{\"x_min\":41,\"x_max\":180,\"ha\":293,\"o\":\"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 \"},\"G\":{\"x_min\":0,\"x_max\":921,\"ha\":1011,\"o\":\"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 \"},\"ΰ\":{\"x_min\":0,\"x_max\":617,\"ha\":725,\"o\":\"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 \"},\"`\":{\"x_min\":0,\"x_max\":138.890625,\"ha\":236,\"o\":\"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 \"},\"·\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 \"},\"Υ\":{\"x_min\":0.328125,\"x_max\":819.515625,\"ha\":889,\"o\":\"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 \"},\"r\":{\"x_min\":0,\"x_max\":355.5625,\"ha\":432,\"o\":\"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 \"},\"x\":{\"x_min\":0,\"x_max\":675,\"ha\":764,\"o\":\"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 \"},\"μ\":{\"x_min\":0,\"x_max\":696.609375,\"ha\":747,\"o\":\"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 \"},\"h\":{\"x_min\":0,\"x_max\":615,\"ha\":724,\"o\":\"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 \"},\".\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 \"},\"φ\":{\"x_min\":-2,\"x_max\":878,\"ha\":974,\"o\":\"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 \"},\";\":{\"x_min\":0,\"x_max\":142,\"ha\":239,\"o\":\"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 \"},\"f\":{\"x_min\":0,\"x_max\":378,\"ha\":472,\"o\":\"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 \"},\"“\":{\"x_min\":1,\"x_max\":348.21875,\"ha\":454,\"o\":\"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 \"},\"A\":{\"x_min\":0.03125,\"x_max\":906.953125,\"ha\":1008,\"o\":\"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 \"},\"‘\":{\"x_min\":1,\"x_max\":139.890625,\"ha\":236,\"o\":\"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 \"},\"ϊ\":{\"x_min\":-70,\"x_max\":283,\"ha\":361,\"o\":\"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 \"},\"π\":{\"x_min\":-0.21875,\"x_max\":773.21875,\"ha\":857,\"o\":\"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 \"},\"ά\":{\"x_min\":0,\"x_max\":765.5625,\"ha\":809,\"o\":\"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 \"},\"O\":{\"x_min\":0,\"x_max\":958,\"ha\":1057,\"o\":\"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 \"},\"n\":{\"x_min\":0,\"x_max\":615,\"ha\":724,\"o\":\"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 \"},\"l\":{\"x_min\":41,\"x_max\":166,\"ha\":279,\"o\":\"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 \"},\"¤\":{\"x_min\":40.09375,\"x_max\":728.796875,\"ha\":825,\"o\":\"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 \"},\"κ\":{\"x_min\":0,\"x_max\":632.328125,\"ha\":679,\"o\":\"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 \"},\"p\":{\"x_min\":0,\"x_max\":685,\"ha\":786,\"o\":\"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 \"},\"‡\":{\"x_min\":0,\"x_max\":777,\"ha\":835,\"o\":\"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 \"},\"ψ\":{\"x_min\":0,\"x_max\":808,\"ha\":907,\"o\":\"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 \"},\"η\":{\"x_min\":0.78125,\"x_max\":697,\"ha\":810,\"o\":\"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 \"}},\"cssFontWeight\":\"normal\",\"ascender\":1189,\"underlinePosition\":-100,\"cssFontStyle\":\"normal\",\"boundingBox\":{\"yMin\":-334,\"xMin\":-111,\"yMax\":1189,\"xMax\":1672},\"resolution\":1000,\"original_font_information\":{\"postscript_name\":\"Helvetiker-Regular\",\"version_string\":\"Version 1.00 2004 initial release\",\"vendor_url\":\"http://www.magenta.gr/\",\"full_font_name\":\"Helvetiker\",\"font_family_name\":\"Helvetiker\",\"copyright\":\"Copyright (c) Μagenta ltd, 2004\",\"description\":\"\",\"trademark\":\"\",\"designer\":\"\",\"designer_url\":\"\",\"unique_font_identifier\":\"Μagenta ltd:Helvetiker:22-10-104\",\"license_url\":\"http://www.ellak.gr/fonts/MgOpen/license.html\",\"license_description\":\"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\\"Fonts\\\") and associated documentation files (the \\\"Font Software\\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\\"MgOpen\\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\\"MgOpen\\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.\",\"manufacturer_name\":\"Μagenta ltd\",\"font_sub_family_name\":\"Regular\"},\"descender\":-334,\"familyName\":\"Helvetiker\",\"lineHeight\":1522,\"underlineThickness\":50}","link":"/jo.github.io/about/helvetiker_regular.typeface.json"},{"title":"Tags","text":"","link":"/jo.github.io/tags/index.html"}],"posts":[{"title":"ES6 简单特性尝鲜-1","text":"ES6的出现，无疑是对现有的ES5的一次巨大冲击。某种程度上，部分人觉得这是给开发人员带来的巨大惊喜。它保证现有的基础之外，增加了很多好用的语法糖，使得对后端转入的javascript更为友好。尽管有些人在ES5上还未站稳脚跟——譬如我，但已经迫不及待地想去尝试ES6。尽管在我的工作曾写过coffeescript,typescipt，但我始终觉得基础的才是实用的。让我们抛开那些多样的Javascript超集不谈，回归到js本身来。 1.Block-Scoped Constructs Let and Const (构造let和const及块作用域) 在我刚开始学习js的时候，我的老师教导在js中声明变量，一定要用var声明。否则这些可能原本应当属于你的孩子，最终都会被window抢走。 后来在工作中，更规范的写法是将所有的变量声明在js顶部，以防止声明提前带来的糟糕影响。 而ES6中的let，则让你更容易地避免以上两种易犯的错误。 let是一种新的变量声明的方式，它允许你把变量作用域控制在块级里面。 *你可能不信，让我们先苦后甜——以一个糟糕的例子开头 123456789101112131415function checkYourMoney(you) &#123; var money = 0; if (you) &#123; var money = 5; &#125; &#123; var money = 100; // 混淆你的视线 &#123; var money = 1000; // 再次混淆 &#125; &#125; return money;&#125;console.log(checkYourMoney(true)); 不管你信不信，控制台里输出的都是冷冰冰的1000。尽管现实中你可能希望钱确实能无故多出来，但在代码这儿可不行。 *反面教材结束，正面登场 123456789101112131415function checkYourMoney(you) &#123; let money = 0; if (you) &#123; let money = 5; &#125; &#123; let money = 100; &#123; let money = 1000; &#125; &#125; return money;&#125;console.log(checkYourMoney(true)); 这回变了，输出为0。*let的好处是让你在任何块内定义都不会互相影响，尽管在别的块内你定义了money不同的值，但对于return而言，只获取邻近的变量。 *相对而言，const的使用较少一些。它的作用是声明常量。虽然这么说，不过它的作用更类似于一个指针指向某个引用，这么听起来好像有些git的感觉。尽管它用于定义常量，但这常量并非一成不变。 1234const GIRL = ['lovely']; // 定义一只可爱的妹子GIRL.push('beautiful'); // 再漂亮点儿console.log(GIRL); // ['lovely', 'beautiful']GIRL = 'lovely and beautiful'; // TypeError: Identifier 'GIRL' has already been declared(…) // 您的妹子已被认领 let和const的基本用法就是这样，还有几点需要注意的是 let声明的变量不具备声明提前的属性，意味着可以就近使用。 let和const只在最靠近的块(作用域/花括号)中有效。 使用const声明时采用大写方式。 const在声明时必须赋值。 let为编写者带来了很多便利，相应地维护成本也增加了，因为你需要非常了解每个声明的变量所处的块作用域。 2.Template Literals (模板对象) 我在工作中有写coffeescript，里面的#{}用法很方便，让你即使在字符串中也可以很自如地穿插变量，现在，ES6推出了类似的写法。 即${}——注意这里的分隔符是反引号`不是‘。 小试一把 12let code = 'cold';console.log(`My code is $&#123;code&#125;`); 123// 在我的日常中更广泛的用法是——譬如angular中$http.get(`$&#123;config().lala_url&#125;/abc/book?page$&#123;page&#125;=&amp;count=$&#123;count&#125;`)// do something... 3.Muti-line Strings (多行字符串) 相信不少人在使用jquery的时候都拼接过字符串，而如果一旦内容较多，画面一定很香艳。 true story——请感受一下冰山一角 123456789let order = '&lt;div class=\"order\"&gt;' + '&lt;div class=\"orderTitle\"&gt;' + '&lt;div class=\"fl\"&gt;' + '&lt;div class=\"orderNum ml10\"&gt;' + order.number + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'+ '&lt;/div&gt;' 而有了ES6的反引号，妈妈再也不用担心我的拼接了！ 123456789let order = `&lt;div class=\"order\"&gt; &lt;div class=\"orderTitle\"&gt; &lt;div class=\"fl\"&gt; &lt;div class=\"orderNum ml10\"&gt; order.number &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;` 请忽略这是段糟糕代码的事实——看！是不是清爽多了。 未完待续…… 参考： 1.前端开发者不得不知的ES6十大特性&amp;version=11020201&amp;pass_ticket=c7Yh9%2F%2BIn%2FGijh%2B4%2BO4woXjDX0Z7CZPLJ3RU4OSXBwKIZsuXR7JF%2F6eQuiz9CwSj) 2.ECMAScript 6 扫盲&amp;version=11020201&amp;pass_ticket=Et6ONVlb%2FAvtJ1F2RhJ0%2B9Fgp347EX4ziPKzR5tTKUrSqpaxXrVZABtlsquUNvfc)","link":"/jo.github.io/2016/07/24/ES6-new-features-1/"},{"title":"ES6 新特性尝鲜-2之箭头函数","text":"最近在准备一个新项目，引入了ES6，平时也常写ts，在越来越多的实战中发现箭头函数确实是ES6里最实用的新特性之一。 Arrow Functions 箭头函数首先来看看ES5之前的函数定义的几种方式:123456789101112131415161718191.函数语句定义function printProps(o) &#123; for (var p in o) &#123; console.log(p + ':' + o[p] + '\\n'); &#125;;&#125;2.表达式定义var f = function fact(x) &#123; if (x &lt; 1) &#123; return x; &#125; else &#123; return x * fact(x - 1); &#125;;&#125;也可以定以后立即调用:var tensquared = (function(x) &#123;return x * x&#125;(10)) 如果代码中的函数较少，也还好接受。但当函数较多时，满屏的function有些让人烦扰。*让我们来试试ES6吧。 ES6箭头函数12ES6允许用箭头来定义函数。var f = a =&gt; a; 等同于 123var f = function(a) &#123; return a;&#125; 如果没有参数或多个参数，可以直接使用括号。箭头后紧跟函数体。 123456789var f = () =&gt; b;即var f = function() &#123; return b;&#125;var sum = (a, b) =&gt; a + b;即var sum = function(a, b) &#123; return a + b;&#125; 当返回的是对象时，由于花括号会被解析为函数体，所以要加上括号。 1var getPerson = () =&gt; (&#123;id: 'sdfdkjhgdflg', name: 'kyrie'&#125;); 当返回的是多行语句，需要用花括号括起来。 12345var init = (p) =&gt; &#123; for (var o in p) &#123; console.log(o + ' : ' + p[o]); &#125;&#125; 当然，出于代码整洁和规范的需要。通常会带上花括号。 123456var init = () =&gt; &#123; return &#123; address: '西湖区', point: [120.123, 30.321] &#125;&#125; 使用箭头函数的好处 1.最大的好处就是使得代码更简洁,尤其是涉及回调的函数。 ​1234567891011121314151617var timer = setInterval(function() &#123; console.log(new Date());&#125;, 1000);可简写为var timer = setInterval(() =&gt; &#123; console.log(new Date());&#125;);同样的还有使用ajax时，如在angular中使用$http.get('api.123feng.com/test').then(() =&gt; &#123; // do something&#125;, () =&gt; &#123; // do something&#125;);是不是简洁清爽了很多。​ 2.还有this只指代定义时的对象，而不是当前对象，所以再也不需要用that来替代this。 ​1234567891011121314151617181920212223242526我在写angular时便会遇到，所有定义的变量都相当于是属性，需要用this.prop去访问。这里使用了ts。export class OrderBatchController &#123; public order: any; constructor()&#123; this.order = &#123;&#125;; &#125; getOrder() &#123; var that = this; this.$http('api.123feng.com/test') .then(function(res) &#123; // 将获取的值赋值,如果写成this，则该变量变成是window下的变量了。 that.order = res.data; &#125;) &#125;&#125;用箭头函数则无须这一步getOrder() &#123; this.$http('api.123feng.com/test') .then((res) =&gt; &#123; // this始终指代当前的controller。 this.order = res.data; &#125;)&#125;​ 注意点1.函数体内的this指向定义时的对象，不管嵌套多少层函数，都指向定义时的对象。12345678910getOrder() &#123; this.$http('api.123feng.com/test') .then((res) =&gt; &#123; // this始终指代当前的controller。 this.order = res.data; setInterval(() =&gt; &#123; this.order = &#123;&#125;; // controller下面的order又变回&#123;&#125; &#125;, 1000) &#125;)&#125; 2.不能用new一个来创建构造函数，否则将会报错。3.不可以使用arguments对象，会在箭头函数的函数体内不存在。使用rest参数代替（待探究） 小结 总体来说，个人觉得ES6的箭头函数和coffee中的箭头函数很相似，使用起来也很方便。最需要注意的地方则是这个this不会再三心二意了。 后续如果有其他注意点，再补充。 参考ES6入门","link":"/jo.github.io/2016/08/31/ES6-new-features-2-arrow-function/"},{"title":"HTTP协议之自定义headers参数","text":"近期和我司服务端对接时发现藏在headers里的参数，并不是HTTP的response里的常规参数。几经折腾后发现是自定义的参数。供前端ajax调用时提取使用。 Before 在工作时常常有获取列表的接口，就必然会涉及获取到的数组的长度，即页数。 讲道理，将返回的数组内容和总数量一起返回并不太合理，就像一本书不会在每一页上都标明总页数，而是在书的最开始或者末尾有说明。所以秉着内容和页数不应存放在一起的原则，服务端同事将列表的总页数放在了response的headers里。 所以问题是如何从response headers获取相应参数。 详情 查找了部分文档后找到了Access-Control-Expose-Headers这个参数。 The Access-Control-Expose-Headers response header indicates which headers can be exposed as part of the response by listing their names. 它表明了哪些参数是可以用名字展示在response的header里的——这里的展示应当理解为前端可以获取，而不是单纯的显示。 默认是展示6个参数： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 也可以展示其他参数。通过以下方式设置： Access-Control-Expose-Headers: Content-Length 甚至自定义参数： Access-Control-Expose-Headers: X-Resource-Count, Content-Length 这样当服务端传了X-Resource-Count时在前端就可以取到X-Rource-Count的值。 123456789101112131415161718192021222324252627282930313233343536373839401.在angular中获取$http.get(`$&#123;url&#125;/getLists/`).then((res) =&gt; &#123; // 可以获取到 console.log(res.headers('X-Resource-Count'));&#125;);2.在jquery中获取$.ajax(&#123; url: `$&#123;url&#125;/getLists`, type: 'GET', contentType: 'application/json;charset/utf-8',&#125;).done((data, textStatus, jqXHR) =&gt; &#123; console.log(jqXHR.getResponseHeader('X-Resource-Count'));&#125;);3.原生ajaxif (window.XMLHttpRequest) &#123; // Mozilla, Safari. IE7+ httpRequest = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE 6 and older httpRequest = new ActiveXObject('Microsoft.XMLHTTP');&#125;httpRequest.onreadystatechange = () =&gt; &#123; if (httpRequest.readyState === XMLHttpRequest.DONE) &#123; if (httpRequest.statue === 200) &#123; // something... &#125; else &#123; // error &#125; &#125;&#125;;httpRequest.open('GET', `$&#123;url&#125;/getLists`);______________________________________________________________function getHeaderCount() &#123; console.log(this.getResponseHeader('X-Resource-Count'));&#125;httpRequest.onload = getHeaderCount;______________________________________________________________httpRequest.send(); 这样就可以愉快地使用X-Resource-Count了。 参考：Access-Control-Expose-HeadersAjax","link":"/jo.github.io/2016/10/17/HTTP-define-headers-params/"},{"title":"/* @ngInject */介绍","text":"angular的依赖注入是一个非常好的特性。但如果注入的很多也会比较麻烦。发现了一个可以自动创建注射器对象的方法。 /* @ngInject */ 由于项目使用脚手架构建的，使用了Gulp，所以可以用/ @ngInject /对需要自动依赖注入的function进行注释。避免了一个个输入的麻烦和意外的错误。*前提是在Gulp中使用了ng-annotate。 可以避免代码中的依赖使用到任何不安全的写法. 不推荐用ng-min. *只需在函数前添加即可 1234567891011export class WindController &#123; public sender: IOrderSender; public checkJavaRes: any; /* @ngInject */ constructor ( private $uibModal, private url )&#123; ... &#125;&#125; 当它在ng-annotate(压缩注释工具?)下运行时，会输出依赖注入的数组. 1WindController.$inject = ['$uibModal', 'url'] 这样原本在index.module.ts(统一写路由的地方)中需要依赖注入的地方就可以无需再输入 123456angular.module('wind', ['ngCookies',...]).controller('WindController', ['$scope', '$http', WindController]) ... 更新后angular.module('wind', ['ngCookies',...]).controller('WindController', WindController) 假如不加入注释的话，使用后者的写法会报错 Error: [$injector:strictdi] WindController is not using explicit annotation and cannot be invoked in strict mode.必须要依赖注入。 参考: angular中文规范","link":"/jo.github.io/2016/08/18/about-@ngInject/"},{"title":"call和apply的区别及各自应用场景","text":"call和apply是js里非常常见的两个概念。但自己从来没有好好的深入理解这两者，尤其是在何时使用，如何使用才适合这两个问题上，没有进一步的思考。这里写一篇笔记来反思。 call和apply的定义 在JavaScript权威指南上是这么定义的： call()和apply()可以看做是某个对象的方法，通过调用方法的形式来简洁调用函数。 call, apply都属于Function.prototype的方法。因此所有函数都有该方法。 call()和apply()的第一个实参是要调用函数的母对象，是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f(),可以这样使用它们。 123456f.call(o);f.apply(o);等同于o.m = f;o.m();delete o.m; 代码可以理解，但描述理解起来实在困难。 具体说明 定义都是用来考试时死记硬背的。所以来看看实例。 首先要明确一点：call()和apply()的作用是一样的，只是调用方式不同。 例如：foo.call(this, arg1, arg2, arg3) == foo.apply(this, arguments) == this.foo(arg1, arg2, arg3/* arguments */) 两者唯一的不同点在于第二个传入的参数。 第一个实参指代当前调用的对象，如果在ES5严格模式下，第一个实参不管传入什么null或undefined或其他，都会变成this。 第二个实参，call方法可以传入任意的实参，不论数量长度。如foo.call(this, arg1, arg2, arg3…) apply方法则传入的是数组，可以是任意长度的数组，而且传入的数组包括类数组对象。如foo.apply(this, arguments) 应用场景 我觉得这部分才是要深入理解的，何时去调用它们，使用它们有什么方便之处。 call和apply的用途是借用别人的方法来调用，或者说，是动态改变this这个对象。 前者或许更好理解。来看看这样一个例子。 123456789101112131415const a = &#123; name: 'mdzz', say: (name) =&gt; &#123; console.log(name) window.alert(`我是 $&#123;name&#125;`); &#125;&#125;const b = &#123;&#125;;// b也是zz,但没有相应的say方法，所以此时b想借用a的方法。// 调用a的方法给b使用a.say.call(b);b.name = 'yrmdzz';// 传入参数时a.say.call(b, b.name);a.say.apply(b, [b.name]); 1234567891011121314151617181920212223242526272829303132333435363738394041/* 或者这样定义更为明显 */ function Foo()&#123;&#125;; // 添加原型属性 Foo.prototype = &#123; name: 'mdzz', say: function() &#123; console.log(this); // 当前调用的对象Foo alert(`I am $&#123;this.name&#125;`); &#125; &#125;// new 生成一个实例对象 const people = new Foo(); console.info(people); people.say(); // 定义一个没有say方法的对象animal // 让它调用people的say方法 const animal = &#123; name: 'kitty' &#125; people.say.call(animal);/* 一个更显而易见的例子 */// 定义一个函数，可以判断传入参数的基本类型 function type(obj) &#123; let toString = Object.prototype.toString; let map = [ '[object Boolean]': 'boolean', '[object Object]': 'Object', '[object Array]': 'array', '[object Number]': 'number', '[object String]': 'string', '[object RegExp]': 'regExp', '[object Function]': 'function', '[object Date]': 'data', '[object Undefined]': 'undefined', '[object Null]': 'null', ]; return map[toString.call(obj)];&#125; 123456789101112131415161718192021222324252627/* 在参数不定时，则可使用apply */ // 这里的例子改写自权威指南 // 内置Math对象有一个max方法，接受任意个参数，返回其中的最大值 // 但有时我们调用时，无法预知参数的个数，而且这种取最大值的情况通常在数组中发生 // 假如有这样一个数组 let arr = [4,98,34,90,41,78]; // 直接Math.max会返回NaN,因为它不接受数组作为参数 Math.max(arr); // 返回NaN // apply方法接受数组作为参数 let biggest = Math.max.apply(Math, arr); console.info(biggest); // 98 // 第一个参数Math可以替换为任何其他值，如下的也都可以 let biggest2 = Math.max.apply(this, arr); let biggest3 = Math.max.apply(null, arr); console.info(biggest2); // 98 console.info(biggest3); // 98/* 还有一个比较有意思的apply使用场景 */ // 使用push方法来合并数组 let arrayA = ['say', 'hello']; let arrayB = ['ok', 'master']; Array.prototype.push.apply(arrayA, arrayB); // arrayA: ['say', 'hello', 'ok', 'master'] 所以我的理解是以下在两种情况下使用call(), apply(): 1.动态改变调用的对象，或者说使没有该方法的对象调用有该方法的对象的方法。 2.改变方法的传入参数为数组。 就目前看来，肯定还有更多的使用场景。但我还未遇到，等遇到或理解的更深一步的时候，再来补充。 参考：《JavaScript权威指南》","link":"/jo.github.io/2016/11/04/call-and-apply-difference-and-application/"},{"title":"chrome插件指南——程序员篇","text":"作为chrome重度用户，在日常工作中少不了用浏览器做些各种各样的事。作为一名前端攻城狮，也少不了用chrome进行开发和调试。这期我整理了部分自认为好用到飞起的插件，希望看到的人也喜欢，也和我一样爽到飞起。 插件列表 Vimium Octotree GitHub Awesome Autocomplete Vimium 有一个传说，说vim是编辑器之神。而我认识的使用vim的前端前辈们也都不是等闲之辈。这款插件就是让你使用vim的快捷键来操作页面。 它包含了日常对网页的几乎所有操作。如果你不熟悉，可以按下shift + ? 来查看所有快捷键。 为什么说它好用呢。首先键盘党一定会点赞，因为它可以让你手再也不用离开键盘去操作那烦人的鼠标。其次，想象一个使用场景——当你靠在沙发或床上，想要上下滑动页面，或者打开新页面，总免不了把手离开键盘，去使用鼠标。但这可是在床上，操作鼠标有诸多不便。也许你有mac，触控板的体验不错，但……如果你是windows,我相信这一定是件麻烦的事。 来看看快捷键一览： 页面滚动、打开新标签页、复制网址、打开书签、查看历史记录、快速跳转标签页、打开页面上的链接等等等等，你想要的，它全都拥有。 赶快去躺在床上试一试吧。 Octotree 作为一名程序猿，我想会有很多使用到Github的场景。不管是追求技术去看各种框架的源码，或是为了潮流去star一些新项目，或者甚至为开源项目贡献自己的一份力，都会离不开Github。 有一位我眼中的大神教授我，看项目不能仅仅满足于readme，要多看源码。但Github上查看源码需要在各个目录下跳转，有诸多不便，所以有了以下这款插件。 感受下，即插即用： 请暂且撇开这做作的字体和装逼的主题，只看左侧。 项目目录一览无余，加上一路直达这样的跳转是不是很完美，很方便。 Github Awesome Autocomplete 这是一个类似alfred的插件。用过alfred的相信没有几个不说好的。这个插件也类似。 先看看平常我们是怎么在Github上搜索的: 事实上，我并不想要这个搜索结果。想我堂堂大angular,怎么可能只有1W+的star…所以还必须要切换到best stars搜索，或者直接搜索angular.js才得到想要的结果。小弟无知，至今没搞明白这两个仓库有啥区别。 然而当我们使用插件后： 这样是不是一目了然，清爽许多?！ 小结 暂且先到这里，后续有补充再添加。 对了，别忘了先学会科学上网噢。","link":"/jo.github.io/2016/09/18/chrome-plugins-for-coders/"},{"title":"JavaScript数组去重","text":"整理了部分常用的数组去重方法。 ES3实现 采用和冒泡排序相似的思路，一一对比后将确定不重复的元素放入新数组。 123456789101112131415161718function unique(arr) &#123; var res = []; for (var i = 0; i &lt; arr.length; i++) &#123; var isUnique = true; // 标识该元素是否唯一 for (var j = i + 1; j &lt; arr.length - i; j++) &#123; if (arr[i] === arr[j]) &#123; isUnique = false; &#125; &#125; if (isUnique) &#123; res.push(arr[i]); &#125; &#125; return res;&#125;var arr = [0, 0, 1, 1, 2, '2'];unique(arr); ES5实现1.方法一：数组的indexOf方法——Array.prototype.indexOf 如果查找到的当前元素的位置和和实际位置相同，那么向新数组里添加。 12345678910function unique(arr) &#123; let res = []; for (var i = 0; i &lt; arr.length; i++) &#123; (arr.indexOf(arr[i]) === i) &amp;&amp; res.push(arr[i]); &#125; return res;&#125;var arr = [1, 1, 2, 2, 3];unique(arr); // [1, 2, 3]; 2.方法二：数组的filter方法——Array.prototype.filter 使用indexOf方法和ES5提供的数组方法filter, 返回查询到位置相应的元素 12345678function unique(arr) &#123; return arr.filter(function(value, index, array) &#123; return array.indexOf(value) === index; &#125;)&#125;var arr = [0, '0', 0, 1, 1, '1'];unique(arr); // [0, '0', 1, '1']; filter方法接受一个函数，里面是判断条件，符合条件为true的数组元素组成一个数组，最终的返回这个数组。 123456789101112131415/** * [unique 数组去重，使用ES5的filter方法] * @param &#123;[obj]&#125; value [数组元素] * @param &#123;[number]&#125; index [索引值] * @param &#123;[array]&#125; arr [原始数组] * @return &#123;[type]&#125; [description] */function filter(value, index, arr) &#123; return arr.indexOf(value) === index;&#125;// 所以以上的去重函数可简化为：function unique(arr) &#123; return arr.filter(filter);&#125; 3.方法三：采用属性哈希值的方法.如果当前元素在对象中没有对应的属性存在，则设置该属性值为true. 该方法可以用于去重由纯数字类型的元素组成的数组。 123456789function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(value) &#123; return obj.hasOwnProperty(value) ? false : (obj[value] = true); &#125;);&#125;var arr = [1, 1, 2, 2, 3];unique(arr); // [1, 2, 3]; 但是该方法无法判断含字符串类型的元素的内容, 因为对象的属性默认会保存为字符串类型。(该方法可能有限制，暂未发现) 1234567891011var arr = [1, 1, '1', 2, '2', 3];unique(arr); // [1, 2, 3]; 无法区分数字类型和字符串类型// 加上类型保存function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(value) &#123; return obj.hasOwnProperty(typeof(value) + value) ? false : (obj[typeof(value) + value] = true); &#125;);&#125;unique(arr); // [1, '1', 2, '2', 3]; ES6实现1.方法一：Array.from与Set 首先使用Set定义一个没有重复值的可遍历对象。再使用ES6提供的数组方法from()将其转化为数组，或者使用扩展运算符...将其转化为数组。 123456function unique(arr) &#123; return Array.from(new Set(arr));&#125;const arr = [1, \"1\", 1, 2, 2];unique(arr); // [1, '1', 2]; 不会进行类型转换 这里使用了ES6提供的两种新的数据结构(Set和Map)之Set. 它类似于数组，但每个属性(值)都是唯一的。可使用构造函数Set生成。 Set有内置属性size，可以查看数组的长度。 12345678910// 数组作为参数传入const set = new Set([1, 2, 3, 4, 5, 5]);set.size; // 5// 类数组对象传入function getDivs() &#123; return [...document.querySelectorAll('div')];&#125;const set2= new Set(getDivs());set2.size; // 192 ​ ES6中，数组扩展了很多方法。这里用到了Array.from方法。它用于将两类对象转为真正的数组: 1.类似数组的对象(array-like-object) 2.可遍历(iterable)的对象,包括ES6新增的数据结构Set和Map 以上的Set则属于第二种，可遍历的对象。 2.方法二：扩展运算符(…)与Set 首先使用Set定义一个没有重复值的可遍历对象。再使用ES6新增的扩展运算符...将其转化为参数序列并作为数组的内容。 123456function unique(arr) &#123; return [...new Set(arr)];&#125;const arr = [0, '0', 1, 1, 2, 2];unique(arr); // [0, '0', 1, 2] 扩展运算符 ...用于实现将一个数组转化为逗号分隔的参数序列。 持续更新……","link":"/jo.github.io/2016/12/05/duplicate-removal-algorithm-about-array/"},{"title":"CSS3 实现🎲旋转教程","text":"最近的工作开始接触到可视化的 3D 部分，因此自己也抽时间温习了以前学习的 css3 知识点，顺便完成一个入门小 demo —— 实现一个旋转的骰子。这个例子里有重温 css3 的一些知识点——用它来实现立体和旋转效果，然后用 flex 布局来实现骰子的点的排列。这个案例对于以后熟练使用 css 和 flex 有一定的帮助，所以这里也做一份教程和总结。最终效果就在页面右下角，相信眼不尖的人也注意到了。 索引 分解步骤 执行步骤 完整代码 分解步骤 要完成这个案例，我们先来分解实现过程，再按步骤一步一步来实现。 首先实现整体界面和骰子的基本界面，一共有六个面，包括面和点的基本样式。 然后实现每个面上的骰子点数排列布局，完成所有的界面。 使用 transform 实现立体形状，给骰子添加立体效果。 为骰子添加旋转动画效果。 执行步骤1. 基本界面 这一步很基础，直接看代码。 1234567891011121314151617181920212223.dice-content &#123; position: relative; margin: 50px auto; width: 200px; height: 200px;&#125;.dice-section &#123; position: absolute; top: 0; left: 0; width: 200px; height: 200px; background-color: #e8e8e9; border: 1px solid #e0e0e0; border-radius: 15px;&#125;.dice-point &#123; width: 50px; height: 50px; border-radius: 50%; box-shadow: inset 3px 3px 5px black; background-color: #333;&#125; 123456789101112131415161718&lt;div id=\"dice\" class=\"dice\"&gt; &lt;div class=\"dice-content\"&gt; &lt;div class=\"dice-section\"&gt; &lt;!-- 这里为了使代码区分明显，点数用 span 来实现，因为在 flex 布局下它会以块级元素方式呈现 --&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"dice-section\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"dice-section\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 4、5、6等等 --&gt; &lt;/div&gt;&lt;/div&gt; 这是包了六个面的骰子的 div, 每个面的位置以绝对定位重叠在同一位置，便于之后修改。然后我在外层再放了一个 div 来实现定位、透视等效果，这点后续会再提到。 2. 点数排布 骰子每个面上的点数不一，每个面里面的点数的排列因此也不一样，但排列都是依循一定的规律。所以非常适合用 flex 布局来实现。 在点数布局中，我们主要使用了以下几个属性来实现——flex-direction、justify-content、align-item. 点数为 1 的情况最为简单，只要实现垂直居中。而 flex 实现垂直居中非常方便。align-items指定了 flex 容器中项目的对齐方式。所以父元素设置居中，子元素设置 auto 即可。 1234567.dice-section &#123; display: flex; align-item: center;&#125;.dice-point &#123; margin: auto;&#125; 点数 4 和 点数 6 的实现方式类似，首先它们被分割成 2 行。然后分别排列点数，分别显示在每一行的两侧。 123456789.dice-section &#123; display: flex; flex-direction: column; justify-content: space-around;&#125;.dice-section-row &#123; display: flex; justify-content: space-around;&#125; 12345678910&lt;div class=\"dice-section\"&gt; &lt;div class=\"dice-section-row\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"dice-section-row\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 我们使用 space-around 项让行内元素均匀分布在行内。 这里值得注意的是我们对行也做了同样的处理，只不过是用 column 换了个方向，让行上下均匀分布在面上，撑满整个面，否则会挤在一块。 然后点数 2 和 点数 3 的实现方式类似，它们被分割成 2 行和 3 行。然后分别排列点数，分别显示在左中右的位置。 1234567891011121314151617.dice-section &#123; display: flex; flex-direction: column; justify-content: space-around;&#125;.dice-section-row-start &#123; display: flex; justify-content: flex-start;&#125;.dice-section-row-center &#123; display: flex; justify-content: center;&#125;.dice-section-row-end &#123; display: flex; justify-content: flex-end;&#125; 123456789101112&lt;!-- 以点数 3 为例 --&gt;&lt;div class=\"dice-section\"&gt; &lt;div class=\"dice-section-row-start\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"dice-section-row-center\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"dice-section-row-end\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; flex-start、center、flex-end表明行内元素分别从行首、行中、行尾开始排列，这样使得点数正好分别排在行内的左中右位置。 同理，点数 5 的排列则是结合了 space-around 和 center 来实现。 到这里点数的骰子的界面基本完成，接下来是给骰子加上立体效果。 3. 立体效果 有两种方式可以让元素以 3D 效果方式呈现。 给父元素添加 transform-style: preserve-3d 告诉元素以 3D 方式呈现。它会影响子元素的呈现。 给父元素添加 perspective 属性，这个属性就是眼睛离画布的距离，值越小离画布越近，效果越明显(头越晕)。通常设置一个较大值来观察，这样更加清楚。 这里我们采用第一种方式。然后开始对每个面加以处理。 在旋转前需要一个原点作为参数，元素会围绕这个点旋转，在这里这个点是立方体的正中心。 1transform-origin: 50% 50% 0; /* 也是默认值 */ 我们使用 transform 属性的 rotate 来实现旋转，用 translate 来实现平移。 6个面里，前后面的改动是最小的。围绕着原点，那么正面需往前平移，然后背面要离正面一个面的长度大小，所以背面沿三维面的 Z 轴向后平移。 123456.dice-pos-front &#123; transform: translateZ(100px);&#125;.dice-pos-back &#123; transform: translateZ(-100px);&#125; 上下面的显示应当是沿 X 轴旋转，然后再位移，需注意旋转后基准的坐标系也变了，看似是上下沿着 Y 轴位移，实际是参照旋转前的 Z 轴位移。 123456.dice-pos-top &#123; transform: rotateX(90deg) translateZ(100px);&#125;.dice-pos-bottom &#123; transform: rotateX(90deg) translateZ(-100px);&#125; 左右面也是类似的道理。 123456.dice-pos-left &#123; transform: rotateY(90deg) translateZ(100px);&#125;.dice-pos-right &#123; transform: rotateY(90deg) translateZ(-100px);&#125; 到这里，一个完整的立方体效果应当出来了。但界面上可能还看不出，我们给这个立方体旋转一定角度，让它呈现得更立体一些。 123.dice-content &#123; transform: rotateX(-30deg) rotateY(-40deg);&#125; 效果如下: 4. 动画效果 css3 的动画从关键帧 keyiframe 开始，定义初始状态和结束状态。然后加以应用。 1234567891011121314/* 定义一个名为 rotate 的动画 */@keyframe rotate &#123; from &#123; transform: rotateX(-30deg) rotateY(-30deg) &#125; to &#123; transform: rotateX(180deg) rotateY(360deg) &#125;&#125;/* 然后应用，配置动画时长，动画效果等参数 */.dice-content &#123; animation: rotate 10s infinite;&#125; 到这里，最基本的一个旋转的骰子就实现了。 我们还可以通过 animation 的其他属性为这个旋转添加一点速度效果。 源码 我将常用的样式类提取了出来。 添加了 perspective 来增强效果。 添加 animation-timing-funtion 在各关键帧切换时添加速度效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;🎲&lt;/title&gt; &lt;style&gt; .flex &#123; display: flex; &#125; .flex-column &#123; flex-direction: column; &#125; .jc-c &#123; justify-content: center; &#125; .jc-sa &#123; justify-content: space-around; &#125; .jc-fs &#123; justify-content: flex-start; &#125; .jc-fe &#123; justify-content: flex-end; &#125; .dice &#123; perspective: 1000px; &#125; .dice-content &#123; /* 设定一个初始角度值以便查看效果 */ transform: rotateX(-30deg) rotateY(-40deg); position: relative; margin: 50px auto; width: 200px; height: 200px; transform-style: preserve-3d; -webkit-transform-style: preserve-3d; transform-origin: 50%; -webkit-transform-origin: 50%; animation: rotate 7s infinite; -webkit-animation: rotate 7s infinite; animation-timing-function: ease; -webkit-animation-timing-function: ease; &#125; .dice-section &#123; position: absolute; top: 0; left: 0; width: 200px; height: 200px; background-color: #e8e8e9; border: 1px solid #e0e0e0; border-radius: 15px; &#125; .dice-point &#123; width: 50px; height: 50px; border-radius: 50%; box-shadow: inset 3px 3px 5px black; background-color: #333; &#125; /* 前后面不做翻转，只在 Z 轴坐标系上平移 */ .dice-pos-front &#123; transform: translateZ(100px); &#125; .dice-pos-back &#123; transform: translateZ(-100px); &#125; /* 上下面是沿 X 轴翻转并位移, 从效果上看是沿 Y 轴平移，但因为加了翻转效果，其实是在 Z 轴上平移 */ .dice-pos-top &#123; align-items: center; transform: rotateX(90deg) translateZ(100px); &#125; .dice-pos-top .dice-point &#123; margin: auto; background-color: red; box-shadow: inset 3px 3px 5px #333; &#125; .dice-pos-bottom &#123; transform: rotateX(90deg) translateZ(-100px); &#125; /* 左右面是沿 Y 轴翻转并位移, 从效果上看是沿 X 轴平移，但因为加了翻转效果，其实是在 Z 轴上平移 */ .dice-pos-left &#123; transform: rotateY(90deg) translateZ(-100px); &#125; .dice-pos-right &#123; transform: rotateY(90deg) translateZ(100px); &#125; /* 定义一个名为 rotate 的动画 */ @-webkit-keyframes rotate &#123; 0% &#123; transform: rotateX(-30deg) rotateY(-40deg) &#125; 35% &#123; transform: rotateX(180deg) rotateY(360deg) &#125; 75% &#123; transform: rotateX(-90deg) rotateY(-180deg) &#125; 100% &#123; transform: rotateX(30deg) rotateY(40deg) &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 纯 css3 实现 🎲 --&gt; &lt;div id=\"dice\" class=\"dice\" title=\"🎲 点我就消失\"&gt; &lt;div class=\"dice-content\"&gt; &lt;!-- 1 --&gt; &lt;div class=\"dice-section dice-pos-top flex\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 2 --&gt; &lt;div class=\"dice-section dice-pos-left flex flex-column jc-sa\"&gt; &lt;div class=\"flex jc-fs\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-fe\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3 --&gt; &lt;div class=\"dice-section dice-pos-front flex flex-column jc-sa\"&gt; &lt;div class=\"flex jc-fs\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-c\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-fe\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 4 --&gt; &lt;div class=\"dice-section dice-pos-back flex flex-column jc-sa\"&gt; &lt;div class=\"flex jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 5 --&gt; &lt;div class=\"dice-section dice-pos-right flex flex-column jc-sa\"&gt; &lt;div class=\"flex jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-c\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 6 --&gt; &lt;div class=\"dice-section dice-pos-bottom flex jc-sa\"&gt; &lt;div class=\"flex flex-column jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"flex flex-column jc-sa\"&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;span class=\"dice-point\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 参考: 1. transform(web) 2. transform(css) 3. flex","link":"/jo.github.io/2017/09/23/css3d-study/"},{"title":"eslint有关import/prefer-default-export报错的解决","text":"今天在配置eslint发现一个神奇的问题——采用airbnb风格的检查时有一个报错 error Prefer default export ...... import/prefer-default-export 查了半天资料终于发现如何解决。 解决 原来是这样 123export function runBlock($log) &#123; $log.debug('runBlock end');&#125; 运行eslint检查的时候一直会报错 error Prefer default export ...... import/prefer-default-export 查询了一些资料后发现是因为,这个单一接口并不是设置为默认的。需要添加参数default。 更改后如下 123export default function runBlock($log) &#123; $log.debug('runBlock end');&#125; 具体原因有待详细追究。目前认为是当输出只有一个变量时，需要添加default。 参考 es6… eslint-plugin-import","link":"/jo.github.io/2016/08/08/eslint-about-import-prefer-default-export/"},{"title":"微信支付开发日志","text":"曾经有一项需求，是从移动端的H5页面请求微信支付功能。微信的文档写地较为混乱，在这里写个防坑指南。 支付的坑1.微信支付的文档不止一个。 在官方的文档里，有一段简单的关于微信支付的说明。调用wx.chooseWXPay方法启用。但是在这个文档之下，有另一个开发文档微信支付开发文档 这个文档里也有一个支付调用的方法weixinJSBridge，但是只能在微信浏览器里使用，非常不方便。本人测试从未成功过，所以建议放弃。 2.wx.chooseWXPay方法的传入参数和签名 该方法发起请求时是没有appId参数的，但是在生成paySign签名的时候，需要有appId和它的值。这里的I是大写的i。 生成paySign的时候的timeStamp是大写的，和传入的参数不一样，传入的是小写。 3.服务端的工作？！ 由于微信文档里没有说明哪些是前端工作哪些是后端，所以在一开始开发时我做了很多服务端做的事。比如生成signature, paySign.两者不一样。 生成签名的工作前端也是可以做的，但是要发起很多异步请求，处理非常多的回调，简直是回调地狱，而且不安全。最后服务端的伙伴处理了第一个签名。 注意两个access_token的不同。 微信公众号的准备工作1.微信公众号开通微信支付功能。 微信公众平台 微信支付-开发配置里配置支付授权目录。 正式授权目录可以添加多个，测试时只能添加一个。 不允许添加端口。只支持默认80端口。 目录即为调用微信支付空间的页面所在的目录。 将个人的微信号加到支付的白名单里，只有白名单里的用户才可以支付，但没想到付的是真钱。 同一个页面里，选择开发者配置，找到接口权限表。 网页授权用户基本信息。 这个url是用户回调的url,即开启微信支付控件页面的url,这个值即是redirect_url的值。 要记得encodeUrl转码。 进入公众号设置，功能设置 对js安全域名做设置。 这个值只能设置一个且似乎改动次数有限制。所以要小心改动。 上线前记得切换。 开发者中心里的配置项。 获取appId, secret等相关信息。 还有mch_id和key。 这些数据都不推荐写在前端页面里。 使用步骤 打开微信页面，从服务端的回调url里获取access_token, openId. 须服务端通过code验证等，然后返回。 获取wx.config配置需要的signature, 传递随机数nonceStr，时间戳timestamp等参数给服务端生成签名。 wx.config接口注入权限验证配置——通过signature等验证后。 通过openId获取prepay_id。 前端生成另一个签名paySign, 然后调用wx.ready里wx.chooseWXPay的方法调起支付。 Show Your the Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// ES6、jquery结合的写法.class WxpayCtrl &#123; constructor() &#123; this.access_token = this.getUrlParams().access_token; this.openId = this.getUrlParams().openId; this.appId = 'skidfoislkdrehjkgrg'; this.key = 'sdkjgfgkgkhjishiduh'; &#125; /** * [getUrlParams 获取url的参数 querystring] * @return &#123;Object&#125; [一个url参数键值配对的对象] */ getUrlParams() &#123; const url = window.location.search; const queryString = new Object(); if (url.indexOf('?') !== -1) &#123; let str = url.substr(1); let strs = str.split('&amp;'); for (let i = 0; i &lt; strs.length; i++) &#123; queryString[strs[i].split('=')[0]] = decodeURI(strs[i].split('=')[1]); &#125; &#125; return queryString; &#125; /** * [createTimestamp 时间戳] * @return &#123;String&#125; [description] */ createTimestamp () &#123; return parseInt(new Date().getTime() / 1000) + ''; &#125; /** * [createNonceStr 随机字符串] * @return &#123;String&#125; [description] */ createNonceStr() &#123; return Math.random().toString(36).substr(2, 15); &#125; /** * [getSignature 获取授权签名] * @return &#123;String&#125; [description] */ getSignature() &#123; const promise = new Promise((resolve, reject) =&gt; &#123; const data = &#123; nonceStr: this.createNonceStr(), timestamp: this.createTimestamp(), url: window.location.href.split('#')[0], access_token: this.accessToken &#125;; $.ajax(&#123; url: `$&#123;url&#125;/wechat/getSignature`, type: 'POST', data: JSON.stringify(data) &#125;) .done((res) =&gt; &#123; resolve(res); &#125;) .fail((err) =&gt; &#123; reject(err.message); &#125;); &#125;); return promise; &#125; /** * [getPrepayId 用openId获取prepay_id， 和服务端协调后决定queryString] * @param &#123;Number&#125; cash [消费金额] * @return &#123;String&#125; [description] */ getPrepayId (cash=100) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; const data = &#123; amount: cash, openId: this.openId, type: 'JSAPI', nonceStr: this.createNonceStr() &#125;; $.ajax(&#123; url: `$&#123;url&#125;/wechat/getPrepayId`, type: 'POST', data: JSON.stringify(data) &#125;) .done((res) =&gt; &#123; resolve(res.content); &#125;) .fail((err) =&gt; &#123; reject(err.message); &#125;); &#125;); return promise; &#125; /** * [weiPay 微信支付，验证加最终支付] * @param &#123;String&#125; prepay_id [description] */ weiPay(prepay_id) &#123; // 随机生成随机数，在不同地方调用的时候是不一样的，尤其注意！！！ const nonceStr = this.createNonceStr(); const stringA = `appId=$&#123;this.appId&#125;&amp;nonceStr=$&#123;nonceStr&#125;&amp;package=prepay_id=$&#123;prepay_id&#125;&amp;signType=MD5&amp;timeStamp=$&#123;this.createTimestamp()&#125;`; const stringSignTemp = `$&#123;stringA&#125;&amp;key=$&#123;this.key&#125;`; const sign = md5(stringSignTemp).toUpperCase(); wx.chooseWXPay(&#123; timestamp: this.createTimestamp(), nonceStr: nonceStr, package: `prepay_id=$&#123;prepay_id&#125;`, paySign: sign, signType: 'MD5', success: (res) =&gt; &#123; if (res.errMsg === 'chooseWXPay:ok')&#123; window.location.href = 'success.html'; &#125; &#125;, fail: () =&gt; &#123; window.alert('支付失败！'); window.location.href = 'fail.html'; &#125;, cancel: () =&gt; &#123; window.location.href = 'cancel.html'; &#125; &#125;); &#125; /** * [weixinPay 调起微信支付] * @return &#123;[type]&#125; [description] */ weixinPay(cash) &#123; this.getSignature() .then((signature) =&gt; &#123; /** * [appId 微信支付的相关配置,通过config接口注入权限验证配置] */ wx.config(&#123; // debug: true, // 该选项仅用于调试 appId: this.appId, timestamp: this.createTimestamp(), nonceStr: this.createNonceStr(), signature: signature, jsApiList: ['chooseWXPay'] &#125;); wx.ready(() =&gt; &#123; this.getPrepayId(cash) .then((prepay_id) =&gt; &#123; this.weiPay(prepay_id); &#125;) .catch((err) =&gt; &#123; window.alert(err); &#125;); &#125;); &#125;) .catch((err) =&gt; &#123; window.alert(err); &#125;); &#125;&#125; 虽然这里有很多回调，代码也略凌乱，但它work了！ 当然有更好的方案，但紧急需求要求下这是较快的实现方式了。再次对接可让生成签名的工作移交服务端！ PS：经过这次对接微信支付文档后，对微信的开发失去了信心。然后对微信推出的小程序也坚持保守态度。 参考：* 接入微信支付流程清晰版","link":"/jo.github.io/2016/12/22/fck-wechat-pay/"},{"title":"如何在git仓库中彻底清除大文件","text":"坑的由来事情是这样的，相信每个公司都有自己的官网。我们也不例外，而由于历史及各种不具名的原因，我司先前的程序猿哥哥将许多视频放在了代码仓库里。结果可想而知，原本只有代码的仓库突然间变得无比臃肿(或者是慢慢臃肿)，从早期的几十MB,迅速飙升至1G以上。眼看要挤爆服务器。这时我们总监看不下去了，大手一挥删了所有视频。仓库眼看瞬间缩小。但是，理论上是该缩小的，直到你不经意间瞄了眼——又多了一个G，这时你紧张了，慌了，明明删了视频，怎么仓库竟还变大了。这一期，让我们走进git,细细体会git带给我们的欢乐与忧愁。 关于git 每个人都会有过去，git也不例外。git是个什么东西 到底发生了什么早些时候我对git的原理并不是很了解，只是随着日常使用，终于开始理解git其实是一个指针指向一次提交的对象，当你在各个分支间切换的时候，指针就随之切换，版本也随之更改。 那么，git 是如何做到的能在各个版本间无缝切换的呢。即使long long ago的代码，只要来一句git reset --hard sesd54f54sdf5sd4sd5f 照样给你打回原形。 真相只有一个，那就是其实所有的版本，不管是否存在了多久，都仍然存在于硬盘里。所以你才可以任性地对代码为所欲为。然而，为所欲为也要付出代价。 代价就是，你删了几次，就会有几个快照存在于硬盘里。删一个大视频，表面上少了500M空间，实则增加了一次至少500M的历史提交记录，虽然现在的代码仓库里不再有这个视频，但是你试试du -sh .git看看.git 文件大小，是不是有惊喜？我在这儿体会的最恐怖的一次，见证了3个多G的.git。 如何 solve it 首先我们看看git相关文件占用的空间，运行git count-objects -v 12345678count: 35size: 4404in-pack: 20775packs: 1size-pack: 1502667prune-packable: 0garbage: 1size-garbage: 136679 size-pack以千字节为单位表示，那么这里就有1.5G大小，这对代码仓库来说可是个恐怖的数字了。 那么让我们来找出罪魁祸首——到底是哪些大文件在混淆视听。 将所有含这些大文件的历史提交记录，一个不漏的找出来。 git verify-pack可以识别出大对象，使用sort参数对输出的5列信息排序，再进行定向 运行git verify-pack -v .git/objects/pack/pack-15esdkfdksjfd...asd.idx | sort -k 3 -n | tail -5 如果你的仓库确实有点臃肿的话，让代码飞一会儿。 得到以下结果: 12345b9e5fc1ea2a87e95ddea6fed47f29c184595485b blob 70580712 62447447 1360078567b8b3833e7f8e8207033b9f7e34e497a3207ecae2 blob 103319718 102366768 1157294281bc4f928a65692d19ab8d9378778463c13be7204c blob 117527265 117467079 102672811152565aeb9009bb4d07ca8d7c130425d9bf31f7b2 blob 201567615 181006235 78816222498c5dc977918aaf3b45a999ae92e031b4b15191b blob 590381017 589431074 198731150 unbelievable!都是huge的文件!最底下的那家伙，到底是什么啊！ 让我们用rev-list命令来查看commit 的 SHA值和文件路径： git rev-list --objects --all | grep 98c5dc9779 198c5dc977918aaf3b45a999ae92e031b4b15191b public/video/feng-mv.mp4 这次倒很快，答案揭晓——是公司宣传视频。我们明明有七牛。这玩意儿就不该出现在这里。 再来看看所有包含这家伙的提交历史: git log --pretty=oneline --branches -- public/video/feng.mp4 129364a4f65f03d3a6d0873106ba21bd3172418176 chore: 删除视频文件da24a01e46876a495518f9617501b4b360177f2b improve(官网首页) 一个大文件的一删一减两个操作，就会占据很多空间，更何况还有其他的较大文件。 找到了根源所在，是时候让我们大干一场: git filter-branch --index-filter &#39;git rm --ignore-unmatch --cached public/video/feng.mp4&#39; -- da24a01^.. 使用filter-branch重写所有相关的提交历史。 index-filter 修改暂存区域或索引。 git rm --cache 从git仓库里删除文件。 ignore-unmatch 忽略不匹配文件的提交记录，不会抛出错误。 最后一个哈希值指重写从这次提交开始的所有提交记录，避免索引所有的提交历史 好了，开始运行吧。一阵眼花缭乱的滚动之后，它宣布重写完成。 123...Rewrite 38f2b11070b7e21cbce465b5f6b384156e3a8e61 (475/475)Ref 'refs/heads/master' was rewritten 此时的历史提交记录中已经不再会有指向那位大文件的引用了。 但仍然需要以下两条命令来删除refs对他的引用(关于这部分的理解我也有待深究)。 你的历史中将不再包含对那个文件的引用。 不过，你的引用日志和你在 .git/refs/original 通过 filter-branch 选项添加的新引用中还存有对这个文件的引用，所以你必须移除它们然后重新打包数据 库。 在重新打包前需要移除任何包含指向那些旧提交的指针的文件: 123456789rm -Rf .git/refs/originalrm -Rf .git/logs/git gcCounting objects: 21406, done.Delta compression using up to 4 threads.Compressing objects: 100% (9323/9323), done.Writing objects: 100% (21406/21406), done.Total 21406 (delta 11867), reused 20640 (delta 11348) 再看看节约了多少空间: 12345678910git count-objects -vwarning: garbage found: .git/objects/pack/tmp_pack_zG7GCbcount: 154size: 4884in-pack: 21406packs: 1size-pack: 1502752prune-packable: 0garbage: 1size-garbage: 136679 尽管表面上看去没有什么软用，但是当我运行du -sh .git查看大小时，发现. git文件夹确实缩小了。 现在这个视频文件存在于松散对象(size)中。虽然它没有彻底消失，但已经不再出现于推送或克隆中。 如果需要彻底移除，运行git prune --expire now。 再次查看 git count-objects -v。 小结 讲道理走到这一步应当是成功了，只是刚才运行git count-objects -v的结果并不那么尽如人意，它并没有缩减的很明显。 这点在以后解决成功时再另起一篇。 最后一点–作为一个前端攻城狮，可不能什么都往城墙里放啊!!!","link":"/jo.github.io/2016/07/17/how-to-clear-huge-files-in-git/"},{"title":"如何清除input元素自定义样式","text":"有注意到input在不同状态下，或者不同浏览器下都会有显示的问题。例如ios下的浏览器里input有边框显示问题，设置input属性appearance为none即可解决。但input仍然留下许多样式坑。 input(type=number)样式问题 当type的值设置为number时，聚焦状态下会出现一个小边框，如下图： 因强迫症和需求以及正常的审美观要求，一致确定去掉这个丑陋的多余项。 查阅部分资料后找到解决办法如下： 1234567input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; -moz-appearance: none; appearance: none; margin: 0; // Apparently some margin are still there even though it's hidden -清除margin。&#125; 原理就是关闭input自带的number按钮选项。 input作为表单自动提交时 当input作为表单时，会自动记录之前的填写项，并自动补充，如果选择自动补充的选项，而且本身给input设置了样式时。画面就会非常唯美（丑陋）。 这里有两种解决方案： 1.修改自动填充的样式（推荐）: 12345678910111213// 使用以下样式来覆盖原有的，更改了背景和字体颜色input: -webkit-autofill,textarea: -webkit-autofill,select: -webkit-autofill &#123; -webkit-box-shadow: 0 0 0 1000px #323339 inset; -webkit-text-fill-color: white;&#125;// 覆盖以下的chrome自带样式input: -webkit-autofill, textarea: -webkit-autofill, select: -webkit-autofill &#123; background-color: rgb(250, 255, 189); background-image: none; color: rgb(0, 0, 0);&#125; 原理是通过打补丁来解决自定义样式——是不是优雅了很多~ 2.通过关闭表单的自动填充功能来彻底根除该问题： 1&lt;input type=\"number\" autocomplete=\"off\"/&gt; 这样就连提示也没有了~也是种解决办法。 参考：Turn Off Number Input Spinners","link":"/jo.github.io/2016/10/01/how-to-clear-input-style/"},{"title":"初识 Threejs(下) —— 实现一个太阳系模型","text":"在上一篇文章中，我整理了 Threejs 中的一些基本概念。现在这一篇，就使用上次所整理的内容加上一些不复杂的算法，来实现一个运转着的太阳系模型。这里的所有行星大小及公转时间，尽量贴合实际。 索引 实现思路 场景初始化 创建行星 创建轨道 创建文本 行星添加公转效果 行星添加光照效果 鼠标交互事件 实现思路 这篇文章于早前发出，收到了前辈的指教。反思后发现确实后面的内容比较流水账，欠缺一个思路的总结和梳理，而只是一味实现。这里我先将整体的实现方案梳理出来，接着我们再分解并一步步去实现它。 我将其主要分为两个部分，静态的实现，以及动态的鼠标交互。 静态实现 太阳系模型的核心是八大行星围绕着太阳做公转运动。涉及到两点，一是运动，二是公转。运动使用动画即可完成。至于公转，实际上行星的运转是做椭圆周运动，我们在这里将其简化为圆周运动，那么核心就是计算圆周运动的坐标点。 那么实现这个静态的太阳系模型就有一定的思路了，首先我们用球体初始化行星，按照距离远近摆放在场景中。然后添加环状图形来当做轨道，辅助观察。接着文本采用外部引入的方式，加载后位置基本与行星相同，减去一定大小将其放在正上方。最后，将行星按照计算出的坐标信息，每一帧去设置位置。最终的效果就是动态的公转效果。 这里有几点值得注意： 字体在 Threejs 中需要另外加载，格外引入。 行星的初始化位置可以用随机的方式来分布，使其更真实。当然，有精力的话可以参考实际去计算坐标，摆放接近真实的位置。 后来在行星中添加了月亮，涉及的计算就是把以太阳左标为原点改为了以地球坐标为原点，其他计算方式则相同。 为行星添加光照效果，就是在太阳的位置上放一个点光源，然后在周围的地方摆放一个环境光光源优化视觉效果。 采用图片纹理的方式优化行星的视觉效果。 动态交互 场景基本完成后。我会添加一个鼠标交互，即鼠标移到行星位置上时，显示行星的名字。 这里主要的复杂点在于坐标系的转化。3d 的坐标系和浏览器平时的坐标系原点及坐标位置不一。这点在下文我详细说明。 场景初始化 首先，创建一个场景用来渲染这一切。 123456let scene = new THREE.Scene()let renderer = new THREE.WebGLRender()let camera = new THREE.Perpestive(40, this.el.clientHeight / this.el.clientWidth, 1, 500)renderer.setSize(this.el.clientHeight, this.el.clientWidth)this.el.appendChild(renderer.domElement)renderer.render(scene, camera) 创建行星 初始化各大星球，即创建球体。在参考了真实大小和距离后，我们尽量按接近真实的比例来创建。 首先我们创建一个对象数组来保存各星球的相关数据。包括名字，大小，位置，颜色等等属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const planets = [&#123; name: 'Sun', size: [5, 16, 16], dis: 0, pos: [0, 10, 0], color: 0xFFFFFF,&#125;, &#123; name: 'Mercury', size: [0.4, 10, 10], dis: 4, pos: [0, 10, 9], color: 0xFFFFFF, rev: 0.3,&#125;, &#123; name: 'Venus', size: [0.85, 10, 10], dis: 7.5, pos: [0, 10, 12.75], color: 0xFFFFFF, rev: 0.6,&#125;, &#123; name: 'Earth', size: [1, 10, 10], dis: 10, pos: [0, 10, 15], color: 0xFFFFFF, rev: 1,&#125;, &#123; name: 'Moon', size: [0.4, 10, 10], dis: 1, pos: [0, 10, 17], color: 0xC0C0C0, rev: 0.2,&#125;, &#123; name: 'Mars', size: [0.6, 10, 10], dis: 15, pos: [0, 10, 20], color: 0xFFFFFF, rev: 1.8,&#125;, &#123; name: 'Jupiter', size: [4, 32, 32], dis: 20, pos: [0, 10, 25], color: 0xFFFFFF, rev: 5&#125;, &#123; name: 'Saturn', size: [3, 32, 32], dis: 25, pos: [0, 10, 30], color: 0xFFFFFF, rev: 10&#125;, &#123; name: 'Uranus', size: [2, 32, 32], dis: 30, pos: [0, 10, 36], color: 0xFFFFFF, rev: 15&#125;, &#123; name: 'Neptune', size: [1.8, 32, 32], dis: 35, pos: [0, 10, 45], color: 0xFFFFFF, rev: 0.5&#125;] 根据这些属性，我们再用形状和材质来创建球体。 12345function initPlanet(size, color) &#123; const sphereGeometry = new THREE.SphereGeometry(...size) const sphereMaterial = new THREE.MeshBasicMaterial(&#123; color &#125;) return new THREE.Mesh(sphereGeometry, sphereMaterial)&#125; 这里我采用遍历数组的数据的方式来依次创建球体。并用一个 THREE.Group 对象来统一保存。 在初始化的数据里，我们可以拿到位置等信息，在这里给球体也加上相应的位置。 123456789101112function initPlanets() &#123; let planetsGroup = new THREE.Group() planets.map((planetObj) =&gt; &#123; const planet = initPlanet(planetObj.size, planetObj.color) planet.name = planetObj.name planetsGroup.add(planet) &#125;) return planetsGroup&#125;const planetsGroup = this.initPlanets()scene.add(planetsGroup) 场景中添加球体物体后，理论上应该能看到九个球体了。但是，这里只能见到一个球体。因为像机的默认视角是正对着球，而此时的球的位置正好连成一条线。我们来调整一下，让相机从高处俯视。 12camera.position.set(0, 10, 20)camera.lookAt(scene.position) 创建轨道 为了更清晰得看清行星运转，我们添加一些轨道线来辅助。 所用的是 RingGeometry 几何形状。创建的方式类似行星。 但是需要注意的是，创建的环默认是垂直于水平面的，我们需要将它做一个旋转，转到水平面上来。 1234567891011121314151617181920212223function initTrack(size, color) &#123; const ringGeometry = new THREE.RingGeometry() const ringMaterial = new THREE.MeshBasicMaterial(&#123; color &#125;) return new THREE.Mesh(ringGeometry, ringMaterial) // todo&#125;// 统一创建 function initTracks()&#123; let tracksGroup = new THREE.Group() planets.map((planet) =&gt; &#123; const outer = planet.pos[2] const inner = outer - 0.05 const size = [outer, inner, 100] const track = this.initTrack(size, 0xffffff) track.rotation.x = Math.PI * 0.5 track.position.set(0, 10, 0) tracksGroup.add(track) &#125;) return tracksGroup&#125;const tracksGroup = this.initTracks()scene.add(tracksGroup) 这样就可以在场景中看到行星在轨道上了。 创建文本 我们使用文本来标识行星的名字，位置在行星正上方。 THREE 创建文本需要先加载字体。通常使用字体是先通过官方的方法加载 json 文件。 1234const textLoader = new THREE.FontLoader()textLoader.load('./assets/fonts/helvetiker_regular.typeface.json', (font) =&gt; &#123; // do sth&#125;) 在自己的案例中，parcel 打包后似乎没有静态文件目录，于是这里了解了下 THREE.Font 部分代码后，发现只需要重新构造一个就可以。 1234567891011121314151617import Font from './assets/fonts/helvetiker_regular.typeface.json'const font = new THREE.Font(Font)// 封装一下function loadFont() &#123; return new THREE.Font(Font)&#125;// 除去字体包以外，字体还有一些必要的样式function initFont() &#123; return Object.assign(&#123; size: 0.5, height: 0, curveSegments: 12, bevelEnabled: false, bevelThickness: 1, bevelSize: 0.8 &#125;, &#123; font: loadFont() &#125;)&#125; 最终创建文本的方式和其他物体相似，也是形状和纹理。 12345function initText(content) &#123; const textGeometry = new THREE.TextGeometry(content, initFont()) const textMaterial = new THREE.MeshBasicMaterial(&#123; color: 0xffffff &#125;) return new THREE.Mesh(textGeometry, textMaterial)&#125; 最后，只要让文本使用对应行星的位置，再做一些小小的位移即可。 行星添加公转效果 在场景里添加以上图形后，我们能看到部分物体了，虽然可能位置有部分重叠。现在我们来给每个行星添加动态效果，让所有行星运转。 公转的本质是改变行星的坐标位置，每一帧进行一次重定位，那么球体看起来就是运动的。 这里的公转，就是围绕太阳做圆周运动，以太阳为中心，距离为半径，圆周上的点就是位置。所以每个行星的位置计算就是半径和弧度的计算。 例如距离为 5 的星球，圆周长则为 2π * r, 即 Math.PI * 2 * 5，计算每帧的弧度则为 2π * r / 60 / 60 / r 即 Math.PI * 2 * 5 / 60 / 60 / 5. 所有行星在同一水平面，所以 y 的坐标固定，具体的位置就是 Math.sin(Math.PI * 2 / 3600) * r, 5, Math.cos(Math.PI * 2 / 3600) * r 因为每个行星的公转速度不一，所以我们再加一个变量来控制速度，整理后如下 123456789function calcSpeed(rev) &#123; return Math.PI * 2 / 3600 / rev&#125;// 然后来调用动画的函数里执行planetsGroup.children.map((planet) =&gt; &#123; planet.angle += calcSpeed(planet.rev) planet.angle = planet.angle &gt; 2 * Math.PI ? planet.angle - 2 * Math.PI : planet.angle planet.position.set(Math.sin(planet.angle) * planet.distance, 5, Math.cos(planet.angle) * planet.distance)&#125;) 文字的移动效果同行星，只是位置要在行星的上方，并且水平方向上减去文本大小的一半。 12const r = text &amp;&amp; text.geometry &amp;&amp; text.geometry.boundingSphere.radius || 0text.position.set(Math.sin(planet.angle) * planet.distance - r, 5 + 1, Math.cos(planet.angle) * planet.distance) 行星添加光照效果 为了使行星看起来更加真实，我们使用另一种材质来创建行星。并给太阳一个光照效果。 123456789// 受光照影响的材质const planetMaterial = new THREE.MeshLambertMaterial(&#123; color: 0x123321 &#125;)// 添加一个白色，光照强度为 1，光照距离为 100 的点光源，位置在太阳中心const pointLight = new THREE.PointLight(0xffffff, 1, 100)// 再添加一点环境光，使我们可以更清楚的观察所有行星const ambient = new THREE.AmbientLight(0xffffff, 0.7)pointLight.position.set(Sun.position)scene.add(pointLight)scene.add(ambientLight) 至此，一个有点像模像样的太阳系微缩模型完成了。 接下来我们为这个模型加点动态交互效果。 场景添加鼠标事件 我们在这里做一个较为简易的交互，即鼠标移到相应的行星上就显示该行星的名字。 3d 空间中，鼠标的交互事件的本质是获取鼠标点的坐标，然后转化为 3d 坐标系里的坐标，然后判断位置是否在物体内，然后做一些处理。 这部分的重点就在于将鼠标坐标转化为 3d 坐标系里的坐标。即坐标换算。 首先我们要创建一个鼠标对象，然后获取鼠标的坐标。 12345let mouse = new THREE.Vector2()function onDomMouseMove(event) &#123; console.info(event.clientX, event.clientY)&#125;this.el.addEventListener('mousemove', onDomMouseMove) 3d 坐标系的不同在于他是以场景中心作为原点的。而鼠标坐标是以左上角为原点的。转换后要将坐标赋值给鼠标对象。所以这里的坐标换算计算公式为： 123456789101112function onDomMouseMove(event) &#123; mouse.x = (this.el.clientX - (this.el.getBoundingClientRect().width / 2)) / (this.el.getBoundingClientRect().width / 2)&#125;mouse.y = - (this.el.clientY - this.el.getBoundingClientRect().height / 2)) / (this.el.getBoundingClientRect().height / 2)// 优化后function onDomMouseMove(event) &#123; const rect = this.el.getBoundingClientRect() const &#123; width, height &#125; = rect mouse.x = (2 * this.el.clientX - width) / width mouse.y = - (2 * this.el.clientY - height) / height&#125; 获取场景中的鼠标位置后。接下去就是判断位置是否在物体上。这里的逻辑是，由相机发往一个射线到鼠标位置处，期间相交的第一个物体就是鼠标点中的物体。即 raycatser 对象中。 1234567let raycaster = new THREE.Raycaster()raycaster.setFromCamera(mouse, camera)// 获取相交的所有物体const intersects = raycaster.instersectObjects(scene.children, true)if (intersects.length &gt; 0 &amp;&amp; intersects[0].object &amp;&amp; intersects[0].object instanceof THREE.Mesh) &#123; // do sth&#125; 现在我们已经能获取到鼠标位置所在的物体了。剩下是完成这个交互，先将文字默认隐藏，然后在鼠标滑过的时候再显示出来。 首先将文本存在同一个组里，便于查找。然后在鼠标滑过行星时，使用行星名字来找出对应的文本，然后显示。 1234567891011121314151617181920function initTexts() &#123; let textGroup = new THREE.Group() planets.map((planet) =&gt; &#123; let text = initText(planet.name) text.visible = false textGroup.add(text) &#125;) return textGroup&#125;// 显示文本逻辑if (intersects.length &gt; 0 &amp;&amp; intersects[0].object &amp;&amp; intersects[0].object instanceof THREE.Mesh &amp;&amp; intersects[0].object.name) &#123; const name = intersects[0].object.name scene.children.map((obj) =&gt; &#123; if (obj.name !== 'texts') &#123; return &#125; obj.children.map((text) =&gt; &#123; text.visible = text.name === name &#125;) &#125;)&#125; 到这儿一个差不多的太阳系模型就完成啦。 后续还可以给各行星的初始位置添加随机位置，给行星添加纹理效果，给土星加上土星环，给地球加上月亮，再加上些星星背景，那就挺好看了。 具体的代码在这里threejs-learning 最终效果 gif 显示的较为简陋。当然，更清楚的效果还是直接跑项目吧~","link":"/jo.github.io/2017/12/19/how-to-create-a-solar-system-using-by-threejs/"},{"title":"15 分钟快速上手 Parcel 中使用 React","text":"最近准备新开一个 Threejs 学习的坑，因为重点在 Threejs 上，所以想构建一个简易方便的环境。于是我自然而然的想到了最近火热的 parcel 来替代以往的 webpack. 在我自己尝试了之后，这简直比我想象中的还要简单方便——当然是指搭建一个基本环境啦。推荐：★★☆ 索引 确立技术栈 安装依赖 快速上手 技术栈 parcel 支持 node v8.0.0 +. 所以我们使用 node v8.0.0 当然也少不了框架 react. 所以使用 react 16.0.0+. npm 使用有些显老了，不如试试 yarn. 至于 parcel, 当然也是与时俱进用最新的了。 所以最终确认下技术栈和版本。 1234node v8.0.0react v16.2.0yarn v1.3.2parcel v1.4.1 安装依赖 mkdir [your project] —— 在一个合适的目录下新建个项目。 yarn init 初始化新项目，一顿回车后即完成。 PS： 如果 node 版本不够的话，先升级 node, nvm install v8.0.0 nvm use v8.0.0. 然后升级 yarn. 卸载后重装。npm uninstall -g yarn. 再 npm install -g yarn. 接下来是安装一些 react 依赖。 yarn add react@16.2.0 yarn add react-dom@16.2.0 yarn add prop-types 当然也少不了 babel 来编译 es6, es7 等。 yarn add babel-preset-env 用于 es6. yarn add babel-preset-react 用于 react. yarn add babel-preset-stage-0 用于 es7. 接着就是重头啦。 yarn add parcel-bundler@1.4.1 这顿操作之后，依赖已经加载完毕。 快速上手 配置 .babelrc 文件来使用 babel。 123&#123; \"presets\": [\"env\", \"react\", \"stage-0\"]&#125; 配置首页入口。 12345678&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 配置 js 文件。使用 react. 12345678910111213141516import React, &#123; Component &#125; from 'react'import ReactDOM from 'react-dom'import PropTypes from 'prop-types'class Hello extends Component &#123; static propTypes = &#123; name: PropTypes.string &#125; render() &#123; return &lt;div&gt; hello &#123; this.props.name &#125;&lt;/div&gt; &#125;&#125;const app = document.querySelector('#app')ReactDOM.render(&lt;Hello name='world'/&gt;, app) 这样就已经接近完成。 剩下的，只要在 package 中加上 scripts. 123\"scripts\": &#123; \"start\": \"parcel index.html\"&#125; 最终只要在项目下运行 npm start，再打开 open http://localhost:1234. 几乎是一眨眼的功夫，就可以看到 hello world 了。 是不是非常快捷而简单呢。 项目地址: threejs-learning附上官网链接: Parcel","link":"/jo.github.io/2018/01/07/how-to-use-parcel-with-react-in-15-mins/"},{"title":"从 zsh 到 fish, 让你的 shell 更可爱更友好","text":"前阵子关注到阮老师更新了一篇博文，内容是介绍一个 shell —— fish.自己去尝试之后发现确实值得推荐，准备当做主力 shell 来替代原有的 zsh. 索引 介绍 安装(想吃热豆腐的点这里) 介绍为什么抛弃 zsh 投向 fish 的怀抱 zsh 作为我的主力 shell 用了很久，而且没有什么做不到，那为什么我要抛弃呢。这并不是恋爱中的喜新厌旧。也并不是 zsh 不好，而是 fish 太好了。在简短的试用之后，我决定留下它。因为体验实在是太丝滑流畅了。 这里列几点最直观的感受。 1. 自动补全和自动建议 zsh 固然有着强大的自动补全命令。不过和 fish 相比，就是小巫见大巫了。fish 的命令，除了在自动补全以外，还会标记命令的对错，输入命令的正确与否，通过颜色显示地一目了然。这里因为配色的关系，颜色对比可能不明显，但仍可以看到，红色清楚的标识了无效命令。 下面这张图显示的是有效命令： 细心的朋友可能还发现了刚才图中灰色的完整命令。这属于 fish 的自动建议。下面这张图可能显示地更直观(点击查看大图)： 尽管 zsh 有着模糊匹配历史命令的功能，但显而易见，这里的 fish 在你输入第一个字母就知道你要做什么的体贴，让用户体验有了极大的提升。就像贴心的女友，知心的姐姐一样为你包办所有。 除此之外，fish 在匹配历史命令的同时，也能标识无效命令。红色醒目地标出： 2. 效率 使用终端 shell 的一大原因，就是效率高。有时有人问我，为什么明明有 git 图形化工具，却还要使用命令行。我想来想去，虽然图形化工具显示直观，但比起命令行，操作起来太慢，况且有许多命令并不支持。 那么既然使用 shell 本身就是为了提升效率，那怎么能忍受一个速度奇慢的 shell 呢。这里的两幅图清晰地说明了各自的效率： 在两种 shell 下连续按下回车键，可以看到以上两个结果。前者是 fish, 后者是 zsh. 可以看到后者有明显的卡顿。也许正是因为 zsh 过于强大，功能过多，导致运行起来奇慢无比。最终让我无法忍受。 小结 对我个人来说，以上两点足够我切换 zsh 到 fish 了。也许其他人有着自己的看法，但我目前还没有发现 fish 使我不爽的地方，因此近期会继续用下去。 安装和使用安装 fish 在 macOS 下，安装有多种方式，这里列出采用 homebrew 安装的方式，十分简便。 1$ brew install fish 安装成功后，输入 fish 后，就可以开启全新的奇妙历程了。 如果你已经迫不及待想要把他设为默认 shell 的话： 1chsh -s /usr/local/bin/fish 假如有提示说 fish 并不是标准 shell. 运行如下命令将 fish 加到系统的默认 shells 中。再运行上面的命令设置即可。 1echo /usr/local/bin/fish | sudo tee -a /etc/shells 设置完之后，重启你的 iterm/terminal, 就能看到全新的 fish shell 了！ 使用 fish 的基本配置在 ~/.config/fish/config.fish 文件里. 如果安装好 fish 后没有这个文件，可以新建一个。 fish 支持通过 web 界面更改配置文件。运行 fish_config 可查看。 可以通过更改如下配置来设置 fish 的问候语，它会在每次进入时输出。 1set fish_greeting 'Talk is cheap. Show me the code.' zsh 有许多好用的 alias, fish 同样可以。最快捷的方式也是在配置文件里直接输入，以下是我的 git alias. 如果你和我一样是前端，那么很有可能也使用 nvm 来管理 node. fish 没有相关的工具，不过可以通过更改配置来使其生效。 1bass source ~/.nvm/nvm.sh 也许你在 zsh 中安装了 thefuck 插件，是的，在 fish 中也可以使用。 12eval(thefuck --alias | tr '\\n' ';')alias fuck-it='export THEFUCK_REQUIRE_CONFITMATION=True; fuck; export THEFUCK_REQUIRE_CONFIRMATION=False' 也许你也装了 autojump 插件，是的，同样可以在这里使用。加入以下代码： 123456begin set --local AUTOJUMP_PATH $HOME/autojump/bin/autojump.fish if test -e $AUTOJUMP_PATH source $AUTOJUMP_PATH endend 这里主要是核对 autojump.fish 这个文件。路径对即可生效。 如果以上两个插件还未安装的话，首先使用 homebrew 安装即可，brew install thefuck, brew install autojump. 一些工具oh my fish 和 zsh 有着 oh my zsh 一样，fish 也有 oh my fish. 可以在终端中输入如下命令安装： 1curl -L https://get.oh-my.fish | fish oh my fish 通过运行 omf install [&lt;name&gt;/&lt;url&gt;] 来安装插件。例如运行 omf install ocean 安装主题。 omf list: 列出当前安装的包。 omf theme &lt;theme&gt;: 列出所有主题/应用某个主题。 omf remove &lt;name&gt;: 移除某个包。 fisherman fish 还有一个管理插件的工具 fisherman. 直接在终端中运行如下命令安装： 1curl -Lo ~/.config/fish/functions/fisher.fish --create-dirs git.io/fisher fisherman 通过运行 fisher &lt;name&gt; 安装插件。例如运行 fisher z. fisher ls: 查看当前插件。 fisher ls-remote: 查看所有插件。 fisher rm &lt;name&gt;: 移除插件。 总结 以上就是我使用 fish 的记录和基本教程。事实上还有很多地方可探索，不过到此为止日常使用是没有问题了。希望大家也可以在使用 fish 的过程中感到愉悦快乐！","link":"/jo.github.io/2017/05/21/introduce-fish-shell/"},{"title":"js诞生与ES6","text":"1.JavaScriptJavaScript，一种直译式脚本语言，是一种动态类型、基于原型的语言，内置支持类别。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。然而现在JavaScript也可被用于网络服务器，如Node.js。在1995年时，由网景公司的布兰登·艾克，在网景导航者浏览器上首次设计实现而成。因为网景公司与昇阳公司的营销合作，加上网景公司管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语义与Self及Scheme较为接近。为了获取技术优势，微软推出了JScript，与JavaScript同样可在浏览器上运行。为了统一规格，1997年，在ECMA（欧洲计算机制造商协会）的协调下，由网景、昇阳、微软和Borland公司组成的工作组确定统一标准：ECMA-262。因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。 2.JavaScript 定义一般来说，完整的JavaScript包括以下几个部分： ECMAScript，描述了该语言的语法和基本对象文档对象模型（DOM），描述处理网页内容的方法和接口浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口它的基本特点如下： 是一种解释性脚本语言（代码不进行预编译）。主要用来向HTML页面添加交互行为。可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。JavaScript常用来完成以下任务： 嵌入动态文本于HTML页面对浏览器事件作出响应读写HTML元素在数据被提交到服务器之前验证数据检测访客的浏览器信息控制cookies，包括创建和修改等 3.JavaScript 起源它最初由网景公司的布兰登·艾克设计。JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型(dom)，浏览器对象模型(bom)。 Netscape在最初将其脚本语言命名为LiveScript，后来网景在与昇阳公司合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时网景为了营销考虑与太阳微系统达成协议的结果。为了获取技术优势，微软推出了JScript来迎战JavaScript的脚本语言。为了互用性，Ecma国际（前身为欧洲计算机制造商协会）创建了ECMA-262标准（ECMAScript）。现在两者都属于ECMAScript的实现。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。 发展初期，JavaScript的标准并未确定，同期有网景的JavaScript，微软的JScript三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。 4.ECMAScript 与 JavaScript一个常见的问题是，ECMAScript和JavaScript到底是什么关系？ 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。 该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。在日常场合，这两个词是可以互换的。 5.ECMAScript历史与ES6ES6从开始制定到最后发布，整整用了15年。 前面提到，ECMAScript 1.0是1997年发布的，接下来的两年，连续发布了ECMAScript 2.0（1998年6月）和ECMAScript 3.0（1999年12月）。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习JavaScript，其实就是在学3.0版的语法。 2000年，ECMAScript 4.0开始酝酿。这个版本最后没有通过，但是它的大部分内容被ES6继承了。因此，ES6制定的起点其实是2000年。 为什么ES4没有通过呢？因为这个版本太激进了，对ES3做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。 2007年10月，ECMAScript 4.0版草案发布，本来预计次年8月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39委员会的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ES6，第六版发布以后，就指ES7。TC39的判断是，ES5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。 2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。 2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。 2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。 2015年6月，ECMAScript 6正式通过，成为国际标准。从2000年算起，这时已经过去了15年。 我们最常写的原生js即是基于ES3和ES5。目前所有主流浏览器都支持ES3、ES6。各大浏览器也在不断更新， 支持ES6。 6.ECMAScript 72013年3月，ES6的草案封闭，不再接受新功能了。新的功能将被加入ES7。 任何人都可以向TC39提案，从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。 Stage 0 - Strawman（展示阶段）Stage 1 - Proposal（征求意见阶段）Stage 2 - Draft（草案阶段）Stage 3 - Candidate（候选人阶段）Stage 4 - Finished（定案阶段）一个提案只要能进入Stage 2，就差不多等于肯定会包括在ES7里面。 7.Babel转码器Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。","link":"/jo.github.io/2016/06/20/js-and-ES6/"},{"title":"单测入门笔记","text":"以前因为技术氛围和开发需求等种种原因限制，还没有写过单元测试。近期入职一家技术氛围较好，并且推崇单测的公司。所以也有必要了解和熟悉下单测(单元测试)。推荐：★★★ 索引 单测是什么 单测框架概览 上手 Jest 断言 使用匹配器 测试异步代码 测试回调 测试Promise .resolves/.rejects async/await 在 React 中使用 小结 Issues 单测是什么 单测是至对程序中最小单元的验证和检查。具体化些，就是对一个模块，一个函数的验证。再应用到 React 项目中，通常是对 reducer 的验证。 单测框架概览 js 的单测框架选择也并不少，常用的有 Mocha，Jest，Jasmine 等。最近的项目里主要是 Jest 和 Mocha，其中 Jest 更多。下面说下自己对这两者的区别的一些初步理解。 Mocha 是现在较为成熟，生态较完善的单测框架。 Jest 由 Facebook 出品，由 Jasmine 演化而来。相对 Mocha 诞生较晚，但背后有着 Facebook 的支持，可见生态社区也会越来越完善。而且和 React 搭配使用也会更友好。 上手Jest 项目中 Mocha 和 Jest 都有，但 Jest 似乎更多。目前准备写的也是应用了 Jest 的项目，所以准备先入门 Jest。 首先新建一个项目 unit-test 并初始化，然后安装相关依赖。 123mkdir unit-testnpm initnpm install jest 在 package 中添加相应脚本。 123scripts: &#123; \"test\": \"jest\"&#125; 项目中已有了 Jest. 此时我们来测试一个简单的加法函数。 新建一个 index.js. 1234function sum(a, b) &#123; return a + b&#125;module.exports = sum 再创建一个 index.test.js 用于验证。 1234var sum = require('./index')test('1 + 2 equals to 3', () =&gt; &#123; expect(sum(1, 2)).toBe(3)&#125;) 然后运行测试，观察输出。 1npm run test 如果验证通过的话，可以在终端看到如下通过提示。 至此，一个简单的测试完成了。 不过通常情况下，我们会结合 ES6，React 使用，所以会配合上 Babel，需要安装其他依赖。 1npm install babel-jest babel-core regenerator-runtime babel-preset-env babel-preset-react 然后添加一个 babel 配置文件 .babelrc. 123&#123; \"presets\": [\"env\", \"react\"]&#125; 然后我们就可以使用 ES6 语法了。可以将原来的 require 改为 import 等。 断言 在上述的测试用例中，有一句断言 —— expect(sum(1, 2)).toBe(2) 实际上，在每个测试中，都至少有一句断言来判断执行结果是否与预期的一致。目前的断言库语义化都做的很好，如同上面这句话，很容易理解这是期望的结果和执行的结果的比较逻辑。 像常用的 Mocha 有着自己的断言库 Chai, 而 Jest 我目前还不确定是引用了什么断言库，看起来好像它本身就支持。 而断言的写法，也是以 expect 开头，然后以匹配器方法调用作为结果。包括下文提到的一些匹配器方法 toEqual 等等。 12expect(func(..args)).toBe(res)expect(func(..args)).toEqual(obj) 使用匹配器 刚才我们使用 expect(sum(1, 2)) 来输出期望的值，再用 toBe 方法来比较值是否相等。这里 toBe 就是相应的匹配器。 toBe 内部使用 Object.is 方法来判断，该方法和全等(===)判断类似，但略有不同。例如 Object.is 会区分 -0 和 +0，但不会区分 Number.NaN 和 NaN. 1234Object.is(-0, 0) // false-0 === 0 // trueObject.is(Number.NaN, NaN) // trueNumber.NaN === NaN // false toBe 方法通常可以用来比较数字，字符串等基本类型。但如果要比较对象等引用类型。可以使用 toEqual,它会递归比较对象中的值。下面来试着使用下 toEqual 方法。 1234test('比较对象相等', () =&gt; &#123; const data = &#123; a: 1, b: '2' &#125; expect(data).toEqual(&#123; a: 1, b: '2' &#125;)&#125;) 相应的，在各类型中还有对应的匹配器方法，例如使用 toBeNull 来匹配 null，使用 toBeCloseTo 来匹配浮点数，使用 toMatch 来匹配正则字符串，使用 toContain 来匹配数组是否包含某项等等。这些都可在 Jest 官网上找到。 测试异步代码测试回调 异步代码中常见的有测试回调，例如有 fetchData 的函数，传入 callback 回调函数。按照之前的理解，测试方式是这样的 1234567891011function fetchData(callback) &#123; const data = 'async data' callback(data)&#125;// 有问题的写法test('测试回调', () =&gt; &#123; function callback(data) &#123; expect(callback(data)).toBe('async data') &#125; fetchData(callback)&#125;) 由于 fetchData 的执行是异步的，所以当该测试执行完毕时，它还没有执行结束，也就无法测试。 Jest 本身在测试回调函数时提供了一个参数用来标识内部函数是否执行行结束。 1234567test('测试回调', (done) =&gt; &#123; function callback(data) &#123; expect(data).toBe('async data') done() &#125; fetchData(callback)&#125;) 这样，当 done 函数执行结束时，测试才执行完毕。而如果 done 没有执行，那也意味着其中哪里出现了问题。 测试Promise 同样的，这样测试 Promise 也无法生效，结果并不会报错。 1234567891011function handleData(data) &#123; return new Promise((resolve, reject) =&gt; &#123; window.setTimeout(() =&gt; resolve(&#123; res: data.res + 1 &#125;, 3000)) &#125;)&#125;// 错误示范test('测试 Promise 代码', () =&gt; &#123; handleData(&#123; res: 2 &#125;).then((data) =&gt; &#123; expect(data).toEqual(&#123; res: 2 &#125;) &#125;)&#125;) 要测试 Promise, 只需要在 Jest 测试中返回一个 Promise 即可。 12345test('测试 Promise 代码', () =&gt; &#123; return handleData(&#123; res: 2 &#125;).then((data) =&gt; &#123; expect(data).toEqual(&#123; res: 2 &#125;) &#125;)&#125;) 当然，Promise 还会有刻意测试错误的情况。于是我们想当然的又会觉得加上 return 就可以了。下面这段代码，我们来测试是否执行了 reject 方法，这时我们传入一个错误的参数再执行。 123456789101112131415function handleDataReject(data) &#123; return new Promise((resolve, reject) =&gt; &#123; window.setTimeout(() =&gt; &#123; if (Object.prototype.toString.call(data) !== '[object Object]') &#123; reject('Type Error!!!') &#125; resolve(&#123; res: data.res + 1&#125;) &#125;, 3000) &#125;)&#125;test('测试 Promise reject 代码', () =&gt; &#123; return handleDataReject('test rejected').catch((data) =&gt; &#123; expect(data).toMatch('Type Error!!!') &#125;)&#125;) 这里确实执行通过了。但如果我们把一个正确的参数传进去，是否能验证错误的情况呢，答案是不会的。例如我们把刚刚的 test rejected 字符串改为 { res: 1 } 作为参数传入的时候，其实也检测不出错误的执行。 因为在测试错误的情况的时候，fulfilled 状态也是不会在测试中被检出的。换句话说，当执行正确的时候，Promise 不会跑到 catch 后续这个函数中，也就会被检测通过。但这里我们需要测试的是异常的情况，所以必须还是需要补充上一句后续断言是否执行的语句 expect.assertions(1)。它并不会抛出测试的错误，但它会提示你有一句断言没有执行，这时候你就知道了，刚才那段对象作为参数执行的代码并没有走到 catch 函数中。 123456test('测试 Promise reject 代码', () =&gt; &#123; expect.assertions(1) return handleDataReject('test rejected').catch((data) =&gt; &#123; expect(data).toMatch('Type Error!!!') &#125;)&#125;) .resolves/.rejects .resolves/.rejects 是对上述更简化的写法。 12345678test('测试 resolves 代码', () =&gt; &#123; expect.assertions(1) return expect(handleDataReject(&#123; res: 1 &#125;)).resolves.toEqual(&#123; res: 2 &#125;)&#125;)test('测试 rejects 代码', () =&gt; &#123; expect.assertions(1) return expect(handleDataReject('test rejected')).rejects.toMatch('Type Error!!!')&#125;) Async/Await 这里的用法其实与它们本身的用法类似。 12345678910111213test('测试 async 代码', async () =&gt; &#123; expect.assertions(1) const data = await handleDataReject(&#123; res: 1 &#125;) expect(data).toEqual(&#123; res: 2 &#125;)&#125;)test('测试 async error 代码', async () =&gt; &#123; expect.assertions(1) try &#123; await handleDataReject('test rejected') &#125; catch(e) &#123; expect(e).toMatch('Type Error!!!') &#125;&#125;) 由于使用了同步写法，这时候不需要再 return 了。当然，我们还是可以使用 .resolves/rejects 来做一些写法上的优化。 12345678test('测试 async 代码', async () =&gt; &#123; expect.assertions(1) await expect(handleDataReject(&#123; res: 1 &#125;)).resolves.toEqual(&#123; res: 2 &#125;)&#125;)test('测试 async error 代码', async () =&gt; &#123; expect.assertions(1) await expect(handleDataReject('test rejected')).rejects.toMatch('Type Error!!!')&#125;) 在React中使用 通过以上的内容，我们对单测有了一个比较初步的了解。 但在实际项目中，我们通常会在 React 中来使用 Jest。而在 React 中书写单测，自己接触较多的是基于 Reducer 的。 下面来写一个 React 中的单测，假设我们有一个列表数据获取逻辑(假设没有异步请求)，然后我们要对它进行一个验证。 首先是 Reducer. 会有一个 reducer.js 文件 12345678910111213141516// 初始数据const initialState = &#123; listData: &#123; data: &#123;&#125; &#125;&#125;// reducer 将 listData 保存export default function ListReducer(state = initialState, action) &#123; switch(action.type) &#123; case: 'LIST_DATA': return Object.assign(&#123;&#125;, state, &#123; listData: action.data listStatus: 'success' &#125;) &#125;&#125; 然后编写相应的单测。reducer.test.js 1234567891011121314151617181920212223242526272829303132333435import ListReducer from './reducer'// mock 数据const initialState = &#123; listData: &#123; data: &#123;&#125; &#125;&#125;// actionconst listData = &#123; type: 'LIST_DATA', listData: &#123; data: &#123; name: 'kyrie', age: 21 &#125; &#125;&#125;// 处理后的数据const listDataReducer = &#123; listData: &#123; data: &#123; name: 'kyrie', age: 21 &#125; &#125;, listStatus: 'success'&#125;test('获取列表', () =&gt; &#123; const state = ListReducer(initialState, listData) expect(state).toEqual(listDataReducer)&#125;) 当然，这里的例子非常简单，运行 npm run test 也能轻易通过。但在实际项目里，Reducer 的处理可能会复杂的多，相应的书写也会更加复杂。上述是一个单个的测试，真实项目中，或许是按模块来组织的。每个模块中有相应的多个 Reducer. 那就需要用到测试套件(test suite) —— describe 块，其中会含有多个测试用例(test case), 即 it 块。 describe 函数的第一个参数是测试套件名，第二个是要执行的回调函数。 it 函数同理，它作为独立的测试用例，是测试的最小单位。 于是整理后如下： 12345678910describe('获取列表模块测试', () =&gt; &#123; it('获取列表', () =&gt; &#123; const state = ListReducer(initialState, listData) expect(state).toEqual(listDataReducer) &#125;) it('获取列表失败', () =&gt; &#123; // do sth &#125;) // 更多的测试用例&#125;) 整理后整个模块的内容都在 describe 套件内，组织起一个个测试用例。显而易见，这样更容易梳理和回顾。 小结 有些时候，项目里没有单测也能基本良好运行，就像我从前做过的项目一样。但这未必是好事。因为单测带来的，其实更多的是对业务的思考和设计。假如我们决定要写单测，那么在写该模块时，就应提前想到多个可能的场景，从而避免未知的错误，同时自己也会对当前业务有着更好的理解。另一方面，就像我现在所做的，其实通过写单测，可以去熟悉相应的业务模块的所有场景，这会比直接阅读业务代码会更熟悉的多。 上述代码对应的仓库 unit-testing. Issues目前碰到的一些问题整理，基于 ^22.4.3. 在运行 npm run test 时 123import &#123; Modal &#125; from 'antd' // 这样引入时会报 CSS 相关的报错import Modal from 'antd/lib/modal' // 这样才不会报错import Modal from '../../../node_modules/antd/lib/modal' // 或者这样也不会报错 排查发现是 Jest 无法解析 CSS。搜索部分结果，有人给出了方案，官方也提供了解决方案。目前发现可以解决。 TODO redux-mock-store 了解。","link":"/jo.github.io/2018/06/29/learning-unit-testing/"},{"title":"如何让你的 Sublime Text 独具一格","text":"sublime 养成记作为大多数前端攻城狮的主力编辑器，怎么能不让它美一些呢。打开偏好設置，參照以下配置，开启你神祕的sublime text 3之旅吧！ 1234567891011121314151617181920212223242526&#123; &quot;auto_find_in_selection&quot;: true, // 开启选中范围内搜索 &quot;bold_folder_labels&quot;: true, // 侧边栏文件夹显示加粗 &quot;caret_style&quot;: &quot;smooth&quot;, &quot;color_scheme&quot;: &quot;Packages/Colorsublime - Themes/Easyballs.tmTheme&quot;, &quot;default_encoding&quot;: &quot;UTF-8&quot;, &quot;default_line_ending&quot;: &quot;unix&quot;, // 使用unix风格的换行符 &quot;draw_minimap_border&quot;: true, // 右侧代码预览时给所在区域加上边框 &quot;ensure_newline_at_eof_on_save&quot;: true, // 保证在文件保存时，在结尾插入一个换行符。这样git提交时不会产生额外的diff &quot;fade_fold_buttons&quot;: true, // 默认显示行号右侧的代码段闭合展开三角号 &quot;font_face&quot;: &quot;Monaco&quot;, // 个人最钟爱的字体 &quot;font_size&quot;: 19, &quot;font_weight&quot;: 700, &quot;highlight_line&quot;: true, // 当前行高亮 &quot;highlight_modified_tabs&quot;: true, // 高亮未保存文件 &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ], &quot;save_on_focus_lost&quot;: true, // 窗口失焦立即保存文件 &quot;tab_size&quot;: 2, &quot;theme&quot;: &quot;Spacegray.sublime-theme&quot;, //主题推荐，除了使用的以外，Material和Seti_UI 这两款都很美，比太空灰更美 &quot;translate_tabs_to_spaces&quot;: true, // 将tabs转换为space &quot;trim_automatic_white_space&quot;: true, // 自动移除多余空格 &quot;trim_trailing_white_space_on_save&quot;: true // 保存时移除多余空格&#125; 常用插件 插件安装包 package control ConvertToUTF8: GBK编码兼容 JsFormat: javascript格式化，包括json.切换Syntax后按 Ctrl+Shift+A?格式化 ColorSublime:用来安装官网的所有主题。 Color Highlighter: 高亮CSS中的颜色，可以设置成用背景色或者边框提示颜色 { &quot;ha_style&quot;: &quot;filled&quot;, &quot;icons&quot;: false } DocBlockr: 代码块注释 /*:回车创建一个代码块注释 /**:回车在自动查找函数中的形参等等。 Git: 还没学会用。 Modific: 高亮文件上次提交后的改动，适合git和svn BracketHighlighter 括号高亮 BracketGuard 高亮错误的括号 Better coffeescript ColorPicker 拾色器 (这个可以用其他软件替代) CSScomb: 给css的属性排序，默认按键是ctrl+shift+c，使用后能会留有空行，再和下面的格式化插件配合使用，效果最佳 CSS Format css格式化插件 // 先cmd+shift+p 然后选择选项，个人习惯选择 Format CSS: Expanded CSS3 支持CSS3，语法高亮，自动补全 Ctags 跳进方法内部，不过配置有些麻烦 Jade Javascript Next: 支持es6，还未使用 LiveStyle 支持实时调整CSS属性 需要文件路径 chrome也要安装插件 不常用 SCSS SyncedSidebarBg 让侧边栏和中间背景色相同 typescript Babel ES6/2015 和 React JSX上添加语法高亮 ES6语法检查 eslint 首先是要系统全局安装eslint, 运行npm install -g eslint，npm install -g babel-eslint 下载插件 sublimeLinter 下载 sublimelinter-contrib-eslint 下载完成后修改Sublimelinter 配置，Preferences-&gt;Package Settings-&gt;SublimeLinter-&gt;Settings-User, debug: true 开启 debug 模式 paths: 根据具体环境，设置 ESLint 路径 例如： 12345678910111213141516171819202122232425&#123;\"user\": &#123; \"debug\": true, ... \"linters\": &#123; \"eslint\": &#123; ... \"excludes\": [\"*.html\"] &#125; &#125;, ... \"paths\": &#123; .... \"osx\": [ \"/usr/local/node/v0.12.7/bin\" // 如果用nvm装的会是这个 \"/Users/kyriejoshua/.nvm/v0.10.30/bin/\" ], \"windows\": [ \"C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\" ] &#125; ...&#125;&#125; 然后在项目根目录下生成eslintrc.json文件 运行eslint --init 选择一些基本配置生成文件 具体配置看这里 ‘off’ or 0 关闭规则 ‘warn’ or 1 将规则视为警告 ‘error’ or 2 将规则视为错误 受不了自帶的丑陋图标？——更换图标方法 – You got the replacement icon (whatever file type, not neccessarily icns) somewhere, open it with Preview.点击准备替换的图标。 – Cmd + Option + 2 to open Preview’s Thumbnail pane. – Select the image in the Thumbnail pane and Cmd + C 复制选中图标 – Use Cmd + I to open the Info panel for the App. 打开app的图标预览 – You see the small icon at the top left of the Info panel. Click to select and Cmd + V 选中粘贴 That’s it! It might take longer than your method, but it doesn’t require the icon to be with “.icns” extension. 参考 sublime中文文档 sublime text3配置","link":"/jo.github.io/2016/05/03/make-your-Sublime-Text-different/"},{"title":"前端入坑周年记——野蛮生长","text":"不久前，正好是我以前端身份工作的一周年。很难相信，毕业前迷茫得找不到北的我，会在没多久后找到一个与自己兴趣相投的职位并且决定长期发展。人总是是要向前看的，但有些时候也需要回顾，我想就这篇文章，来记录这一年里踩过的大大小小的坑，和经历前端风云变化的一些事。 不断踩坑我清楚记得刚开始工作时的状态——那会儿只学习了些基础知识的我，在第一次面对实际的业务代码的时候一脸懵逼。就像新手从新手村刚出来，就开始不得不面对boss。但其实远没有那么夸张，当你只见过html, javascript, css这些素颜天真的妹子，然后再第一次遇见化妆后的美女们，自然会不知所措。js化妆成了简洁的coffeescript(cs), html化妆成了简洁的jade, css穿上了高跟鞋变成scss.还有强大无比的版本控制工具git, 再加上本来习惯用的windows平台，换成了mac, 就像习惯穿的T恤牛仔，换成了西装衬衫。在把妹(coding)时也越来越不自信了。 但在一开始接触这些，其实并不是坏事。她们让我明白了前端的多样性，多元化，也让我做了今年最棒的事之一——由于工作需要，买了属于自己的Macbook Pro——尽管前不久我才刚刚把分期还完。使用MBP的效率实在是高的惊人，就前端而言，她是如此地方便和快捷。github上有一堆awesome-mac系列app等待你去挖掘。 搭配cs使用的是angular 1.3, 在这一年里慢慢发现，这个曾经流行的MVC框架王者，在框架领域开始慢慢被react和vue瓜分。而1.3更可算是古老的版本了，她和cs正在随着历史潮流退去。这是我后来才意识到的事。在我还没意识到这些的时候，我又接触了typescript + angular 1.4搭建的项目，ts和ES6相似，有许多ES6的新特性，而整体上有一点像java, 静态类型，类，继承，私有状态等等。 前半年大概就在大量接触新内容的状态中度过了。说来惭愧，至少过了个把月，我才渐渐适应这些琳琅满目的框架和预编译语言等等。在这里要感谢两位前辈聪哥和望哥，和他们接触的时间并不久，但给我留下很多可学习的地方。让我在编程初期意识到良好的代码规范在团队中的重要性，要养成好的代码习惯等等。 野蛮生长后来在望哥帮助下，我构建了一个小项目——主要使用了webpack+ES6, 是一个多页面应用，截至目前只引入了jquery，除此之外包括eslint规范审查，引入babel编译ES6等等。后来应用到了公司的生产环境中，在微信公众号里。建立这个项目初期是期望开发者能简单上手，但随着业务需求的增加，它开始变得捉襟见肘。首先缺乏bootstrap这样类似的样式框架，未定义公共样式，使得后来所有单个页面的样式都需要重写。后来我尝试添加路由，尝试引入express框架却发现每个模块都需要更改，实际条件不允许，更别谈引入react和vue之类的框架了。 接下来的过半年时间我在写以ts和ES6为主的业务代码。在没有框架可用情况下使用纯ES6边学习边写，没有任何模板，也没有时间写模板，不管是样式还是逻辑。即便ES6新提供的语法糖非常可爱实用，但过程却让我非常痛苦，也不得不去github看一些优秀项目的源码寻找更好更优化的方案。这段时间，写几乎纯原生的代码让我开始意识到代码的抽象性。写代码的能力和抽象的能力是正比的。 回顾下来，我渴望进步，所以在工作之余试图让自己处在学习的状态。但或许有些过犹不及——那些技术热文我看了许多，其中却也匆匆扫过许多，留下印象的却寥寥无几。有段时间我啃起了权威指南，有段时间又尝试理解Understore.js源码。阅读内容，方向太杂太乱导致我有时停滞不前。所以最近，我又让自己回归基础，啃起了js权威指南。我始终觉得基础的是最重要的。 划重点这一年，我的重心从angular+cs转到angular+ts, 再到后几个月的ES6+jquery+webpack，经历了较大的转变。而这年也几乎是我在前端摸爬滚打的一年, google, github issues, stackoverflow, segmengfault等等我用尽各种手段去寻找坑的答案。前两个月有前辈指导，后来就开始横冲直撞。库克说过——总之是一个名人说过——只要是方向对了，不管是跑是走是爬，都是进步，都是好的。但我不想爬了，不想横冲直撞，想走路，想走快点，再快点，我还有饱满的热情不想浪费呢。 最后，留一点私心。最近离职了，正在寻找下一份工作。我的一切几乎都在上面了，剩下的也在博客里，有talk有code。希望也有机会可以和各路前辈大神交流，十分想加入一个优秀的团队，和各位优秀的伙伴共事、成长。","link":"/jo.github.io/2016/12/26/my-2016-with-front-end/"},{"title":"我的 git 工作流","text":"这篇文章的契机是曾经有个同事问我为什么要在终端里使用 git, 当时我愣了会，因为从没有人问我这个问题，我也没有为这问题好好总结过。虽然其实有很多显而易见的好处，但我还未好好总结一番。既然自己平时在工作中使用 git 的地方非常多，也有着一套标准和工作方式在执行，那我希望通过这次整理把这流程体系更完善的加以说明。既规范化、提高工作效率，也可留作记录。 基本流程 首先是最基本的操作，从一次工作的开始到结束。这是一个比较基础的流程。 Working Directory(工作区) =&gt; Staging Area(暂存区) =&gt; Git Repository(git 仓库) 123456git checkout -b feature-newgit statusgit add .git commit [-m 'commit message']git checkout develop|mastergit merge feature-new 从当前分支切出一个新分支，在该分支下进行开发。 在工作区内修改文件，当任务完成时，添加所有改动文件到暂存区，然后提交，注明提交信息。 提交完成后，切回到原始分支，然后 merge 刚刚完成的功能分支。 而在这过程中，有许多地方可以改善，或者根据实际应用场景，有很多部分可以扩展。 这里以三种状态为界限展开。 Working Directory and Staging Area 工作区是自己开发时的部分。通常当一个新需求降临时，我们从 develop|master 切出分支，即自动停留在这阶段。 当需求开始开发，改动了部分代码而没有完成任务，这时我使用 git add . 来将代码保存到暂存区。 git add .的适用场景还包括但不限于以下： 睡午觉。 泡咖啡。 吃晚饭。 简言之，是工作因故暂时停止而任务又没有完成时，适合使用该命令。 Git Repository 当一个需求或任务完成时，我们需要将改动提交上去。 最常见的是，当一项任务完成时，我们先把所有改动放到暂存区，然后运行 git commit -m &#39;feat: 完成xx功能&#39; 来将这次改动提交到仓库。必要时再将分支 push 到远程。 以上是对基础使用的扩展总结。但，如果只谈这些这篇文章就毫无价值了。以下是一些进阶使用方式——毕竟任何事都不会只有基础那么简单。这些使用对我工作的效率是有极大帮助的。 进阶使用Working Directory and Staging Areagit status优化 个人而言，在未开发完需求时，最常见的使用 git 时机是查看当前的改动状态，有多少文件修改，有多少文件已经放在暂存区。 这时通过git status来查看文件状态。 不过，正因为频繁使用。完全可以简化查看内容。 git status -sb(git status -short -branch)查看分支情况并简化信息。 简便多了。 git diff优化 一个常见的场景是需要查看当前代码的改动部分——我想大部分人都不会刻意去记住自己究竟改了哪些代码。 运行git diff查看当前改动的文件: 这里我用diff-so-fancy优化排版了diff 的查看。 简单直接对吧。 如果文件多也不怕，可直接查看单个文件。 git stash和git stash apply 这是个可能有些人不熟悉的命令，但实际上很有用。 想象一下这个场景，你在自己分支上改了部分代码，突然某个环境有个严重问题要你切换到 master 或某个分支马上查看，这时工作没完成并不适合提交，放在暂存区的话不方便切换分支。git stash在这里就很有必要了。 git stash保存当前工作进度，代码改动。然后你可以尽情地切换分支，在别的分支上修复完问题后再回来，使用git stash apply恢复即可。 改动了部分代码： 保存代码改动： 当在其他分支完成后再回到当前分支恢复： git checkout .撤销修改 有时候会遇到这样一个情况，午睡时或喝咖啡或其他小伙伴过来故意动手动脚开玩笑的时候，不小心按到键盘上的某些键，而且该死，正好打在了编辑器上。我们当然不会傻到一个个去找出来然后动手删掉。 这时只要用git checkout .来取消所有修改。 git checkout file——或者发现只有一个文件改动时。 Git Repositorygit commit优化: 使用 commit message 规范提交 如果你临时起意想要创建一个项目用来随意把玩，那自然随意提交即可。但只要项目是多人维护，多人开发的，或者有回顾自己以往的改动记录的需求的，commit message 就显得很有必要了。 我参考阮一峰老师的如下规范来编写 commit message. 例如刚才的改动，使用git commit -m &#39;feat: 完成 demo4&#39;来提交。 这里我写错了，少写了完成两字，不过没关系，下一节有说明。 如果严格遵守规范，那么回顾过往的提交记录时，结果将是一目了然的。 而即便没有以上较麻烦的规则，严格遵守自己的规则也是必要的，这使得你能够清楚直接的了解自己过去、或者别人过去在这个项目里面做了什么。 git commit补充 正常的提交像上面按规则使用git commit即可。但如果突然发现自己的提交信息有误，或者遗漏了重要的信息。没关系，仍然可以修改刚才的提交——只要你还未 push 到远程！ git commit --amend命令可以将当前的改动补充到前一次提交中。 刚才我提交过快，把feat: 完成 demo4写成了feat: demo4, 现在我改回来。 这点在补充完善 commit message 时非常方便。但也需要非常注意，这只适用于还未 push 时，否则会引起一些小麻烦。 git rebase合并提交 很多时候，一个需求的完成需要数天时间，迫于各种原因，期间会提交数次。但总的来说，我们只是完成了某个需求。所以并不需要中间的或者前几次提交，这时候合并提交就显得有必要了。 git rebase -i HEAD~n可以合并前几次提交。 合并前： 现在我们将最近两次提交合并git rebase -i HEAD~2: 这里清楚显示了各命令用法，我们使用squash来合并，把第二个 pick 改为 squash. 可以再次编辑 commit message, 我们精简一下，写在一起。 完成后可见提示。 这时再查看记录： 两条 commit 已经合为一条。 和git commit --amend类似，因为涉及到修改 commit 历史，所以千万不要在git push后尝试哦！ git log优化 git log --oneline以一行的形式快速查看提交记录，这个可见刚才的提交记录。 git log -p查看提交记录同时也查看具体改动的代码部分——这在 code review 时非常方便。 git log -p file查看单个文件提交记录同时也查看具体改动的代码部分——这在找错时非常方便，再也不用到处找人询问是哪个家伙改了 XX 文件的代码了。 git log --stat查看提交记录的时候显示文件改动信息——也很适合 review 或排查错误. git log --auther=zhengyuan zhu查看某个家伙的提交记录——我没改这部分代码啊，看看那个家伙做了什么(这家伙究竟有没有好好工作)。 git shortlog简化版提交记录。 git shortlog -s -n查看所有人提交次数并排序——或许这样看更加简洁方便。 很高兴看到在这个项目里我贡献的部分较多。 其他 git pull --rebase可以简洁 pull 过程——适合洁癖者——我是很反感在查看 log 时看到一堆 merge 记录和情况。即有时如果远程仓库和本地仓库代码不一致时，git pull 会自动进行一次合并，这条记录突兀地存在于 commit history 里，我觉得毫无必要。 git pull --rebase过程中可能会遇到冲突，解决后用git rebase --continue来继续。或者觉得这次不稳，可以用git rebase --abort来取消。 如图所示的f6c5d08和6cbd73f提交就可以通过git pull --rebase避免。 小结 这里罗列了我常用的 git, 还有部分因篇幅原因不能再一一列举。可能更适合再写一篇来总结。相比之下，我觉得 GUI 很难做到像这样随心随欲地做到自己想用 git 所做的事。而这些完全可以使用一行命令搞定的事，我也不高兴去将手从键盘区移开然后去挪动笨重的鼠标去一个个点击。 希望大家都可以学好 git, 善待 git, 然后在 CLI 里尽情使用 git 吧.","link":"/jo.github.io/2017/07/07/my-git-workflow/"},{"title":"前端性能加快之nginx开启gzip压缩","text":"近期发现公司内部网站加载特别慢，原因是我们将所有样式文件，外部引入的文件都分别合成成一个文件，这文件少则1M，多则3、4M。大的简直不敢想象。导致打开速度几十秒甚至一分钟。实在无奈，经前辈指点终于发现nginx有个好配置…… gzip Gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。也经常用来表示gzip这种文件格式。软件的作者是Jean-loup Gailly和Mark Adler。在1992年10月31日第一次公开发布，版本号0.1。 gzip HTTP协议上的GZIP编码是一种用来改进web应用程序性能的技术。通常可以将纯文本内容压缩到原有大小的40%甚至更小。 减少文件大小，一是可以减少存储空间。二是通过网络传输文件时，可以减少传输时间。 USAGE 在nginx中使用gzip压缩很方便。只要将默认的注释除去，加上一些配置即可。 vim /etc/nginx/nginx.conf 12345678gzip on;gzip_min_length 1k;gzip_http_version 1.1;gzip_buffers 4 16k;gzip_types text/plain application/x-javascript text/css text/javascript;gzip_comp_level 2;gzip_vary off;gzip_disable \"MSIE [1-6].\" gzip on 开启gzip gzip_min_length 当返回内容大于这个值时会进行压缩，以K为单位，如果值为0，所有页面都进行压缩，但没有必要。 gzip_http_version 识别http协议的版本。默认值为1.1，就是对HTTP/1.1协议的请求才会进行压缩。 gzip_buffers 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_types 设置需要压缩的MIME类型，非设置值不进行压缩。 text/html默认已经压缩 图片可不开启压缩，jpg/gif/png格式的图片本身就是压缩过的。 gzip_comp_level 设置压缩等级，等级越低压缩速度越快文件压缩比越小，传输块但也比较耗费CPU。可设置为1-9，默认是4。 gzip_vary 判断HTTP是否支持压缩，如果不支持的就不压缩。 gzip_disable 禁用IE6的gzip，IE6支持不好，不过这年头用IE的人也不太想理会了…… PS：公司缺少运维，真心锻炼前端的全栈能力…… 参考：开启Nginx的Gzip压缩功能","link":"/jo.github.io/2016/08/02/nginx-gzip-on/"},{"title":"个人git使用手册","text":"git安装 主要针对Mac环境下 安装说明 SSH 以下通常在测试时需要，因为需要连上主机 命令行里的输入方法（如果能在页面上做最好还是在网页上） 命令行里输入 cat ~/.ssh/id_rsa.pub 查看密钥、公钥方法 输入 vim ~/.ssh/authorized_keys 在内容里编辑，加上自己的公钥，这样可以方便以后每次测试或者做其他事时不再需要每次都输入密码（首先要输入密码进入 如ssh root@10.0.0.246 根据提示输入密码 ） 更详细的见以下链接 SSH使用说明 使用git 理解git的三种状态：已暂存、已修改、已提交 文件常常处于这三种状态之一 熟悉git的常用命令 如果提交文件时有需要编译的文件，就下载相应的编译 例如，在终端中输入：npm intall -g coffee-script 强烈推荐翻墙使用，下载更快，更方便 git常用命令(自己不太熟的)：git merge-合并、git revert-回到某次提交的状态并产生一次新的提交、git reset-撤销某次提交 、、、、、、 git 遇到问题error:bad line length character 权限问题，或者修改Host ###查看历史提交记录 格式为作者，修改距离现在多久/提交时间：提交说名 -简短的哈希字串 展示分支合并、历史 git log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph*格式基本同上 git log --pretty=format:&quot;%h - %an, %ar/%cd : %s&quot; 撤销操作撤销 取消文件的暂存*git reset HEAD &lt;file&gt;来取消暂存 撤销对文件的修改 ！不推荐使用，不能还原 git checkout --&lt;file&gt; #####补充提交 补充提交，会覆盖上次的提交，并不会产生一次新的提交 提交前用git add &lt;file&gt;加上补充的文件 *git commit --amend 远程仓库 查看远程仓库git remote -v 显示读写远程仓库使用的git保存的简写与其对应的URL git remote show origin &gt;查看远程仓库的更多信息*添加远程仓库 git remote add &lt;shortname&gt;&lt;url&gt;例如：git remote add pb http://www.google.com*可以用pb来代替整个url 例如：git fetch pb 拉取远程仓库 从远程仓库抓取和拉取 git fetch [remote-name] 并不会自动合并*git pull 会自动合并,相当于先执行git fetch再执行git merge 推送到远程仓库 `git push [remote-name] [branch-name] #####远程仓库的移除和重命名*修改远程仓库的简写名 git remote rename 例如： git remote rename pb paul &gt;将pb重命名为paul !这个操作也会修改远程分支的名字 *移除远程仓库 git remote rm 例如：git remote rm paul ###打标签 #####列出标签 git tag ###git别名 *用于修改git操作的别名，使操作更方便 运行git config --global alias.logpregra &#39;log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph&#39; git logpregra就等价于 git log --pretty=format:&quot;%an, %ar/%cd : %s -%h&quot; --graph*常用的还有 git config --glabal alias.ci commit、git config --global alias.co checkout 定义外部命令 替换外部命令而不是子命令时，在命令前面加一个‘！’号git config --global alias.visual &#39;!gitk&#39; 定义git visual为gitk的别名 ###分支简介 查看分支 运行git log --oneline --decorate --graph --all 查看提交历史、各个分支的指向以及项目的分支分叉情况*在本机上已配置为git logoneall 删除分支 git branch -d [branch-name] 如git branch -d watch-pro 合并分支 当有冲突存在时*其中之一方法利用图形化工具来解决冲突，运行git mergetool &gt;git中默认的合并工具是opendiff 分支管理 git branch --merged 查看哪些分支已经合并到当前分支查看所有包含未合并工作的分支， git branch --no-merged使用git branch -d命令来删除未合并的工作时会失败，因为它还未合并 但如果确实想丢掉那些工作，可以用-D选项强制删除 远程分支 远程分支以 (remote)/(branch)形式命名 运行git ls-remote (remote) 来显式地获得远程引用的完整列表 &gt;就是远程的所有分支,或者使用git branch -a来查看远程分支，似乎这个比前者更有效 更换远程分支的名字 git clone -o booyah 那么远程分支的名字就会是 booya/master 更新远程仓库到本地的命令 git fetch teamone 抓取远程仓库teamone有而本地没有的数据 假如刚刚克隆了一个仓库，想要获取一个远程分支，先在当前分支下pull，保证是最新的，然后运行git checkout -b index-pro origin/index-pro 这样你就有一个同名分支index-pro和远程的分支index-pro同步了 推送 推送本地的分支到服务器上 git push origin servefix等同于 git push origin servefix:servefix 如果不想让远程的分支重名 可以这样git push origin servefix:awesomebranch ####如何避免每次输入密码 如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。 如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。 跟踪分支（上游分支）：与远程分支有直接关系的本地分支 在远程跟踪分支之上建立本地的分支进行工作 git checkout -b [branch] [remotename][branch] 例如 git checkout -b serverfix origin/serverfix 可以用--track快捷方式 例如 git checkout --track origin/serverfix 设置本地分支与远程分支为不同的名字 git checkout -b sf origin/serverfix 本地分支sf会从origin/serverfix拉取 设置本地已有的分支跟踪一个新的拉取下来的远程分支，或者修正正在跟踪的上游分支，可以使用-u和--set-upstream-to选项运行 git branch 例如 git branch -u origin/serverfix 查看设置的所有跟踪分支 运行git branch -vv 上游快捷方式 当设置好跟踪分支后，可以通过 @{upstream} 或 @{u} 快捷方式来引用它。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。 删除远程分支 通常在通过远程分支做完所有工作了以后操作，一般这个删除只是删除了指向服务器的指针，并不会删除数据，服务器会保存一段时间的数据，直到垃圾回收运行，也容易恢复 git push origin --delete serverfix git分支-变基 git中整合来自不同分支的修改主要有两种方法：merge和rebase*变基即在新分支上引入补丁和修改，然后在原分支上再应用一次 运行git checkout [branch-name]git rebase master 然后合并 git checkout mastergit merge [branch-name] 变基使得提交历史更整洁 图例说明 将client的修改合并到主分支并发布，但暂时不合并server的修改这时可以使用 git rebase命令的--onto选项，选中在client分支里但不在server分支里的修改，在master分支上重演 git rebase --onto master server client取出client分支，找出处于client分支和server分支的共同祖先之后的修改，然后把它们在master分支上重演一遍。 然后可以快进合并master分支了git checkout master git merge client 接下来再把server分支中的修改也整合进来，使用git rebase [basebranch] [topicbranch]*git rebase master server 然后再合并主分支mastergit checkout master git merge server 变基的风险(不太理解) 不要对在仓库外有副本的分支执行变基 图例说明 接下来，有人向中央服务器提交了修改，其中包括合并。然后你抓取了远程分支的修改，将其合并到本地的开发分支，然后提交历史就会变成这样。 刚才的那个人又把合并操作回滚，改用变基，然后又用git push --force命令覆盖了服务器上的提交历史。之后你再从服务器抓取更新，会发现多出来些新的提交。 如果此时执行git pull,会合并来自两条提交历史的内容，生产成一个新的合并提交，如下图。 如果现在执行git log命令，会发现有两个提交的作者，日期，日志是一样的。 而且如果将这堆推送到服务器上，那么实际上是将那些已经被变基抛弃的提交又找回来。 用变基解决变基 如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下git都能成功分辨出哪些是你的修改，并把它们应用到新分支上。*如果遇到图3-38的情境，如果没有执行合并，而是执行git rebase teamone/master,git 会: 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）检查其中哪些提交不是合并操作的结果（C2，C3，C4）* 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4’）**把查到的这些提交应用在 teamone/master 上面会得到下图的结果 要使得方案有效，需要对方变基时确保C4`和C4几乎是一样的。否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。 在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。 只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，你就不会有事。*如果某些情形下决议要这么做，一定要通知每个人执行git pull --rebase命令，这样虽然不能避免伤痛，但能有所缓解。 总的原则是：只对还没有推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样才能享受到两种方式带来的便利。 子模块！ 新克隆一个项目时，会克隆相应的子模块，但是子模块内容为空。运行git submodule init初始化 再运行git submodule update同步 如果是在一个项目中新增子模块git submodule add git@code.gomrwind:FrontEnd/ui.git 假如成功了 运行git status会看到 12new file: .gitmodulesnew file: ui 然后可以cat .gitmodules查看配置 应当如下 1234[submodule \"src/ui\"]path = src/uiurl = git@code.gomrwind.com:FrontEnd/ui.gitbranch = master 要注意的是！如果之前有下过提示出错等，要更改.git中的config配置。还有.git下的modules下的相对应文件夹需要删除rm -rf files 点这里学习 123456如果在运行子模块的相关命令时出现以下问题：fatal: Needed a single revisionUnable to find current revision in submodule path运行命令删除错误的文件，重新更新： * rm -rf [模块文件名] * git submodule update --init 12345如果在运行子模块相关命令时出现以下问题fatal: reference is not a tree: 16effe6cfd27ff78b04ff95e9103514e6dcf5cb3Unable to checkout '16effe6cfd27ff78b04ff95e9103514e6dcf5cb3' in submodule path 'gezbox/lib/NotificationStyles'Failed to recurse into submodule path 'src/ui'切换分支到master,再拷贝一个分支作为对比，这是子模块有修改导致的。确认修改后再在那个分支上提交更新。 服务器上的git-协议（本地协议、HTTP协议、SSH协议、GIT协议）本地协议 最基本的协议 运行git clone /opt/git/project.git 或者执行git clone file:///opt/git/project.git 推荐使用前者 增加一个本地版本库到现有的git项目，执行git remote add local_proj /opt/git/project.git HTTP协议注意点！！！ 新建一个项目时，要新建一个文件 .gitignore 里面设置哪些文件不随git提交 如果忘记了，在之后再添加时或再次修改时。 最好重新克隆到本地。然后依次运行git rm --cached . git add . git commit -m &quot;.gitignore is now working&quot; 先把所有文件从版本控制中删除，然后再重新加回来，提交上传后新的.gitignore就生效了 git rm –cached .`表示哪些文件不随git提交 如果有错误提示 could not get git status --porcelain 很有可能是因为忘记添加.gitignre。执行一遍上述操作 could not get git status --porcelain 这样的错误提示，我的理解是上传的文件数量过多导致的。在.gitignore忘记加入时将node_modules等文件也上传，node_modules内容过多大概就导致了这个报错。甚至会导致无法使用git commit","link":"/jo.github.io/2016/03/03/my-gitbook/"},{"title":"面试题整理-2017","text":"面试时遇到的一些没答上来的问题，在这里总结反思。其实很多都并不难，回顾基础大多可以答对，但现实就是要我们在任何时候都做好准备。所以，教训如下。 InterviewHTML 什么是w3c规范： W3C是英文World Wide Web Consortium的缩写，w3c理事会联盟。它是对网络标准制定的一个非赢利组织，例如制定HTML、XHTML、CSS、XML的标准。 CSS import和link有什么区别: link属于html标签，而import是css提供的引入文件方式。 加载顺序有异。link会在页面加载同时加载，而import会在页面全部下载完后再被加载。 兼容性差异。import是css2.1才提出的，所以那些老的快掉牙的浏览器(ie5+)并不支持。link则没有该问题。 dom控制样式时，只能改变用link引入的css.而import的css是无法用dom控制的。 JavaScript 创建对象的几种方式: 12345678910111213141. 使用构造函数创建:var obj = new Object();2. 对象直接量:var obj = &#123;&#125;;3. 自定义构造函数创建:function Fun(name) &#123; this.name = name;&#125;var obj = new Fun('joshua');4. Object.create(parentObj[,&#123;key: &#123;key: value&#125;&#125;]);var obj = Object.create(&#123;name: 'kyrie'&#125;); 以下代码输出什么: 12345678910111213for (var i = 0; i &lt;= 3; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, 0);&#125;// 输出 4个4;/* 理解如下(待完善): 由于js是单线程的，只有当前一个逻辑运行结束，才会执行下一个逻辑。 对应到这里，就是for循环先运行完成，再执行setTimeout. 这样for循环结束，一共有四次循环，产生四个结果。 而setTimeout打印每次的结果，所以是4个4。 */ 以下代码输出什么： 12345678910111213141516171819202122function b() &#123; console.log(myVar1); console.log(myVar2);&#125;function a() &#123; var myVar1 = 1; var myVar2 = 2; b();&#125;var myVar1 = 11;a();console.log(myVar2);// 11;// myVar2未定义，报错;/* 理解： 注意这里b不是闭包，无法访问到a函数内的变量。 所以myVar1会从函数作用域内向全局作用域寻找，输出11 而myVar2在全局下没有定义，就会报错。 */ 控制台内执行以下代码，然后用户在10秒内连续点击页面三次，请问会输出什么: 123456789101112131415161718192021222324function waitSomeTime() &#123; var st = 10000 + new Date().getTime(); while(new Date() &lt; st)&#123;&#125;; console.log(\"don't wait, it's ok\");&#125;function clickMe() &#123; console.log('why click me');&#125;document.addEventListener('click', clickMe);waitSomeTime();console.log('hello');// 会依次输出如下\"don't wait, it's ok\";'hello';'why click me';'why click me';'why click me';/* 理解如下(待完善): 由于函数体内的逻辑是顺序执行的, while因条件不对不会触发，所以直接跳过，执行下一句。 */// 因为紧张，这题本来对了被面试官又误导错了。输在心理素质上。 将一个二叉树反向打印: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 二叉树反序 a / \\ b c / \\ \\d e f a / \\ c b / / \\f e d*/var a = &#123; value: 'a', left: null, right: null &#125;;var b = &#123; value: 'b', left: null, right: null &#125;;var c = &#123; value: 'c', left: null, right: null &#125;;var d = &#123; value: 'd', left: null, right: null &#125;;var e = &#123; value: 'e', left: null, right: null &#125;;var f = &#123; value: 'f', left: null, right: null &#125;;a.left = b;a.right = c;b.left = d;b.right = e;c.right = f;// bad idea but usefulfunction walkTree(root, current) &#123; var obj = current ? current : root; if (obj.left || obj.right) &#123; var temp = obj.left; obj.left = obj.right; obj.right = temp; walkTree(root, obj.left); &#125; else &#123; // 一侧或者两侧已经遍历完的情况 if (!this.shouldStop) &#123; this.shouldStop = true; walkTree(root, root.right); &#125; else &#123; console.info(JSON.stringify(root, null, 2)); &#125; &#125;&#125;// better ideafunction walkTree(root) &#123; if (root.left || root.right) &#123; var temp = root.left; root.left = root.right; root.right = temp; root.left &amp;&amp; walkTree(root.left); root.right &amp;&amp; walkTree(root.right); &#125; console.info(JSON.stringify(root, null, 2));&#125;walkTree(a); 未完待续……","link":"/jo.github.io/2017/01/05/questions-in-interview/"},{"title":"理解 React 组件的生命周期","text":"近期 React 可谓是站在了风口浪尖上。某些大厂们纷纷开始抛弃它转而使用其他框架。但实际上，React 只手遮天的势力难以一时磨灭，我们这些小厂里的前端其实不必太过担心。真到了 React 末日的时候，这个世界也一定发生了巨变。所以，在当下，我们还是专注于当前，使用好 React. 于是我在这里总结了这大半年使用 React 的体验，主要是组件的生命周期和它常见的应用场景。 生命周期钩子方法组件的挂载阶段 constructor componentWillMount render componentDidMount componentWillUnmount constructor 执行阶段：在开始 render 之前。 在这里进行 state 的初始化工作。但不要使用 setState. 还可以做一些事件绑定的工作。 Note: 如果既不绑定事件也不初始化 state, 那么其实可以不使用 consturctor. 在少数情况下，constructor 中的 state 可以使用 props 来替代，但如果要达到状态随 props 改变的效果，最好使用状态提升来实现，因为 state 并不会随着 props 的改变而改变。 123456constructor(props)&#123; super(props) this.state = &#123; type: props.initialType &#125;&#125; componentWillMount 执行阶段: 组件将要挂载的阶段。在 render 前调用，只会调用一次。 这里或许可以添加一些接口请求数据的逻辑，但在这里进行 state 的更新是异步的，它并不会触发 re-render 也就是 render 重新渲染。通常情况下，更推荐使用 constructor 来替代. Note: 如果要避免一些副作用，更好的办法是将这里面的逻辑放在 componentDidMount 里来处理。 render 渲染挂载组件。这步一定会执行的。 在正常状态下，该方法会返回以下几种类型的值： React element: 最常见的返回。即使用 JSX 创建的原生 DOM 或自定义的组件例如 &lt;MyComponent/&gt;. Protal: 使用 ReactDOM.createPortal 方法创建的对象。 Boolean: bool &amp;&amp; &lt;div/&gt;, 当 bool 为 false 的时候，不渲染。 String|Number: 文本节点。 null: 不渲染。 Note: 该方法是纯函数，不应有 setState 的操作。每次渲染只会输出同一个值。如果有对状态的变更，应该是放在 componentDidMount 里。 该方法是可以返回数组的，这样就可以返回多个对象。 1234567render() &#123; return [ &lt;div key=\"A\"&gt;First&lt;div/&gt; &lt;div key=\"B\"&gt;Second&lt;div/&gt; &lt;div key=\"C\"&gt;Third&lt;div/&gt; ]&#125; componentDidMount 组件挂载完毕时即调用。生命周期内只会调用一次。 应用场景：通常可以将请求后端数据—— ajax/fetch 放在这里。此时界面上 DOM 已经存在。可以做有关 DOM 的操作。例如 findDOMNode. Note: 在这里调用 setState 会进行一次额外的 rendering,虽然这会导致两次的 render, 但用户不会察觉这过度的时间。可能要多加考虑的地方是这会导致一定的性能问题。 componentWillUnmount 执行阶段：当组件卸载的时候的回调函数。 应用场景: 适用于清除定时器，取消请求等逻辑。 Note: 这个函数回调适合销毁那些在 componentDidMount 里创建的方法。 更新阶段 componentWillReceiveProps componentShouldUpdate componentWillUpdate render componentDidUpdate componentWillReceiveProps componentWillReceiveProps(nextProps) Note: 每次接收到新的 props 调用。注意这里是接收到 props 就调用，但 props 的值不一定就和原来的值不一样，有可能还是相同的。在某些情况下，这会造成重复渲染。 在组件完全挂载后才会调用。在完全挂载之前是不会调用的。 可以在这里比较 props 和 nextProps, 然后更新 state, 但 setState 不会触发该方法。 shouldComponentUpdate shouldComponentUpdate(nextProps, nextState) 当每次 props 或 state 更新时调用。在首次 render 之后的每次 render 之前执行。 Note: 该方法的返回值将会影响 componentWillUpdate、render、componentDidUpdate 的执行。但在未来这一点有可能会改变。 可以在这里可以进行一些值是否相等的判断，但最好不要将对象，数组等判断放在这里，因为这可能会引起性能问题。 componentWillUpdate componentWillUpdate(nextProps, nextState) shouldComponentUpdate 方法返回 true 之后执行。 Note: 在这里不能调用 setState 方法，也不能进行 redux 的 action, 因为他会重复调用该方法。 如果需要在 state 更新后操作 props, 把这部分逻辑放在 componentWillReceiveProps. render 渲染挂载组件。 componentDidUpdate componentDidUpdate(prevProps, prevState) 在初次 render 以后的每次渲染之后执行。执行逻辑和 componentWillUpdate 一样，当 shouldComponentUpdate 返回 false 时不会执行。 应用场景：该方法总是在 DOM 存在后才会执行，所以可以在这里进行一些操作 DOM 的逻辑。也可以在这里发起一些网络请求，但前提 props 发生了更改，否则可能也会引起性能问题。 componentDidCatch (16版本引进) componentDidCatch(err, info) 捕捉异常。 try/catch 固然很好，但它会立即捕获异常。在 React 中，有时我们虽然遇到错误，但不希望影响挂载或渲染过程。所以统一在这个回调里进行处理。对用户来说，业务仍然是正常的，错误维护了 React 的生态，并不会影响组件挂载。 React 组件都必须是纯函数，并禁止修改其自身 props. 这里以图片形式更直观地来理解这整个生命周期流程 组件的生命周期流程图 PS: 截止 9 月份，React 宣布将会随着 16 版本更新，修改原有的 license， 将原专利许可和 BSD 协议改为 MIT 协议。算是给这场风波一个较为圆满的结果。参考： 1.react 2.reactchectsheet 3.reactjs","link":"/jo.github.io/2017/08/30/react-component-lifecycle/"},{"title":"DOM 重要知识点回顾","text":"回顾部分重要的 DOM 知识点。 DOM 元素的增删改查。 获取或设置元素的属性。 DHTML 动态HTML。 一系列实现网页动态效果的技术统称。 区别: HTML：超文本标记语言，标签名固定。 XHTML：更严格的HTML语言标准。 XML: 可扩展的标记语言，标签名可自定义，语法和HTML完全相同。 JS(ECMAScript、DOM、BOM) ECMAScript(核心语法)。 文档对象模型。 浏览器对象模型。 DHTML: 7大内置对象 window: 指代当前浏览器打开窗口。 document: 指代当前页面的HTML文档。 navigator: 封装了浏览器软件的版本信息和部分设置。 history: 封装当前窗口成功浏览过的网址的历史记录栈。 location: 指代当前窗口中地址栏。 screen: 指代当前显示器。 event: 指代事件对象。 DOM 网页中一切内容都是节点(Node)对象。 所有节点对象以树形结构组织在一起(Dom Tree)。 增删查改。 DOM TREE 网页加载时生成的文档模型。 Document: Dom Tree根节点, 网页加载完成自动生成。 继承自 HTML Document 的原型，Document 的原型中提供了 document 对象可用的 API. 节点对象 元素节点对象：指代 HTML 文档中每个元素。 文本节点对象：指代 HTML 文档中的文本内容。 节点对象：所有节点对象都继承自一个父对象：Node.prototype. Body 对象：body -&gt; HTMLBodyElement.prototype -&gt; HTMLElement.prototype -&gt; Element.prototype -&gt; Node.prototype -&gt; 所有结节点共有属性. document 对象：document -&gt; HTMLDocument.prototype -&gt; Document.prototype -&gt; Node.prototype. nodeType: 元素节点(1)。 文本节点(3)。 nodeName(返回全大写形式的标签名): 元素节点(标签名)。 文本节点(#text)。 nodeValue: 文本节点(文本内容)。 元素节点(null)。 节点关系 父子关系: node.parentNode: 获得 node 对象的父节点对象。 node.childNode: 获得 node 对象的所有子节点对象。 node.firstChild: 获得 node 对象下第一个子节点对象。 node.lastChild: 获得 node 对象下最后一个子节点对象。 返回 NodeList 类型的对象。 NodeList 中的节点对象都是基于 Dom 树动态查询。 Dom 树的变化随时反映在 NodeList 中。 遍历所有子节点：1234567891011for (var i = 0; i &lt; node.childNodes.length; i++) &#123; console.log(node.childNodes[i]);&#125;// 每遍历一个元素，for 循环就会重新查找 childNodes 结果// 优化如下for (var i = 0, len = node.childNodes.length; i &lt; len; i++) &#123; console.log(node.childNodes[i]);&#125;` 兄弟关系 node.previousSibling: 获得平级对象的前一个节点对象。 node.nextSibling: 获得平级对象的后一个节点对象。 查找元素 id: var elem = document.getElementById(&#39;id&#39;). TagName: var elems = element.getElementsByTagName(&#39;tagname&#39;). elems是一个动态集合——HTMLCollection类型的对象。 随着页面 Dom 的改变实时改变。 name: var elem = document.getElementsByName(&#39;&#39;). 直接获得表单元素: var form = document.form[&#39;id&#39;].(存疑) elems = form[&#39;name&#39;]. 返回对象或者 HTMLCollection. class(HTML5): var elems = node.getElementsByClassName(&#39;class&#39;). 选择器查找: Selector API 没有兼容性问题。 原生API，执行效率高。 返回值：包含全功能，全属性的元素对象集合。 var elem = element.querySelector(&#39;selector&#39;). var elems = element.querySelectorAll(&#39;selectors&#39;). 读写元素对象内容属性 操作元素的内容：开始标签和结束标签之间的内容。 elem.innerHTML: 开始标签和结束标签的 HTML 原文。 批量替换或删除一个元素下所有子节点的最快速高效的办法。 注意点： 替换内容不要包含事件处理程序。 不是所有元素都支持: table 极其子元素，除了 td 外都不支持。 html/head/style. elem.textContent: DOM 标准。 存在兼容性问题： IE8: elem.innerText. firefox 不支持。 性能问题： 每次设置 innterHTML 时，会临时创建解释器对象。频繁设置会导致内存浪费，效率差。12345678910for (var i = 0; i &lt; values.length; i++) &#123; ul.innerHTML += '&lt;li&gt;' + values[i] + '&lt;/li&gt;'&#125;// 会创建多个解释器对象var lis = [];for (var i = 0; i &lt; values.length; i++) &#123; lis.push('&lt;li&gt;' + values[i] + '&lt;/li&gt;');&#125;ul.innerHTML = '&lt;li&gt;' + lis.join('&lt;/li&gt;&lt;li&gt;') + '&lt;/li&gt;'; 读写元素属性 通过 HTMLElement 类型提供的标准属性: HTML DOM. elem.[attr] 通过 get/setAttribute 函数——核心DOM. elem.getAttribute(&#39;attr&#39;). elem.setAttribute(&#39;attr&#39;). 获取或设置所有属性类型都是字符串。 可读写 HTML 元素中自定义属性。 attribute: 指 HTML 标签中属性或自定义属性。 property: 指内存中对象的属性。 前两种方法不可通用。 读写内联样式 返回一个 CSSStyleDeclaration. CSS 中的属性都是 style 对象的子属性。 所有 CSS 紫属性都返回带单位的字符串。 例如：console.log(elem.style.width); // &#39;100px&#39; 子属性的命名规则，去横线，改驼峰。 修改属性： elem.setAttribute(&#39;style&#39;, &#39;style string&#39;). elem.style.cssText = &#39;style string&#39;. 移除属性： elem.style.removeProperty(&#39;attr&#39;). 大量修改样式建议如下： CSS 中为元素的不同状态定义样式类 JS 中控制对应的样式类改变 遍历 DOM TREE 遍历：以任意元素对象开始，以深度优先的原则，获取所有子对象。 递归：函数内调用自己123456789101112var blank = [];function getChildren(parent) &#123; console.log(blank.join('') + '|-' + (parent.nodeType != 3 ? parent.nodeName : parent.nodeValue)); if (parent.childNodes) &#123; blank.push('\\t'); for (var i = 0, len = parent.childNodes.length; i &lt; len; i++) &#123; getChildren(parent.childNodes[i]); &#125; blank.pop(); &#125;&#125;getChildren(document); 递归遍历 手写遍历元素树：仅包含元素节点的树结构 tree 节点数 元素树 父子节点 — — 父节点 parentNode parentElementNode 子节点 childNode childElementNode(IE8支持) 首末节点 — — 首个子节点 firstChild firstElementNode 最后子节点 lastChild lastElementNode 兄弟节点 — — 前一个 previousSibling previousElementSibling 后一个 nextSibling nextElementSibling DOM 2级遍历API NodeIterator 迭代器： 一个集合中每次金宝村一个对象的游标 游标通过前后移动在集合中遍历每个元素 迭代器1234567891011121314/** * [iterator 迭代器] * @param &#123;Object&#125; parentNode [开始遍历的父节点对象] * @param &#123;String?&#125; nodeType [选择节点的类别(NodeFilter.SHOW_ALL|NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT)] * @param &#123;Function&#125; filterFun [筛选器函数对象] * @param &#123;Boolean&#125; boolean [] * @type &#123;[type]&#125; */var iterator = document.createNodeIterator(parentNode, nodeType, filerFun, boolean);// 调用 nextNode 方法iterator.nextNode();// 待完善 TreeWalker: 用法和迭代器完全一样 新增了部分API，所有如下：firstChild、lastChild、previousNode、nextNode、previousSibling、nextSibling、parentNode. 操作节点创建、删除节点对象 核心 DOM. 创建：var newElem = document.createElement(&#39;tagName&#39;); 12var newElem = document.createElement('tagName');// var a = document.createElement('a'); 在 DOM 树中添加： 1234parent.appendChild(newTag);parent.insertBefore(newTag);parent.replaceChild(newTag);... HTML DOM: 部分常用元素对象可以直接生成。 123456789101112131415// 创建新对象的同事插入 tr 到 table, i 为新行位置的索引// HTMLTableElement:var newTr = table.insertRow([i]);// HTMLTableRowElement:var newTd = tr.insertCell(i);// HTMLSelectElement: onchange(),sel.selectedIndexvar sel = document.getElementById('#select'); // ? 这步存疑var opt = sel.add(new Option('innterHTML', 'value'));// 创建一个新的空对象。// 将第一个参数设置为 opt.innerHTML 属性// 将第二个参数设置为 opt.value// 将 opt 对象添加到 sel 中sel.remove(); // 移除 性能：频繁添加节点会反复解析 DOM 树，导致效率低下。 文档片段：内存中临时保存多个 DOM 节点对象的空间。 12// 向文档片段中临时存入节点对象var tempFrag = document.createDocumentFragment(); 文档片段接入 DOM 树中时，不会在页面显示。 BOMWINDOW 在浏览器中代替 global 对象的全局对象。 全局作用域。 修改或设置浏览器窗口的相关属性。 打开新链接的方式 在当前窗口内替换当前页： 1&lt;a href=\"url\"&gt;&lt;/a&gt; 1var newWin = [window.]open('url', 'self'); 打开新窗口，可重复打开: 1&lt;a href=\"\" target=\"_blank\"&gt;&lt;/a&gt; 1var newWin = [window.]open('url'[, 'blank'] ); // 默认是 blank 打开新窗口，不可重复打开 1var newWin = [window.]open('url'[, 'blank']); 窗口定位、移动 window.innerHeight/width: 浏览器窗口可见区域的大小。 window.outerHeight/width: 浏览器窗口完整大小。 window.moveTo(浏览器窗口左上角 x 坐标，浏览器 左上角 y 坐标). window.moveBy(x 坐标的变化量，y 坐标的变化量). 在打开窗口时制定窗口大小和位置：123456789101112131415/** * [open] * @param &#123;String&#125; strUrl [链接] * @param &#123;String&#125; strName [名字] * @param &#123;String&#125; config ['attr=value, attr=value' 键值对的方式保存] */open('url', 'name'[, 'config']);// 例如：window.open('www.google.com', 'google', 'resizable=no, scrollbars=yes,status=no');// config 可以写：// height/width: 窗口文档显示区大小// top/left: 窗口左上角 x 坐标，y 坐标// resizable: 是否允许调整窗口大小// location: 是否允许修改地址栏 对话框 alert(&#39;warning&#39;); var input = prompt(&#39;tips&#39;); var bool = confirm(&#39;tips&#39;); // 含两个按钮 定时器 周期性定时器：反复执行。 123456789101112131415161718// 定义任务函数。// 全局变量保存定时器的 id.// 启动定时器。/** * [setInterval 周期性定时器] * @param &#123;Function&#125; function [须调用的函数] * @param &#123;Number&#125; time [间隔时间] */var timer = setInterval(fun, time);// 例如：// 定义它：var timer = setInterval(function()&#123; console.log(new Date());&#125;, 3000);// 清空它：clearInterval(timer); 一次性定时器：执行一次任务后便自动退出。 1234567891011121314// 定义任务函数。// 定义全局变量，保存定时器 id.// 启动定时器。/** * [setTimeout 一次性定时器] * @param &#123;Function&#125; function [任务函数] * @param &#123;Number&#125; time [延迟时长] */ var timer = setTimeout(function() &#123; console.log(new Date()); &#125;, 3000); // 清空它： cleatTimeout(timer); NAVIGATOR: 封装浏览器软件版本信息的对象 navigator: 检测插件。 navigator: 检测 cookie 是否启用。 chrome -&gt; 设置 -&gt; 显示高级设置 -&gt; 隐私 -&gt; 内容设置 -&gt; 禁用 navigator.userAgent: 包含了浏览器名称和版本号。 LOCATION: 封装当前窗口打开的 url 信息的对象 window.location === document.location; // true location.search: 获取 url 中查询字符串参数 在当前窗口内打开新 url: 123location.href = 'url';window.location = 'url';location.assign(url); location.replace(&#39;url&#39;): 禁止后退： HISTORY: 当前窗口打开后的历史记录栈123456789// 前进history.go(1);// 刷新history.go(0);// 后退history.go(-1);history.go(-2); SCREEN screen.width/height: 完整分辨率。 screen.availWidth/availHeight: 除去任务栏后的剩余分辨率。 window.innerWidth/innerHeight: 浏览器可视区域的大小，出去控制台等。 window.outerWidth/outerHeight: 浏览器整体大小 事件：网页中，人为触发或自动触发的状态改变 事件处理程序：一个对象的特殊属性。 属性一般引用一个函数对象或 JS 程序块。 当事件发生时，自动执行绑定在属性上的程序。 例如：123456789window.onload = function() &#123;&#125;;btn.onclick = function() &#123;&#125;;txt.onfocus = function() &#123;&#125;;select.onchange = function() &#123;&#125;;// 其他div.onmouseover // 鼠标跨入边界执行div.onmousemove // 鼠标在范围内移动则执行div.onmouseout // 鼠标跨出边界执行 事件流：当事件出发时，内外层元素间的时间出发顺序 DOM 标准事件流：由外向内捕获 -&gt; 目标触发 -&gt; 由内向外冒泡触发。 IE8 事件流： 目标触发 -&gt; 由内向外冒泡触发。没有捕获阶段。 绑定事件处理程序 HTML 中设置事件属性: &lt;div onclick=&quot;javascript&quot;&gt;&lt;/div&gt; // this 必须从页面中传入 DOM0 级 API: JS 中设置对象的时间属性 obj.onclick = function() {}; // this 指代正在调用时间处理程序的元素对象 存在以下两个问题： 无法改变事件流中事件触发的顺序。 同一对象的统一吹函数，同时绑定多个函数对象。 DOM2 级标准 API: obj.addEventListener(&#39;click&#39;,function(){}[, boolean]); // 依次传入事件名，函数对象，是否在捕获阶段触发 IE8 的处理：obj.attchEvent(&#39;click&#39;, &#39;function() {}&#39;); // 依次传入事件名，函数对象 EVENT: 事件触发时自动创建，自动传入事件处理函数内(默认为第一个参数) 获取：var event = window.event || arguments[0]; // 在函数内使用 获得事件源(目标对象)：var src = event.target || event.srcElement; // this 随着事件冒泡而变化 取消冒泡： event.cancelBubble = true; // IE event.stopPropagation(); // DOM 兼容写法：if (e.stopPropagation) { e.stopPropagation(); } else {e.cancelBubble = true;} 取消事件：取消事件的默认行为，停止继续执行 if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; }","link":"/jo.github.io/2017/02/12/review-dom/"},{"title":"回顾JS——第一部分","text":"因面试时裸面的惨痛教训，特此回顾从前所学的JS。这个办法也许很蠢，但她肯定有效。 回顾JavaScript知识点(ES3,ES5为主，部分ES6)什么是JavaScript JavaScript: JS是一种轻量的，解释性的，面向对象的头等函数语言。其最广为人知的应用是作为网页的脚本语言，但同时它也在很多非浏览器环境下使用。JS是一种动态的基于原型和多范式的脚本语言，支持面向对象，命令式和函数式的编程风格。 JavaScript的标准就是ECMAScript.截至2012年为止，所有的主流浏览器都完整的支持ECMAScript 5.1, 旧式的浏览器至少支持ECMAScript 3标准。2015年6月17日，ECMAScript的第六个版本正式发布，该版本正式命名为ECMAScript 2015, 但通常被称为ECMAScript或ES6。 网页中编写JS 使用script标签 可以写在页面的任何位置，随网页解释执行 元素的事件属性 事件触发后，才会执行事件处理程序 &lt;div onclick=&quot;window.alert(&#39;Send me a job! Please!&#39;)&quot;&gt;&lt;/div&gt; 单独的JS文件 &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; 变量 内存中一个数据的空间 JS中变量不能以数字开头，不能使用保留字，如果有多个单词，一般采用驼峰命名 可以使用_或$开头，这是唯二的例外，目前所知。 规范： 变量一定要声明，ES5前使用var，ES6后使用let或const. 变量的声明通常在文件顶部(ES5前)，避免因声明提前造成的问题。 数据类型 原始类型 Undefined: 一个没有被赋值的变量会有默认值undefined. Null: null,常用于清空变量。 String: JS的字符串类型用于表示文本数据。它是一组16位的无符号“整数值”的元素。一旦创建便无法更改。 Number: ECMAScript中只有一种数字类型：基于IEEE 754 标准的双精度64位二进制格式的值(-(2^53 - 1) 到 2^53-1)，没有像Java里的那种浮点数整数之分。 Boolean: 布尔表示一个逻辑实体(true/false). Symbol (ES6新增): 符号类型是唯一的并且是不可修改的，而且可以用来作为Object的key的值。 引用类型(Object): 对象是指内存中的可以被标识符引用的一块区域。 使用typeof操作符判断对象类型。 数据类型转换 JS是弱类型编程语言 声明变量时，无需提前规定变量的数据类型。 赋值时，根据存入数据，动态决定数据类型 运算时，JS会根据需要动态转换数据类型(隐式转换) 隐式转换和强制转换 强制转换 x.toString()、String(x) parseInt(x)、parseFloat(x) Boolean(x) typeof x 查看x的数据类型 严格模式 ES5中的严格模式是JS中的一种限制性更强的变种方式。 严格模式会将JS陷阱直接变成明显的错误。 严格模式修正了一些引擎难以优化的错误，同样的代码有些时候严格模式会比非严格模式下更快。 严格模式下禁用了一些有可能在未来版本中定义的语法。 运算 n++: 将变量本身的值+1，并返回新值 ++n: 将变量本身的值+1，并返回旧值1234var n = 12;var n1 = n++; // n1 = 13;m = 12;m = ++m; // m1 = 12; 比较操作符 严格比较操作符 === 非严格比较操作符 == Object.is()(ES6新增) Object.is(value1, value2) 和严格比较操作符类似，但更规范 关系运算 关系运算中，所有数据默认转为数字类型比较 如果无法转为数字，就会转为NaN,如果转为NaN，那不管另一半是什么，都会返回false,NaN和任何数据(包括它自己)比较 如果是俩字符串比较，则会依次比较字符串中每个字符的unicode码，只要任意一位字符比较出结果就不再继续向后比较 12345var name1 = 'Eric'; name2 = 'Scott';name1 &gt; name2; // false 'E' -&gt; 69, 'S' -&gt; 83var name3 = 'Smith';name2 &gt; name3; // false 'c' -&gt; 99, 'm' -&gt; 109 undefined: 自动初始化变量 null: 主动清空变量12345undefined == null; // true 含隐式转换undefined === null; // false 不含隐式转换typeof null // objecttypeof undefined // undefined 逻辑运算 &amp;&amp; || 位运算赋值运算 如果是原始类型赋值，则原变量不会随着新变量的改变而改变。 如果是引用类型的赋值，新变量的改动会随之影响原变量，使其一起改变。因为本质上，它们指向同一对象。 三目运算 condition ? expr1 : expr2 函数 在JS中，函数是一等公民，它不仅像对象一样拥有属性和方法，还可以被调用。 一个函数定义(函数声明，函数语句)由以下三部分组成: 函数名(name). 函数参数列表(params): 包围在括号()中并由,分隔。 函数功能(statements): 包围在花括号{}中，用于定义函数功能的一些 JavaScript 语句。 12345678/** * [square 输入一个数，返回该数的平方的函数] * @param &#123;Number&#125; number [description] * @return &#123;Number&#125; [description] */function square(number) &#123; return number * number;&#125; ​ 变量作用域 全局作用域 保存在全局window对象下，任何位置都可以访问 意味着也随时可以修改 函数作用域 保存在函数内：随每次函数调用时，临时创建。函数调用完即释放内存空间。再次调用再次创建。 声明提前：JS程序正式执行前，引擎会预读var和function到当前作用域的顶部，而赋值留在原地。 按值传递：在向函数传入参数时，外部变量仅将值复制一个副本给函数的参数变量。 函数内修改参数变量，不影响函数外原变量(原始类型)的值。理论同赋值运算。 全局函数，可以在全局进行调用的函数。 parseInt/parseFloat isNaN isFinite eval encodeURI/decodeURI encodeURLComponent/decodeURIComponent 程序结构 顺序结构 分支结构 if else switch case: 当一个case触发时，之后的所有的case都自动触发。 使用break来退出当前结构。 相邻俩case需要连续时，可省略前一个case中的break。 循环结构 循环三要素：循环条件，循环变量，循环体 while、do while、’for’1234567891011121314// whilevar n = 0;while(n &lt; 3) &#123; console.log('n = ' + n); n++;&#125;// n = 0; n = 1; n = 2;// do whilevar n = 4;do &#123; console.log('n = ' + n);&#125; while(n &lt; 3);// n = 4; 数组程序 = 数据结构 + 算法 数据结构：程序中数据如何存储的机构 算法：程序的执行步骤：顺序、分支、循环 数组类型 数组不限制元素个数，数组中的元素可以为任意类型 关联数组(hash数组) 为每个元素自定义字符串下标 12345var arrM = [];arrM['name'] = 'Sandra';arrM['shx'] = 80;arrM['yw'] = 65;arrM['yy'] = 95; 关联数组的下标没规律。 关联数组的length属性无效。 使用for in循环遍历 索引数组：自动从0开始，每个元素有各自编号 1var arrM = ['Sandra', 80, 65, 95]; 数组常用API toString、 join、 sort 、 concat、 slice、 splice、 reverse、 reduce、 reduceRight、 map、 filter… 控制台里看一下 栈和队列(数据结构) 栈和队列：JS中没有专门的栈和队列的类型，是用数组模拟的 栈：一端封闭，只能从另一端进出（仅适用于JS） FILO：first in last out 队列：只能从末尾进入，从头出的数组 LIFO： last in first out","link":"/jo.github.io/2017/01/15/review-js-part1/"},{"title":"回顾JS-第二部分","text":"第二部分。 JS中内置对象 String、 Number、 Boolean、 Array、 Date、 Math、 RegExp、 Error、 Object、 Function、 Global(window) 注意和基本数据类型的区别。 包装类型？：临时封装原始类型数据，并提高对数据操作方法的对象————类型名和原始类型名相同。 正则表达式 贪婪模式：默认情况下，正则表达式会匹配最大的符合条件的字符串。 懒惰模式：仅匹配最小的符合规则的字符串。 12345678// 筛选网页中的a元素// 贪婪模式 =&gt; 懒惰模式 .*?// 贪婪模式&lt;a\\s+(.*)href\\s*=\\s*[\"\"]([^\"\"]*)[\"\"]// 懒惰模式&lt;a\\s+(.?)href=\\s*=\\s*[\"\"]([^\"\"]*)[\"\"] RegExp 封装一个正则表达式，提供了利用正则表达式执行验证和查找的功能 12345678// 正则不会改变时var reg = /正则表达式/ig;// 正则可能会改变时var reg = new RegExp('', 'ig');// 注意转义 '\\'和'\"'new RegExp('^\\\\s+|\\\\s+$', 'ig');new RegExp('&lt;a\\\\s+(.*?)href\\\\s*=\\\\s*[\\'\\\"][^\\'\\\"]*[\\'\\\"']', 'ig'); RegExp API String: match: 所有关键内容的个数 search: 查找有没有,返回布尔值 RegExp: reg.exec(str):既获得内容，又获得位置 reg.text(str):返回布尔值 MathMath API ceil、 floor、 round、 pow、 sqrt、 random Date 每个时间都有get/set方法，除了setDay. 命名: 年月日星期不带s结尾 时分秒毫秒以s结尾 取值: 只有月中的日从1开始到31结束 其余都是从0开始，到进制-1结束 所有set方法，都会自动调整进制. 时间计算： 两日期对象相减：得到毫秒差 -&gt; 进制 -&gt; 小时 单个时间点做加减(人为操作) 取分量 做加减 set 回去 时间显示: date.toString(): 默认以标准时间显示日期 date.toLocaleString(): 将日期转为操作系统当地时间 date.toLocaleDateString(): 仅获取Date对象中的日期部分 date.toLocaleTimeString(): 仅获取 Date对象中的时间部分 错误处理 错误：程序运行过程中发生的异常状态。 错误处理：当程序发生错误时，保证程序不退出的机制。 发生错误时，程序会自动抛出一个Error对象: Error对象中封装了错误信息。 JS中的6种错误对象: SyntaxError: 语法错误。 ReferenceError: 引用错误。 TypeError: 类型错误，错误的使用了类型或类型的方法。 RangeError: 范围错误，特指函数的参数范围。 EvalError: 调用eval函数时发生的调用错误。 URLError: URL错误。 1234567891011try &#123;// 正常执行流程(可能出错)&#125; catch(err) &#123;// 错误发生时执行的代码// 1. 记录/显示错误信息// 2. 继续向调用者抛出异常&#125; [finally &#123;// 非必须// 无论对错，必须始终执行的代码// 一般finally, 释放占用的资源&#125;] 错误处理中的 return: 其他位置的 return 会先确定要返回的值，暂时挂起，再执行finally,finally中的操作不影响其他位置已经确定的 return 值。 finally 中有 return, 会替换其他位置的 return. 应用场景： 用户输入数据可能出现的问题。 使用个别浏览器不兼容的对象。 向服务器发送/接收消息时。 null/undefined. 抛出自定义错误 自己实现的函数，被他人调用时，为了向浏览器提示开发错误，都要主动抛出错误信息。 throw new Error(&#39;信息内容&#39;) 该代码片段后的代码不再执行 优先选择if else, 因为try catch更占资源，创建了新的变量err等等 Function对象 普通对象：封装数据，并提供对数据的操作。 函数对象：不封装数据，反而是一个可调用的对象。 重载： 多个函数(方法), 拥有相同的函数名，但不同的参数列表。调用时，可根据传入的参数值列表，自动调用匹配的函数。 当一件事可能根据参数的不同，执行不同的流程时，使用重载。 JS使用arguments对象(类数组对象)，模拟重载的效果。 函数创建方式： 123456789101112// 1. 声明方式,声明提前，可以写在任意地方function getName(name) &#123; return name;&#125;// 2. 直接量方式,必须写在调用地方之前var getName = function(name) &#123; return name;&#125;// 3. 构造函数方式(必须使用字符串包裹),执行效率低，因为在运行时动态修改函数体的内容var getName = new Function('name', 'return name'); 内存中的函数对象(待理解) 声明函数时，创建了两个对象。 函数对象：保存函数的定义本身。 作用域链对象：顺序保存了函数可用的变量范围的地址。 默认情况下：作用域链对象只有一个元素，指向 window. 调用函数时， 在作用域链对象中追加一个新元素。 新元素指向将要创建的函数对象。 创建本次调用的活动对象。 活动对象：调用临时创建的，仅保存函数的局部变量的对象。 调用时，使用便利的优先级遵循先局部，后全局的顺序。 如果活动对象中有，就不用全局。 调用后，作用域链中指向活动对象的引用，出栈活动对象的引用出栈，活动对象变回垃圾，被回收，局部变量不复存在。 匿名函数 一个函数只被调用一次——自调的方式。 函数不是自己调用，传递给别人用——回调。 1234// 回调arr.sort(function(a, b) &#123;return a-b;&#125;)// 自调(function(a, b)&#123;return a-b;&#125;)(); 闭包 希望共享局部变量，又不希望被随便篡改时，就要构建一个闭包结构。 使用外层函数封装受保护的局部变量。 在外层函数内定义专门操作局部变量的内层函数并返回。 在全局调用外层函数，获得内层函数的对象，保存在全局变量中反复使用。 特点： 嵌套函数。 内层函数使用了外部函数的局部变量。 内层函数对象被返回到外部，在全局反复调用。 作用：保护可共享的局部变量。 外层函数调用了几次，就有几个受保护的局部变量。 12345678910function fun() &#123; var n = 999; nAdd = function() &#123;n += 1;&#125;; function f2()&#123;alert(n)&#125;; return f2;&#125;var result = fun(); // 创建了一个闭包result(); // 999nAdd(); // 使局部变量n+1result(); // 1000 OOP: 面向对象程序设计 对象：程序中描述现实中一个物体的属性和功能的机构。 一个对象代表现实中的一个物体。 封装事物的属性和功能的结构。 创建对象的几种方式 对象直接量。 123var obj = &#123; key: value&#125; 使用构造函数创建多个统一结构的对象,可以反复创建。 1234567891011121314// 定义构造函数function OperateFun(name, age) &#123; this.name = name; this.age = age; var _this = this; this.getName = function ()&#123; return _this.name; &#125;&#125;// 调用该构造函数var obj1 = new OperateFun('Lily', 45);console.log(obj1.name);console.log(obj1.age);console.log(obj1.getName()); 过程中执行了以下四步： new 创建空对象空间。 调用构造函数，在对象中添加属性和功能。 将新对象的 __proto__ 属性指向构造函数的 prototype 对象。 将新对象地址，返回调用者。 创建空对象，再设置属性。 123var obj = new Object();obj.name = 'Sun';obj.age = 17; 使用Object.create()方法创建对象。 1234567891011121314151617/** * [Object.create description] * @param &#123;Object || null&#125; proto [一个对象，作为新创建对象的原型] * @param &#123;Object&#125; prpertiesObject [可选参数，属性与值] * @return &#123;Object&#125; [description] */// 一个原型为null的空对象var obj1 = Object.create(null);// 以字面量方式创建的对象var obj2 = Object.create(Object.prototype, &#123; // name会是新创建对象的数据属性 name: &#123; writable: true, configurable: true, value: 'Hency' &#125; &#125;); this this: 只用于对象中的方法，访问对象自己的属性 this指代正在调用方法的当前对象 this和定义在哪无关。只和调用时的对象有关。 原型 面向对象：封装，继承，多态 原型：几种保存所有对象公用属性值的方法的对象。 每个函数都有一个属性prototype,指向自己的原型对象。 每个对象都有一个proto属性，指向创造自己的构造函数的原型(prototype). 重点作用于构造函数。 封装：将现实中一个事物的属性和功能，集中定义在程序中的一个对象里。 多态：一个对象在不同情况下显示不同的状态。JS中对多态支持不好，只讨论重写。 继承 继承：父对象中的属性值或方法，子对象可以直接使用。 设置子对象继承父对象：3种1.单独修改一个对象的父对象，不影响其他对象。 Object.setPrototypeOf(childObject, parentObject); 2.直接修改构造函数的原型对象。 不影响已创建的对象，会影响之后新创建的对象。 3.创建新对象同时，手动设置父对象。 Object.create(parentObject, null); 检查两对象之间的继承关系(包含整个原型链上的所有父对象): parentObject.prototype.isPrototypeOf(childObject); 原型链 原型链：由每个对象的proto构成的多级继承关系。 所有对象的原型链的顶部都继承自Object.prototype. Object.prototype.__proto__ === null; // true 所有函数对象的原型链一定都继承自Function.prototype. Function.prototype._proto__ === Object.prototype; // true 检查某个对象中是否拥有指定的属性或方法 检查原型链中是否包含 属性名 in 对象 =&gt; name in Object. 判断存在: if (Object.name !== undefined || Object.name) 仅检测自有属性: Object.hasOwnProperty(Object.name); 扩展内置对象的内置方法 12345678910111213141516// 给Array添加类似String的indexOf方法// 首先检查原来的原型链中是否有该方法function indexOf(value) &#123; if (!this.indexOf &amp;&amp; !Array.prototype.indexOf) &#123; // 疑问: 为什么这里this.indexOf in Array.prototype 会返回false // 使用this来指代当前的调用对象(数组) for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] === value) &#123; return i; &#125; &#125; return -1; &#125;&#125;// 可以简写成以下这样Array.prototype.indexOf = Array.prototype.indexOf || indexOf;","link":"/jo.github.io/2017/01/25/review-js-part2/"},{"title":"sublime text插件安利之wakatime","text":"今天发现一款十分优秀的插件，可在各种编辑器中使用,我在sublime中首先使用了它。 万能的它还支持Vscode，Vim,Atom,Webstorm,甚至Chrome中也可使用。 Wakatime 这是一款我觉得非常优秀的插件，以至于我愿意单独把它拿出来说明它的正确打开方式。 通过sublime的常规下载插件方式即可下载。 下面简单说明使用。 官网文档里说的比较详细了，下载后设置api_key参数，就像设置sublime的配置一样。 Awesome Part 来看看令人激动的部分。 1 首先它可以看到每天在编辑器上所花的时间，以及所使用的语言，甚至修改过的文件。 可以看到我每天在各种js之间切换。ts,cs,es6……下面是具体文件 2 还有在各种编辑器上或各种项目上所花的时间。 我也在各种项目和编辑器之间切换(好不专一)。 3 甚至每个项目上具体文件所花的时间。 4 只要connect至gitlab或github，甚至也可以查看commit。 目前支持主流的前端编辑器Vscode,Atom,Vim,Webstorm… 小结：再也不用担心自己碌碌无为的时间都不知道花哪儿去了。让wakatime告诉你答案！","link":"/jo.github.io/2016/09/21/sublime-text-plugin-wakatime/"},{"title":"浅谈JavaScript API设计原则","text":"近期整理项目，发现有一些api的写的比较好，风格统一，流畅，可以对比学习。下面罗列一些设计api时应当遵循的原则。以web-order仓库为例。 1.流畅性 简单易懂 1234567891011var a = _.pick(obj, ['name', 'age', 'address']);_.pick是lodash的方法，从对象obj中取出name和age，address属性。但是这个操作需要经常调用，完全可以封装起来。function a(obj)&#123; return _.pick(obj, ['name','age','address']);&#125;这样每次调用a方法即可。明确易用。 可读性 1234567891011一开始接手这个web-order的时候，我是非常头疼的。到处是函数式编程，一层嵌套一层。这个时候如果没有交接，代码对新接触的人来说是非常痛苦的，所以有必要增强方法的可读性。下面是整理过后的：function generateChoosenPeople(people)&#123; return _.pick(people, ['name','age','address']);&#125;获取选中的人————名字即说明了该函数做的事情，可读性较好。但是，还有一点并不太令人舒服的地方，就是名字取得太长了。容易读懂，但不容易记住，也不方便使用。所以就需要下一点。 减少记忆成本 1234567将名字简化：function getMan(man)&#123; return _.pick(man, ['name','age','address']);&#125;这样既简明，也方便调用。 2.一致性 api的一致性 现在的项目中，一个人开发一个项目的情况非常少见，而且即使一个人开发，代码的风格统一也是很有必要。更何况通常是多人开发。目前遇到的最头痛的一个问题，不是不知道一个问题怎么解决。而是要尝试解决的时候要先上手，看懂别人的代码，毕竟总不能说重写就重写。 请看下列方法取名： 12345closeTips();closePrintModel();printChoosenOrder();getListByOrderPackage();getOrdersLength(); 对这些方法的第一印象是很长。但仔细看，api命名风格是统一的。各方法做什么事都在名字中已体现。一目了然，清晰明确。大大减少上手时间。 规则很简单： 1.一律采用驼峰命名，首字母小写。 2.第一个单词是动词。 3.错误处理 预见错误并处理错误 在第一个示例中提到的方法，getMan,要求传入的参数是对象，但如果传入的是数组或是字符串呢，这个时候就需要对参数进行检查并抛出错误。 对方法改写如下： 1234567891011function getMan(man)&#123; if (Array.isArray(man) || typeof order !== 'object' ) &#123; console.error('param a must be type of string'); return; &#125; return _.pick(man,['name','age','address']);&#125;当传入参数不符合条件的时候，先抛出错误。先判断是不是数组，然后再判断是不是对象，否则就抛出错误。 另一个常见的是ajax请求的错误处理，最先接触ajax的时候，从没想过请求失败的情况。经同事提醒，才了解到这样对用户很不友好。 上一个最早写的ajax请求,用angularjs的http： 1234$http.get('http://123lalala.com/test').then(() =&gt; &#123; // do something...&#125;) 这种情况只考虑了正常的情况下所做的操作，没有考虑其他情况。 其实很简单，只要再加上一段。但是之后对用户就友好许多，增加了错误提示。 12345678$http.get('http://123lalala.com/test').then(() =&gt; &#123; // do something&#125;, (err) =&gt; &#123; console.error('请求失败'); // or window.alert('请求失败' + err.msg);&#125;) 4.后续如果有补充再更新，有疑问或指正请提出。","link":"/jo.github.io/2016/06/23/talk-about-JavaScript-API-design/"},{"title":"升级 MacOs Mojave 后的兼容问题解决","text":"升级 MacOs Mojave 后不免会遇到兼容性问题，这里列举几个自己遇到的，后面列出了解决方案。推荐：★★☆ 索引 问题概览 小结 参考 问题概览 终端启动报错 xcode运行报错 vim报错 终端启动报错问题描述 打开终端时，直接报错 manpath: error: unable to read SDK settings for &#39;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk&#39; 解决方案 升级 xcode 和 commandline tools. 在应用商店里升级 xcode 后，运行 xcode-select --install. 再重启终端即可。 xcode运行报错问题描述 打开 xcode 跑项目时，之前可以跑的项目无法运行。 解决方案 打开 File =&gt; Project Setting, 将里面的 Build System 的 New Build System 选项改为 Legacy Build System. 升级前就是这个选项 Legacy Build System. vim报错问题描述 在运行 git commit --amend 等不直接使用 vim 的命令时，报错。 12345Vim: Caught deadly signal SEGVError detected while processing function 70_PollServerReady[7]..70_Pyeval:Vim: Finished.line 4:Exception MemoryError: MemoryError() in &lt;module 'threading' from '/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.pyc'&gt; ignored 解决方案vim 直接报错 重新下载 vim. 运行 brew install vim --with-lua --with-override-system-vi 重启 shell. 如果是 vim 直接打开的报错。那么以上步骤可以解决问题。 vim 其他报错 如果是在运行其他命令时出现该报错。则很可能是 YouCompleteMe 插件的问题。 首先继续执行上述重新下载 vim 的步骤。 然后进入对应目录下。 cd ~/.vim/bundle/YouCompleteMe 更新代码插件的代码。 git pull 更新子模块的代码。这步很重要，不能遗忘。 git submodule update --init --recursive. 更新后需要重新编译插件，在当前目录下执行编译。 python install.py 如果不编译，会出现这样的报错。 The ycmd server SHUT DOWN (restart with &#39;:YcmRestartServer&#39;). YCM core library too old; PLEASE RECOMPILE by running the install.py script. See the documentation for more details. 问题解决。 如果报错依然存在，试试在 ~/.vimrc 文件中先将 YouCompleteMe 插件注释，再取消注释后重启。 小结 以上是目前在升级系统后遇到的兼容问题，都得到了解决。后续再遇到问题，再进行补充。 参考Update MacOS to Mojave, then vim get error with powerline更新 macOS Mojave 后 vim 打不开","link":"/jo.github.io/2018/11/23/the-compatibility-issues-in-macos-mojave/"},{"title":"Sublime Text 3 高效插件配置","text":"不久前，sublime text 官方推出了一次大更新。这次更新几乎时隔一年，而且有重大改动，虽然我早用 dev 版提前体验了新版本，但也借此机会再鼓捣了下自己的工具。 索引 Sublime Text 插件 Sublime Text 下载 插件1. Git 在 sublime 内使用 git. 因为我个人是在终端使用 git. 所以日常 git 不会在这里提交。但有一个比较实用的功能是查看当前文件的修改历史。比在终端里用 git log -- [file] 查看会方便一些。 在命令面板输入 git log current file 可以查看当前文件修改历史，查看有谁改过当前这个文件和具体改动了什么。 2. Git blame 查看当前行的修改历史。比前一个插件更加具体，直接查看当前行的最近一次改动负责人和提交记录。 git 插件也有该功能，但使用起来不如这个方便。 3. GitGutter3.1 Modific 在行号前形象地显示当前的改动差异。 后者也是一个可以显示改动的插件——但是它还支持 SVN 等。可选其一使用。 4. SublimeLinter、SublimeLinter-contrib-eslint4.1 Babel sublime 编辑器内可以配合 eslint 使用来检查代码规范或是代码风格。只是要两个插件配合使用。 两个插件下载完毕即可使用。 如果没有生效的话，可以打开 sublimelinter 的用户设置检查 node 的路径是否正确，或者是否安装了相应的版本。 sublimelinter 官网还有更多使用配置。 该插件对使用 jsx 语法的 js 文件支持不太友好，所以你可能还需要这一个插件 Babel 来解析文件。 5. React ES6 Snippets5.1 React Snippets 写 react 非常实用的 snippets. 如果还没有使用 ES6 的话，那就使用后者。 其他框架自然也有。AngularJS、Vuejs Snippets、Vue Syntax Highlight、j​Query. 6. DocBlockr 友好的注释插件。支持 Javascript, PHP, CoffeeScript, Actionscript, C &amp; C++ 等。 7. cssDOC 右键在 MDN 上查询属性相关信息。快捷方便。 8. SyncedSideBar 打开文件时侧边栏定位到当前文件。在查看文件时会十分方便。 9. BracketHighlighter9.1 BracketGuard 高亮括号对应项。 后者高亮使用错误的括号。 10. Material Theme、DA UI 最后推荐两款清爽的浅色主题。以下是效果图。 清爽干净的 UI,是不是对最新版 sublime 已经跃跃欲试了呢。 下载Sublime Text 在此。嫌 sublime 万年不更的小伙伴可以下载 dev 版 ，其实暗地里啊，它更新地比 vsc 还勤呢。题外话 在这个 vsc 分了半边天的代码工具里，我还是对 sublime 情有独钟。甚至我对 vim 也有着自己的偏爱。即便 vsc 或者 webstorm 方便到了令人发指的地步，我也希望还有人能坚守 sublime 等轻量级编辑器的阵地。因为我喜欢这个鼓捣的过程，喜欢把自己需要的东西一步一步手动加上去的过程，在这个过程中，会更加理解自己需要什么，不需要什么，对那些新增的插件的下载和使用也会有新的理解。而且我也相信有许多程序员和我有着相同的癖好。 偶尔我也会试用 vsc，但确实用不习惯。在丝滑流畅这一点上，它和 sublime 比还有一定的差距。而它相较于 sublime 的优势在我使用时却没有明显体会。类似直接查看函数的定义的功能，我反而认为自己去寻找可以更了解项目的整体结构。最终还是一句话，自己使用起来最舒服的工具就是最适合自己的工具。","link":"/jo.github.io/2017/10/07/the-introduction-of-sublime-text-plugins/"},{"title":"有关 getaddrinfo 报错的解决","text":"有关 getaddrinfo 报错的解决方式。 问题 近期在配置新项目环境的时候遇到了如下问题： 123456events.js:72 throw err;Error: getaddrinfo ENOTFOUND talk.bb at errnoException (dns.js:37:11) at Object.onanswer [as oncomplete] (dns.js:124:16) 经提示后发现是host配置的问题。 因为项目的配置 gulpfile.coffee 文件里是这样的： 12345server.listen config.webpackDevPort, 'talk.bb', (err) -&gt; if err? throw new gutil.PluginError('webpack-dev-server', err) gutil.log '[webpack-dev-server] is listening' cb() 这里的 talk.bb 实际上是替代了 localhost 作用，虽然目前在接手这项目的时候还不知它的作用，但就此去解决的方法就是在 host 文件下增加 talk.bb 配置。 解决 修改电脑的 host 配置，以管理员身份修改，运行 sudo vim /etc/hosts.可见文件如下： 123127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost 在其中增加 talk.bb 即可，如下： 1234127.0.0.1 talk.bb127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost 不知这类的问题算不算是计算机基础问题，依然还有很长的路要走……","link":"/jo.github.io/2017/01/23/the-problem-about-host/"},{"title":"webpack-dev-server 中代理(proxy)相关问题的解决及反思","text":"记一次工作中踩的坑。坑不大，但耗时非常长。 问题 近期刚加入新公司，配置环境方面踩了非常多的坑。有的最后发现其实是非常简单的原因导致，有的到最后也没有找到原因。这里记录一个最近发生的，让自己头疼了很久的问题，最后的解决方式并不难，但解决的过程值得记录和反思。 新项目中使用了 gulp 来配置 webpack, 其中也包括了 webpack-dev-server. 问题便来自于这里。 首先来看看代码： 12345678910# gulp 中一个很普通的 task, 使用 coffeescript 编写gulp.task 'webpack-dev', (cb) -&gt; webpackServer = publicPath: '/' hot: true stats: colors: true proxy: '/api/': target: 'http://localhost:8000' 这里使用了 webpack-dev-server 的 proxy 配置来代理请求，将原 /api/发起的请求发往 localhost:8000, 看起来似乎没有什么问题，实际上也并没有问题所在。 然而，因为某些未知 bug, 我不得不更改 proxy 的 target 对象。实际上，个人认为，前端在调试时，使用本地的后端服务并不恰当，最好是在 dev 环境上进行接口调试。dev 环境提供的服务至少稳定。 因为那该死的 bug, 和刚才说明的考虑，我将这个 target 指向了公司的 dev 站点。 改动很少，大致如下: 12345gulp.task 'webpack-dev', (cb) -&gt; # ... proxy: '/api/': target: 'http://chat.dev.cn' 本以为不会有任何问题，小小的改动怎会引起巨变。然而，坑就这样产生了。开发环境中的 xhr 请求无法请求到原来的接口。但在浏览器中直接打开 http://chatops.dev.cn/api/user 却能得到应有的结果。这让人烦躁，让我心慌。 解决过程 最初碰到这问题的时候，我一脸懵逼，第一反应是这属于 nodejs 相关的问题，但我对 nodejs 接触不多，想到要从一无所知的事物下手，心情更加烦躁。 待冷静下来后，首先想到的是跨域问题。既然 chrome log 里涉及到了 xhr, 那么从跨域的角度或许能找到线索。 不幸的是，我发现，这个代理请求是 nodejs 发出的，并不是浏览器发出，既然不是浏览器发起，那也没有跨域这一说。 随即我反应过来，既然是 webpack-dev-server 的问题，那么从官方文档查看或许会有进展。果然，文档中有如下说明并列举了使用方式。 Proxying local virtual hostsIt seems that http-proxy-middleware pre-resolves the local hostnames into localhost, you will need the following config to fix the proxy request: 我根据文档修改，于是得到如下结果： 1234567891011gulp.task &apos;webpack-dev&apos;, (cb) -&gt; # ... proxy: &apos;/api/&apos;: target: host: &apos;chat.dev.cn&apos; protocol: &apos;http:&apos; port: 80 ignorePath: true changeOrigin: true secure: false 这时我怀着激动的心情重启服务，却得到了失望的结果——接口请求到了，返回的格式却是’text/html’. 一定是有哪里出了问题，但无从得知。心情更加烦躁。 从刚才 webpack-dev-server 的说明中，我又查阅了 http-proxy-middleware 的相关文档，里面有它自己相关的说明，但和 webpack 相关的仍然一无所获。 无奈之下，第一反应是回到万能的 google, 提取关键字 webpack-dev-server 和 proxy，几乎漫无目的搜索后，并没有发现有用的解决办法。 于是我又想到 github issues, 在 webpack-dev-server 开源项目中查找相关 issues, 的确有部分 proxy 的疑问在，但仍然没有可提取的信息。 stackoverflow 上也是同样的结果。这几乎是我最绝望的时刻。 冷静下来，我开始反思，是不是一开始就走错了路。于是我回到了官方文档上，逐一试探。 在尝试了 quiet 选项之后无效。 将端口改为本地一样的 8000 也无效。 我想，虽然不是跨域，但 origin 应当是更改的，changeOrigin 应保留。而 secure 在基础配置里也有，应当也不是。于是我再尝试修改 ignorePath 的值，重启之后，发现竟然成功了。 最后的代码如下： 1234567891011gulp.task &apos;webpack-dev-server&apos;, (cb) -&gt; # ... proxy: &apos;/api/&apos;: target: host: &apos;chat.dev.cn&apos; protocol: &apos;http:&apos; port: 80 ingorePath: false # 默认即为 false,注释掉也可以 changeOrigin: true secure: false 回顾与反思 这个问题，前前后后困扰了我近一个工作日的时间，跨度有好几天。每天都花费了一定的时间在上面，直至今天，用了近半天的时间才得以解决。 事实上，这个问题的本质我还是没有发现，我只是简单地让他生效，并不知其中的原因。等到发现根本原因，理解透彻之后，再回来更新这里。 在解决这个问题的过程中，我先后想到 nodejs, 跨域，官方文档，google, github issues, stackoverflow 到最后回到文档。仔细想想，其中有部分是可以避免的，比如在漫无目的的使用 google 时，搜索的效果其实并不好，提取关键字也不够到位。 而且在每个过程之间，都有一定的时间跨度，这是不足之处。因为在前一种方式尝试过后难以平复失败时的焦躁心情，不能冷静的思考其他可能，才浪费了许多时间。 另外，要拥有一种任何问题都可以搞定的心态，没有搞不定的问题，只有没有信心的人。问题总是可以解决的，只不过有的解决方式并不那么完美，但也许睡过一觉再醒来，再想想，就会发现新的角度。如果一个问题暂时无法解决，那就好好睡一觉，第二天继续干。","link":"/jo.github.io/2017/03/07/the-problems-in-using-webpack-dev-server/"},{"title":"面试题整理-2018","text":"P6 的标准。这里所有的题都应该十分熟悉。推荐：★★★☆ Part 2 2018版 JavaScript 类型判断 函数防抖和函数节流 浅比较和浅拷贝的实现 函数柯里化 ES6 Promise React CSS BFC 行内元素 浏览器 同源策略 跨域方案 前端安全 其他 JavaScript酷家乐面试题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 引用类型(引用值传递和堆栈模型，这是最主要的)var a = &#123; b: 1&#125;function changeA(obj) &#123; obj.b = 2 return obj&#125;let aa = changeA(a)console.info(a.b) // 2console.info(aa.b) // 2aa = &#123; b: 3&#125;console.info(a.b) // 2console.info(aa.b) // 3// 事件模型var len = 6for (var i = 0; i &lt; len; i++) &#123; setTimeout(function() &#123; console.info(i) // 6 个 6，异步执行宏任务 &#125;, 1000)&#125;console.info(i) // 6 异步执行，所以这里优先打印// 考察类型判断和声明提前function temp() &#123; console.info(typeof bbb) // undefined console.info(typeof f) // function 声明提前 bbb = 1 function f() &#123;&#125;&#125;console.info(typeof temp()) // undefined 没有 return 返回值// 匿名函数 this 指向 windowvar obj = &#123; getBar: function() &#123; return this.bar &#125;, bar: 1&#125;;(function() &#123; return typeof arguments[0]() // undefined 相当于 typeof window.bar&#125;)(obj.getBar)// 不用循环实现一个工具函数 f(n, v), 生成 n 个 v 的数组。递归function f(n, v) &#123; return n &lt; 1 ? [] : [v].concat(f(n - 1, v))&#125;f(10, 1) var 变量声明及原型1234567891011121314151617181920212223242526272829303132function Foo() &#123; getName = function() &#123; console.log(1) &#125; return this&#125;Foo.getName = function() &#123; console.log(2)&#125;Foo.prototype.getName = function() &#123; console.log(3)&#125;var getName = function() &#123; console.log(4)&#125;function getName() &#123; console.log(5)&#125;// 请写出以下输出结果Foo.getName(); // 2getName(); // 4 函数直接量的定义会声明提前从而被 var 声明的所取代Foo().getName(); // 1 window.Foo().getName() this 指向 windowgetName(); // 1 由于调用了 Foo().getName()，而该方法\b内没用 var/let 声明的变量，都是 window 的，因此 window 上的 getName 被改写new Foo.getName(); // 2 函数的属性方法调用new Foo().getName(); // 3 函数的原型链上的方法随着继承而调用new new Foo().getName() // 3 函数的原型连上的方法随着继承而调用// 原型var obj = &#123;&#125;obj.__proto__ // Object.prototypeObject.__proto__ // function() &#123;&#125;Object.prototype.__proto__ // nullFunction.__proto__ // function() &#123;&#125;Function.prototype.__proto__ // Object.prototype 类型判断 typeof instanceof： 测试构造函数的 prototype 是否出现在对象的原型链之中。由于 prototype 是可更改的，所以同样的表达式不一定会返回一样的结果。 object instanceof constructor 1234567891011121314151617181920typeof [] === typeof &#123;&#125; // 'object'typeof Object === typeof Array // 'function' 构造函数typeof null // 'object'typeof undefined // 'undefined'typeof NaN // 'number'111 instanceof Number // false'111' instanceof String // false// 因为它们都不是用构造函数实例化的对象，所以不是// 下面则是var num = new Number(111)num instanceof Number // truevar str = new String('curry')str instanceof String // true&#123;&#125; instanceof Object // 报错[] instanceof Array // true[] instanceof Object // true// 通常的判断Object.prototype.toString.call(obj) 函数防抖和函数节流 函数防抖：频繁调用的事件，在事件触发超出时间间隔时才执行，当一次事件执行时，后一次要等时间间隔过去才能再次执行 应用场景：输入框校验，输入完成后进行。 函数节流：指定时间间隔内只触发一次，在间隔内触发多次，则只有一次生效 应用场景： scroll 到底部的判断，debounce 的话只有停止滚动才判断。所以是 throttle. 拖拽，缩放事件等。resize, scroll，mousemove 事件等。 输入框搜索联想 keyup 时间等。 在线 Demo-直观清晰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * [debounce 函数防抖] * @param &#123;Function&#125; fn [执行函数] * @param &#123;Number&#125; delay [延时时间] * @return &#123;Function&#125; [返回函数] */let debounce = (fn, delay = 100) =&gt; &#123; let timer = null // 使用非箭头函数，这样可以获取 arguments 对象 return function () &#123; // 清除上次定时器, 定时器可以用变量保存 if (timer) &#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; // 这里类数组对象可以作为参数传入 fn.apply(this, arguments) &#125;, delay) &#125;&#125;/** * [throttle 函数节流] * @param &#123;Function&#125; fn [执行函数] * @param &#123;Number&#125; delay [延时时间] * @return &#123;Function&#125; [返回函数] */let throttle = (fn, delay = 100) =&gt; &#123; let isRunning = false // 使用非箭头函数，这样可以获取 arguments 对象 return function () &#123; if (isRunning) &#123; return &#125; isRunning = true setTimeout(() =&gt; &#123; fn.apply(this, arguments) isRunning = false &#125;, delay) &#125;&#125;// 举例let throttleEvent = throttle(() =&gt; &#123; console.info(new Date().getTime())&#125;, 1000)let debounceEvent = debounce(() =&gt; &#123; console.info(new Date().getTime())&#125;, 1000)window.addEventListener('scroll', debounceEvent) // 不恰当，只为看效果window.onresize = throttleEvent 函数柯里化 蚂蚁的题。 12345678910111213141516171819202122232425262728293031function sum(a, b, c) &#123; return a + b + c&#125;var currySum = curry(sum)// currySum(1)(2)(3) = sum(1, 2, 3) // 实现这样的效果// 兼容参数个数的实现function curry(fn, args) &#123; let arr = args || [] // 入参，在第二次调用时会有初始值 let len = fn.length // 函数参数的数量 return function () &#123; res = arr.concat(Array.prototype.slice.call(arguments)) // 传入的参数与原来的参数整合 // 参数长度不足时，仍然传入原函数 if (res.length &lt; len) &#123; // 调用柯里化函数，并传入原函数和参数 return curry(fn, res) // 等同于 curry.call(null, fn, res) // 参数长度足够时，输出结果 &#125; else &#123; return fn(...res) // 等同于 fn.apply(null, res) &#125; &#125;&#125;currySum(1)(2)(3) === sum(1, 2, 3) // 6// 30 秒代码上的实现，更加简约// https://30secondsofcode.org/function#curry// args 这里不是很理解const curry = (fn, len = fn.length, ...args) =&gt; &#123; return len &lt;= args.length ? fn(...args) : curry.bind(null, fn, len, ...args)&#125; ES6Promise12345678const wait = ms =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms))wait().then(() =&gt; console.info(4))Promise.resolve().then(() =&gt; console.info(2)).then(() =&gt; console.info(3))console.info(1)// 1 2 3 4// 传递到then中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在JavaScript事件队列的所有运行时结束了，事件队列被清空之后才开始执行.// 微任务(promise)优先于宏任务(setTimeout)执行。 Promise 串行的实现 reduce 方法的思路 123456789101112131415161718192021let a = (v = 0) =&gt; &#123; return Promise.resolve(v + 1)&#125;let b = (v = 0) =&gt; &#123; return Promise.resolve(v + 3)&#125;let c = (v = 0) =&gt; &#123; return Promise.resolve(v + 5)&#125;let arr = [a, b, c]function handlePromiseList(arr) &#123; return arr.reduce((promise, fn, index) =&gt; &#123; console.info(`当前是 $&#123;index&#125;`) return promise.then((res) =&gt; &#123; return fn(res) &#125;) // 需要传入初始值供链式调用 &#125;, Promise.resolve())&#125;handlePromiseList(arr) TODO: 循环的思路 for in 和 for of 区别 两者在循环数组时，前者循环出的是 key, 后者循环出的是 value 后者是用来迭代可迭代对象(Array, Map, Set, String, TypedArray, arguments)，但不包括对象 Object for in 可以迭代出原型上的属性 for in 和 Object.keys 的区别 Object.keys 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for in 循环遍历该对象时返回的顺序一致。 它们的区别在于 Object.keys 只循环对象的可枚举属性。 for in 则循环对象的可枚举属性和对象的原型链上的可枚举属性。 浅比较和浅拷贝的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 这里的 shallowEqual 就是浅比较，这个方法经过小部分的扩展，也可以实现 Object.assign 方法，后续补充上// 内部实现其实主要依赖于 es6 的一个方法 Object.is// 它类似于 === 的功能，但补充了 === 在比较时的不足，// 例如 +0 === -0 和 NaN === NaN 这两种特殊情况// 这里做一个模拟 Object.is 的实现/** * [is 其实就是 Object.is] * @param &#123;Any&#125; a [description] * @param &#123;Any&#125; b [description] * @return &#123;Boolean&#125; [description] */function is(a, b) &#123; if (a === b) &#123; // 处理 +0 === -0 返回为 true return a !== 0 || b !== 0 || 1 / a === 1 / b &#125; else &#123; // 处理 NaN === NaN 为 false 的情况 return a !== a &amp;&amp; b !== b &#125;&#125;/** * [shallowEqual 浅比较] * @param &#123;Any&#125; obj1 [description] * @param &#123;Any&#125; obj2 [description] * @return &#123;Boolean&#125; [description] */function shallowEqual(obj1, obj2) &#123; // 对基本数据类型的比较 if (is(obj1, obj2)) return true // 这里是对上述遗漏的基本类型的对比的补充，但暂时没想到在哪些情况下会进入到此逻辑中 if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null ) &#123; return false &#125; const keys1 = Object.keys(obj1) const keys2 = Object.keys(obj2) // 如果长度不等，直接返回不等 if (keys1.length !== keys2.length) return false // 相等时，再做遍历的比较 for (let i = 0; i &lt; keys1.length; i++) &#123; let key = keys1[i] // 使用 hasOwnProperty 来判断在 obj2 中是否有 obj1 的方法 if (!Object.hasOwnProperty.call(obj2, key) || !is(obj1[key], obj2[key])) &#123; return false &#125; &#125; // 到此结束，也就是说，无法在对象的属性里再比较对象类型的数据 // 如果要深比较，则涉及到递归遍历，下次再拓展 return true&#125; TODO 深拷贝的实现实现 Array.prototype.map 方法 链接中的方法更完善，此为简易版。 12345678910Array.prototype.map = function (callback) &#123; if (!Array.isArray(this)) &#123; throw new TypeError('Param must be Array') &#125; if (typeof callback !== 'function') &#123; throw new TypeError('callback is not a function')&#125; let res = [] let len = this.length for (let i = 0; i &lt;= len - 1; i++) &#123; res[i] = callback(this[i], i, this) &#125; return res&#125; 12345678910const a = [1, 2, 3, 4, 5]a.multiply() // [1, 4, 9, 16, 25]function multiply() &#123; if (!Array.isArray(this)) &#123; throw new Error() &#125; return this.map((item) =&gt; &#123; return item * item &#125;)&#125;Object.assign(a.__proto__, &#123; multiply &#125;) jsonp实现原理及具体实现 蚂蚁面试时被问到了 jsonp 的实现原理，虽然答出了原理，但具体的实现逻辑有所遗忘，这里做一个简易版但是是完整的实现。 利用 script 标签可以跨域请求资源的原理。 1234567891011121314151617181920/* * 回调函数，服务端响应数据后执行 */function handleCallback(res) &#123; console.info(res.data)&#125;function handleJsonp() &#123; let script = document.createElement('script') script.src = `http://justexample.com?callback=handleCallback` script.type = 'text/javascript' document.body.appendChild(script)&#125;handleJsonp()// 服务端的返回应当是这样，这里是 nodejs 的写法// `$&#123;callback&#125;($&#123;callbackData&#125;)`// handleCallback(&#123; data: 'bad view' &#125;)// 然后客户端执行 handleCallback 函数，打印出结果 import 和 require 的区别 规范: import: ES6 的语法规范——模块化方案。仅在现代浏览器上支持，在其他浏览器上需转成 ES5 运行，也就是说其实仍然是转成 require 的方式运行。 require: nodejs 提供的社区方案，遵循 CommonJS/AMD 规范。 调用时间： import: 编译时执行。因此必须放在文件开头。 require: \b运行时加载。当首次调用时，会执行请求的文件的脚本代码，执行后生成一个对象在内存中。之后再引用时，并不会重新执行代码，而是从缓存中读取对象。 循环取值的情况。 官方文档 阮一峰解读 本质： import: 值引用，所取的值仅仅是可读的。见下文。数据无法重新赋值，基础数据类型无法更改，对象类型无法赋值，但可以定义属性。在React中查看 require: 值拷贝，浅拷贝。基础类型相当于直接赋值。对象类型，相当于获取了值，并浅拷贝给当前的值。123456789// a.jsmodule.exports = 0// b.jsexport const b = 0// main.jslet a = require('a.js')import b from 'b.js'++a // 1++b // 报错，因为这个值是 read-only 的 写法： 1234567891011121314151617// import 的方式较多import React from 'react'import * as React from 'react'import &#123; default as React &#125; from 'react'import React, &#123; Component &#125; from 'react'import &#123; Component &#125; from 'react'import &#123; PureComponent as PC &#125; from 'react'// exportexport default fsexport const fsexport * from 'fs'export &#123; readFile, writeFile &#125;export function readFile// require 方式很少const fs = require('fs')module.exports = () =&gt; &#123; console.info('A') &#125;exports.fs = &#123;&#125; window.open 的使用 - by 丁香园 window.open 该方法接受三个参数： strUrl: url 地址。\b设置的值没有 http 时，打开的新窗口是当前 url 的相对地址。 strWindowName: 窗口名称，不是窗口标题，\b并不会显示。如果已存在同名的 strWindowName 的窗口，就不再打开新窗口，而是在那个窗口中加载。除非将它设置为 ‘_blank’. strWindowFeature: 窗口的属性，字符串形式，以逗号分隔。 window.open(&#39;http://www.google.com&#39;, &#39;newWindow&#39;, &#39;resizable,scrollbars&#39;) this 指向 window - by 丁香园123456789101112131415161718192021222324const obj = &#123; name: 'james', show: function(name) &#123; console.info(name) &#125;&#125;obj.show(this.name) // 空，因为当前的 this 指向 window// TODO 不知道这题的意义const result = (function ()&#123; return '1';&#125;, function() &#123; console.info(2) return 2;&#125;)()typeof result // \"number\" result 是 2document.body.addEventListener('click', function(e) &#123; console.info(e.target, this) // this 指向 body, 绑定对象时指定了 this&#125;, false)document.body.addEventListener('click', (e) =&gt; &#123; console.info(e.target, this) // this 指向 window&#125;, false) ReactcomponentWillMount TODO: 为什么不推荐该生命周期，以及为什么不推荐在这里使用 ajax. componentWillMount 内的报错会阻塞后续生命周期的执行，即 DOM 的挂载等等。 如果异步请求后续有涉及 DOM 的操作，可能会因为 DOM 还未生成而找不到 DOM 而报错。 存疑：v16+ 的版本里，在 fiber 的机制下，开启 async rendering, render 之前的生命周期函数可能会执行多次，导致发送多次 ajax。 服务端渲染 SSR，componentWillMount 也会触发？ CSSBFC 块级格式化上下文: 布局过程中生成的块级盒子区域。规定了内部块级元素的布局规则，默认情况下只有 body 一个 BFC 块级上下文. 规则： 盒子块会在垂直方向上放置。 相邻的盒子块在垂直方向上的 margin 会合并。 \b\b每个元素的 margin box 左边，与包含 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。（这部分不太理解）Demo BFC 区域不会与 float box 重叠。Demo BFC 是页面上隔离的独立的容器，容器内部的子元素不会受外部影响，也不会影响外部元素。 计算 BFC 的高度时，浮动元素也参与计算。 触发条件： 根元素或包含根元素的元素。 行内块元素：display 为 inline-block. 浮动元素：float 有值(不为 none). overflow 不为 visible 的块元素. 绝对定位元素：position 为 fixed 或 absolute. 弹性元素：display 为 flex 或 inline-flex 元素的直接子元素。 网格元素：display 为 grid 或 inline-grid 元素的直接子元素。 等等。 实际应用：很多 CSS 的布局方案都是通过创建 BFC 来解决的。 不使用 BFC 实现文字环绕效果。使用 BFC 实现排列效果。在线 Demo 例如解决 margin 合并的问题，方案就是创建两个 BFC。使元素处在不同的 BFC 中。在线 Demo 例如清除浮动，父元素添加了 overflow: hidden 属性后，生成了一个 BFC，而 BFC 的高度计算是包括浮动元素在内的，因此计算后的父元素高度包括了浮动元素，当前的原本脱离了文档流的浮动元素又被包括在父级 BFC 内。在线 Demo display: inline-block;float: left;position: absolute; 等等能创建 BFC 的方式都可以清除浮动，但还是要看具体的应用场景。 border-box 和 content-box 区别 box-sizing123456789101112131415161718.parent &#123; box-sizing: border-box; width: 200px; height: 200px; margin: 20px; padding: 10px; border: 10px solid pink; background: red;&#125;.child &#123; width: 100%; height: 100%; background: yellow;&#125;/* 说明各区域颜色及 child 宽高. *//* * border-box 是 width 包括 border, padding，但不包括 margin */ 用 css 实现子元素宽度为父元素宽度一半的正方形 - by 头条 在线 Demo 12345678910111213// 父元素大小未知，这里假定.parent &#123; width: 720px; height: 420px; background: red;&#125;// 使用 padding 将其撑开.son &#123; width: 50%; padding-top: 25%; padding-bottom: 25%; background: lightgreen;&#125; 行内元素 行内元素例如 &lt;span&gt; 是可以设置宽高的，但是设置无效，除非将 display 的值修改为 inline-block 或 block。 在线 demo 浏览器同源策略 浏览器的同源策略规定，协议相同，域名相同，端口相同(该条 IE 除外)。 影响： Cookie, LocalStorage, IndexDB 无法读取。 无法使用 AJAX. 无法获取 DOM. 但是有几个标签的请求是绕过同源策略的。 &lt;img src=&#39;&#39; /&gt; &lt;link href=&#39;&#39; /&gt; &lt;script src=&#39;&#39; /&gt; 跨域方案 JSONP CORS：比较常规的解决方案。 access-control-allow-origin 这个参数添加域名或设置为 *. 简单请求浏览器直接发送。 非简单请求，浏览器自动先发送预检请求 options, 然后再发送非简单请求。 window.postMessage：个人理解比较适用于 iframe 间的通信。 window.postMessage(message, targetOrigin, [transfer]) 接收三个参数。 message: 消息内容，会被自动序列化，无需手动序列化。 targetOrigin: 要发送的域名。 transfer: TODO 手动接收事件 window.addEventListener(&#39;message&#39;, receiveMessage, false) message: 包括 data, origin, source data: 传过来的数据对象。 origin: 发送方的源地址。 source: 发送方窗口的引用。 receiveMessage: 回调函数。 node 中间件代理 思路是 node 服务端获取到客户端请求，再从 node 服务器发出，请求后数据再返回给客户端。 这样从服务端发起请求，没有同源策略影响。 TODO: nginx 反向代理 类似 node 中间件代理，搭建一层服务器作为中转。 ssh 登录上服务器，修改 nginx 的配置文件。然后重启 nginx. nginx -s reload 在 nginx.conf 文件里修改12345678server &#123; listen 80; server_name www.domain1.com; location / &#123; proxy_pass www.domain2.com:8080; #反向代理 index index.html; &#125;&#125; TODO: websocket 前端安全 TODO：https://github.com/riotkkwok/blog/issues/8,https://zhuanlan.zhihu.com/p/31553667https://tech.meituan.com/fe_security.html XSS: CSRF 其他 在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。假设： A：每次只有一只老虎可以吃羊，而且一旦他吃了羊，他自己就变成羊。 B：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 问最后这只羊会不会被吃？- 头条的骚题。 从一只老虎开始分析，当一只老虎一只羊时，老虎必定吃羊。 当两只老虎时，老虎不敢吃羊，因为一旦吃了羊，变成了羊，就会被剩下的老虎吃了。 三只老虎时，头一只老虎可以吃了羊，然后问题回到两只老虎的状态，都不敢吃羊。 四只老虎时，老虎如果吃羊，就会回到三只老虎的状态，因此任一老虎都不会吃。 综上所述，老虎数量为奇数时，老虎会吃，为偶数时，不会吃。 单双向数据流的理解 TODO 单向数据流： 简单的理解，可认为水（数据）往低处流。高处是用户，低处是视图。用户的交互行为使得动作发生变更，派发后触发回调函数，进而引起视图的监听事件的调用，最终导致视图的更新。换句话说，视图的变更不会引起数据的变化，否则这就是双向数据绑定了。当然，目前谈论到的数据变化，是以 UI 控件为前提。 user interaction =&gt; dispatch(action) =&gt; callback =&gt; store(update) =&gt; change events =&gt; view(react component) 双向数据流：","link":"/jo.github.io/2018/06/11/the-questions-in-interview-part2/"},{"title":"跳槽面试小结——那些在我下次面试前我想知道的事","text":"不久前，我做了一个较为艰难但对我以后的发展绝对有利的决定——从前公司离职。这是我呆的第一家互联网公司，也是我作为前端的第一份工作。一年多的工作经历并没有特别多的感慨，但我想记录下相关的事，来避免以后所走的弯路。 那些在我下次面试前我想知道的事不久前，我做了一个较为艰难但对我以后的发展绝对有利的决定——从前公司离职。这是我呆的第一家互联网公司，也是我作为前端的第一份工作。一年多的工作经历并没有特别多的感慨，但我想记录下相关的事，来避免以后所走的弯路。 有关离开和前公司的许多要好的同事一样，在这家公司开始“发力”，“改变”的时候，我有了一些关于离开的念头。 最初是和薪资有关。当无意中得知同行业其他人的薪资水平时，我确实吃了一惊。因为当你在一家公司，独自撑过曾经有四五个人维护过的项目超过个把月时，你应该得到一些报酬。但这种事，我天真以为应由公司方面主动，可我忍了很久也无动于衷，在自己提出后，最终得到了一定的涨幅。尽管过程较长，至少得到了较好的结局。 但如果仅仅因为薪资而离开，对一个刚开始工作的人而言这样的想法是幼稚的，所幸我最终没有那么做。我选择继续等待，等着接下来会发生什么。平淡的几月过去，然而接下来的事仍然无法打消一些不时间涌上来的念头。我想，很多人都会或多或少有过离开的念头，不论在哪家公司，只要年轻，就会有冲动，但即使年轻，也要学会衡量利弊，学会压下冲动。所以，我理清楚了一些事，当你离开时，你至少得注意几件事： 离开的决定是在理智的时候决定的，职场上，不要在任何冲动的情况下做决定。 如果决定离开，试着想想曾经来到这里的原因，再想想离开的原因。 列一张留下和离开相关利弊的表格，衡量各种利弊关系。 给自己一个沉淀期，等这段时间过去，再来看看接下来会发生什么，再做决定。 是否真的做好了下个地方的准备，去接受新的环境，建立新的人际关系。如果没有，除非现在的地方糟透了，否则一定要谨慎。 是的，针对第一条，是因为我自认在上一家公司，接受过许多不平等的、使人不愉快的事，那些事总会让我的脑海里浮现离开的场景。但最终我忍了下来，加上第四条的缘故，而且这样的选择是对的。在职场上，这其实是很简单的道理，只不过大部分人并没有幸运到会有个人来告诉你这些事。所以，自己把握吧。 我也在很多时候回顾了来这里的原因。来这里纯粹是机缘巧合，但从后来来看，在这里开始是个很好的选择，作为前端，我接触了很多新奇有趣的东西。虽然那只占据了这份工作的不多的部分，但我仍然为此心存感激。也一直感谢着招我入职的前辈。关于离开，除了那些会使我冲动和不愉悦的事外，我也试着去罗列那些相关的利弊，那会使我冷静下来。 我并不知道是否有关于沉淀期真正的名词说法，这是我自己随意取的。我只是在工作的初始阶段意识到，对于大多数人的第一份工作，他们应当有一个时间段，去熟悉这份工作，尤其这像我这样非科班出身的程序员，需要有一定时间去缓冲，去沉淀。不论在这时间段里发生什么，只要没有发生过分的事，就继续下去，这是一个信念，让你保持你的专注，吸收有关技术的知识，远离那些冲动和纷扰。当我回顾的时候，我发现我并没有非常坚定地执行这个信念，特别是在接近一年期满的时候，仍然会被其他事情所打扰，也许是因为年轻的缘故，但我最终坚持下来了。我庆幸这点。有的人把这个沉淀期定为一年，或者二年，或者更久。我把它定为一年。 一年期满后，当我再去看那些有关利弊的分析，已经是恍然大悟的状态——完全没有任何留下的理由——而我虽然没有做好充分的准备，但至少认可了自己。这使我最终选择离开。 跳槽对很多来说，骑驴找马是再正常不过的事。不过对我来说，很遗憾，我只能专注于一件事。我无法在一边工作的情况下，一边寻找机会，这直接导致了我的裸辞。 尽管很多朋友劝我不要选择裸辞，也不要选择年前离职，但我还是这么做了。从现在来看，也许是有遗憾，不过我不会因此而后悔或想选择再来一次。对我来说，裸辞并没有问题。问题是裸辞后应当有一段缓冲期，这缓冲期用来放松、出去走走，用来回顾总结。然而我几乎失去了这段时间，原因有部分也来自于离职的原因——没有年终奖导致了没有较多的积蓄，而平时也几乎月光。所以，这点没有办法。直到现在，我仍无法相信在一家公司超过一年的员工，会在一年结束时没有任何实际的奖励。现在我可以肯定地说，如果以后任一家公司发生相似的事，除非它的产品极具吸引力，或是平时月薪达到了超出同行业很多水准的高度，否则我会立即考虑离职这件事。 除了没有缓冲期外， 我觉得自己在离职时机上也没有问题。年底前一周，如果非要挑刺的话，希望再晚两周左右。因为从现在回顾去，确实接近过年时涌现了大批机会。不过在我离开的那时，机会已经足够多，错失的是自己没有把握住，而且那时候自己的心态，已经不适合继续——当毕业不久的你遇到相同的事，相信很多人会做比我更早离开的选择——我没法再当那更少数人了。 面试与准备如果要说这次跳槽，最大的败笔是什么，无疑是我的简历，我最初的简历十分糟糕——因为几乎没有准备——更别提精心准备。这使我在面试早期错过了很多好的机会，这点我最需要反思。一个重大原因似乎是没有对比，我几乎没有见过好的技术简历，所以不知道自己写的到底有多差。另一个原因，是我自己本身的优势，没有很好的在简历中体现。截止下笔时间，有无数好的机会就错过在了简历上。也许根本上还是自己的懒散导致，所以希望在下一次——最好至少在一年后——一定要准备好简历，这会让一切都开始地容易的多。 另一个不足的地方，在于基础知识的巩固。我在这一年里确实接触了很多，有各式各样的框架，还有各种打包工具。但最原始的html,css,js却忘了在面试前回顾。因为那些框架和工具，只能显示出你表面的功夫，底子里，面试问几个问题就一目了然，而许多我没能答上来的问题，却早就在自己的笔记里了。所以，前端最原始的那些基础知识，是在面试时最需要回顾的。 然后是面试时需要做的事——表现自己的自信和能力。自信体现在态度上，能力体现在技术上。有许多次，我并没有休息好就参加面试，加上自己心理素质相对不足，完全没有体现自己的优势，反而劣势被无限放大。在我面试的十五次左右里，最想去的那几家这点体现地很明显。最终导致了自己面试结束开始怀疑人生。有关这点，还有一些体会——非科班出身的人去面试，就好像背后插了把刀子。一旦面试官问起为什么选择前端，就好像拔出了那把刀子，再痛一次。另外，对那些出言不逊或者面试时令人不舒服的面试官，除非公司好的让人流口水，不然还是给否定答复或尽早放弃吧，我实在无法想象在面试短短几十分钟就令人不悦的人，以后还要以月以年来计算地继续相处。面试是交流和考察，不是欠你钱或者死了妈。 那些较好的机会，也可以试试。虽然也许自己还没到那薪资水平，但有些公司存在缺人的情况，这点大概是可遇不可求了，但也许面多了，也会有一定的直觉来判断。 总结这段不长的三周面试经历，一共十多次显得有些密集——最好仍是维持一两天一次，一周两三次这样的密度。现在看来，那些小公司的面试经历有些是不必要的，有些面试官做作的姿态反而令人不悦，费心费神。希望之后的面试，可以更专注的想去某个地方，提前订好目标。就现在来看，我想去的那些地方，大概是这样： mbp标配，双屏显示，最好带机械键盘，工程师座椅。 4-7前端的小团队，交流快捷迅速，喜欢追求，喜欢前端，有些geek，还有个各方面受认可的leader。 做较好的产品，那种你不会在需求讨论阶段就在心里wtf的产品。 较为规范的开发流程。代码规范是必须的。 定期的分享会，且在会上有更多新奇的东西，在code review时少些wtf. 对自己的能力认可的话，薪资按涨幅50%起加吧。 对了，我还做了一份自己看重公司的要点的表格，将拿到的offer和面试所知信息进行全部对比，优劣一目了然。它不会花你很多时间，但却会有很好的效果。 以后的机会对绝大多数人来说，漫长的职业生涯的跳槽经历都远不止一次。我也属于这其中一员，所以我希望在这里留下一些再次遇到相似情况时——最好不要再发生类似的事但万一发生的话——该注意的地方(顺序进行): 如果仍然习惯专注一件事，可以再选择裸辞。但有点要注意，部分城市转移户口需要连续交满一定时间的社保，裸辞的话，需要段时间寻找，很可能没办法延续，这个坑以后要记住。 时间接近年前，最好在年后。最差是11月底，12月初或月底(如果过年晚的话)。 有一些积蓄，去较远的地方走一趟——最好是国外。 回顾前端三驾马车，基础必须扎实。 非常认真的准备简历。 面试时自信，相信自己的能力(只要面试官不刻意刁难，这点我有时接近了)。 减少面试次数，先确定想去的地方，再去面试5-10家，最好五个以内。 好的机会，尽量去试试，不用在意招聘要求。 末尾写在2017年初，去下一个公司报到前一天晚。","link":"/jo.github.io/2017/01/17/the-summary-of-interview/"},{"title":"初识 Three.js(上) —— 基础概念一览","text":"近期在项目中有规划 3D 组件的需求。在发现 echarts-gl 不能满足需求后，我在d3等一众第三方库中无所适从。最终我决定挑战一下 Three.js. 当然在一开始，我遇到了很多麻烦，所幸到了临近最后时，我解决了绝大多数的问题。我在未学习 webgl 的情况下直接使用 threejs, 其实并不是个较好的方案，却是能较快出结果的方案。这篇文章记录了我使用 Three.js 的痛苦和收获。 索引 简单介绍 基础概念 Scene(场景) Renderer(渲染器) Camera(相机) Geometry(几何模型) Material(材料) Light(光源) Animation(动画) Demo Three.js 是什么 我在初次见到 Three.js 的时候并不理解它是一种怎样的存在。只知道使用它可以做出各式各样炫酷，无所不能的 3D 效果。当时我的同事提醒了我，他说这是一个类似 jquery 的库，封装了 webgl 的各式各样的 api. 因此更加友好，也更加方便。它让你可以绕过 webgl 基础这部分，直接创建 3D 效果。但你仍然要知道，这是一个捷径，是临时的方式。如果要切实使用好 Three, 还是必须得学好 webgl. 即使里面所有的基础 api 可能不会在 Three 中体现出来，但 webgl 的实现思路，里面的知识点仍然是值得借鉴和学习的。 Three.js 基础概念 一定有人迫不及待地跃跃欲试了。但是且慢，在我尝试写代码之前，Three 的中文文档的寻找就耗去我不少时间。就目前而言，似乎还未找到官方的中文文档，教程之类的地方。只有部分翻译的文档。我最终只好硬着头皮阅读英文文档。所以若是理解有出入，请大胆指出。 Scene 就像 canvas.getContext(&#39;2d&#39;)获取上下文 一样，创建 3D 组件也需要一个上下文环境。 通常情况下，这个场景不需要做什么配置。 const scene = new THREE.scene() 源码 Renderer WebGLRenderer 渲染器使用 WebGL 来绘制场景。这个渲染器比 CanvasRenderer有着更好的性能。 const renderer = new THREE.WebGLRenderer() 使用 webgl 来渲染。 WebGLRenderer Camera Three 为我们提供了多个相机，包括正交相机，透视相机，还有立方体相机等等。 正交相机，则是类似一个长方体，我们透过这个长方体去看事物。此时，看到的事物是平面的，也就是没有立体感。和我们看 2d 的 canvas 类似。 const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000) 每个参数分别代表相机视锥体左面，右面，上面，下面，前面，后面。 透视相机，遵循近大远小的原则。和人肉眼所见相似。我们用以下方法来创建一个视角为 75°，占满屏幕大小，并且从离相机 1 个单位处开始渲染，到 500 的地方停止。 const camera = new THREE.PerpestiveCamera(75, window.innerHeight/window.innerWidth, 1, 500) 四个参数的含义分别为相机视锥体垂直视角，相机视锥体宽高比，相机视锥体近裁剪面，相机视锥体远裁剪面。 源码 Geometry 模型是构成物体的基本元素。它决定物体的形式。每个几何模型都基于基础类Geometry. 常见的几何模型有球模型(SphereGeometry)、盒子模型(BoxGeometry)、平面模型(PlaneGeometry)、环状模型(RingGeometry)、文本模型(TextGeometry)等等。 我们可以使用const sphereGeometry = new THREE.SphereGeometry(1, 1, 8) 来创建一个球体模型或使用const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)立方体模型。 Geometry Material 材料用来描述物体的外观和构成部分。用于决定一个物体以何种形式来渲染。例如球体的颜色，表面光滑度。 Material是材料的基础类。其他材料都基于此类。 常用的材料有基础网孔材料(MeshBasicMaterial)、兰伯特网孔材料(MeshLambertMaterial)、Phong网孔材料(MeshPhongMaterial)等等。 使用const sphereMaterial = new THREE.MeshBasicMaterial({color: &#39;0x000000&#39;}) 来渲染黑色的表面。 当形状和材料两项都创建好的时候，就可以来创建一个完整的物体。 const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial) 源码 Light 光源通过光照的强度和范围去影响场景中的部分对象，主要是对不同材质的对象产生影响。 Light是光源的基础类。其他光源都基于此类。 常见的光源有环境光源(AmbientLight)、平行光源(DirectionLight)、点光源(PointLight)等。 环境光源对所有对象产生影响。 平行光仅对MeshLambertMaterial和MeshPhongMaterial材质的对象产生影响。 点光源同上，仅对MeshLambertMaterial和MeshPhongMaterial两种材质产生影响。 以点光源为例，我们创建一个简单的点光源。 123let light = new THREE.PointLight(0xffffff, 1, 100) // 光照颜色，光照强度，光照范围light.position.set(50, 50, 50)scene.add(light) 源码 Animation 最后，让这一切动起来，需要动画来运行。 12345function animation() &#123; window.requestAnimationFrame(animation) renderer.render(scene, camera) // do something&#125; Demo 在了解所有基本的要素之后，让我们来实现一个简单的动画吧——一个旋转的立方体。 12345678910111213141516171819202122232425262728293031import * as THREE from 'three.js'const body = document.bodyconst scene = new THREE.Scene()// 新建渲染器并设置大小const renderer = new THREE.WebGLRenderer()renderer.setSize(window.innerWidth, window.innerHeight)body.appendChild(renderer.domElement)// 设置相机和位置，并将视线转向场景中央const camera = new THREE.PerspectiveCamera(75, window.innerHeight / window.innerWidth, 1, 1000)camera.position.set(0, 0, 10)camera.lookAt(scene.position)// 新建一个立方体const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)const cubeMaterial = new THREE.MeshBasicMaterial(&#123; color: 0x123abc &#125;)const cube = new THREE.Mesh(cubeGeometry, cubeMaterial)scene.add(cube)// 旋转立方体function animation() &#123; window.requestAnimationFrame(animation) renderer.render(scene, camera) cube.rotation.z += 0.01 cube.rotation.y += 0.01&#125;animation() 中文文档","link":"/jo.github.io/2017/11/23/the-usage-of-threejs/"},{"title":"ES6改写cookies.js及分析","text":"cookies.js是前阵子在github上很火的一个超轻量级的库，发布当天就获得了2k+的star数。最初只有80行，到现在也不过一百多行。而里面的写法很值得借鉴学习，在这里我尝试用ES6改写，边改边学习。目前还留下了小部分不理解的地方，这些坑留待之后理解了再回来填。 ES6改写cookies.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/** * [cookies cookies.js] * @param &#123;Object&#125; data [description] * @param &#123;Object&#125; opt [description] * @return &#123;Object&#125; [description] */// 用ES6改写cookies// cookies 不会变化,所以用const定义const cookies = function(data, opt) &#123; /** * [defaults 源码中的合并对象属性函数 这里采用ES6的Object.assign替代,是否会引起错误？] * @param &#123;Object&#125; obj [原始对象，如果没有则默认新建一个] * @param &#123;Object&#125; defs [用来合并的对象] * @return &#123;Object&#125; [description] */ // function defaults(obj=&#123;&#125;, defs) &#123; // for (let key in defs) &#123; // if (obj[key] === void 0) &#123; // obj[key] = defs[key]; // &#125; // &#125; // return obj; // &#125; // 初始化 // defaults(cookies, &#123; Object.assign(cookies, &#123; expires: 365 * 24 * 3600, // 设置默认的过期时间，一年 path: '/', // 路径 secure: window.location.protocol === 'https:', // Advanced Options 不推荐更改的一些默认选项 nulltoremove: true, // 设置cookie的值为null时即移除它, autojson: true, // encode or decode 转码成json autoencode: true, // 安全编译 encode: (str) =&gt; &#123; return encodeURIComponent(str); &#125;, decode: (str) =&gt; &#123; return decodeURIComponent(str); &#125;, error: (error, data, opt) =&gt; &#123; throw new Error(error); &#125;, fallback: false // 如果cookies失效时启用的回调 // 更改时需要在全局环境下 // cookies.nulltoremove = true; // cookies.autojson = true; // cookies.autoencode = true; // cookies.encode = (str) =&gt; &#123; // return encodeURIComponent(str); // &#125;; // cookies.decode = (str) =&gt; &#123; // return decodeURIComponent(str); // &#125;; // cookies.error = (error, data, opt) =&gt;&#123; // throw new Error(error); // &#125;; // cookies.fallback = false; &#125;); // 将 cookies 复制到 opt 上, 用于后面的保存 // opt = defaults(opt, cookies); opt = Object.assign(opt, cookies); /** * [expires 将时间格式转化为UTC格式] * @param &#123;Date || Number&#125; time [可能是以秒为单位的时间，或是Date对象] * @return &#123;Date&#125; [description] */ function expires(time) &#123; let expires = time; // 假如传入的时间不是Date对象 if (!(expires instanceof Date)) &#123; expires = new Date(); expires.setTime(expires.getTime() + (time * 1000)); &#125; return expires.toUTCString(); &#125; // 查询cookie,注意这里采用了链式写法,函数式编程风格 if (typeof data === 'string') &#123; // 依据分号间隔将字符串cookie转成数组 let value = document.cookie.split(/;\\s*/) // 如果autoencode为true,则将数组中的每个cookie通过decode进行处理 .map(opt.autoencode ? opt.decode : (d) =&gt; &#123;return d&#125;) // 数组的map方法返回的是数组，所以可以进行链式调用 .map((part) =&gt; &#123; // 再将每个cookie 分割成 [key, value] 的结构,得到一个二维数组 return part.split('='); &#125;) .reduce((parts, part) =&gt; &#123; // 将数组中的 [[key1, value1], [key2, value2]] // 转化为 &#123;key1: value1, key2: value2&#125;的格式 // parts[part[0]] = part[1]; // 作者后来改为下面 parts[part[0]] = part.splice(1).join('='); return parts; &#125;, &#123;&#125;)[data]; // 获取指定的cookie值，将该值赋给value // 是否支持转化成json的object if (!opt.autojson) &#123; return value; &#125;; let real; // json格式化 try &#123; real = JSON.parse(value); &#125; catch (e) &#123; real = value; &#125; // 假如当前值是undefined,切存在回调函数，则返回调用毁掉函数后的返回值 if (((typeof real) === 'undefined') &amp;&amp; opt.fallback) &#123; real = opt.fallback(data, opt); &#125; return real; &#125; // 新增cookie for (let key in data) &#123; let val = data[key]; // expired 涉及两个判断 // 一个data[key]的值是否为undefined // 第二个是 nulltoremove的值为true, 且设置的值为null // 当满足这二者之一的条件时，expired 的值为true // 这个写法简洁明了 let expired = typeof val === 'undefined' || (opt.nulltoremove &amp;&amp; val === null); let str = opt.autojson ? JSON.stringify(val) : val; let encoded = opt.autoencode ? opt.autoencode(str) : str; // TODO: 这里为什么不放在encoded判断之前 if (expired) &#123; encoded = ''&#125;; // 这段略复杂、、保存各种数据，以分号相隔 // 如果存在则保存，不存在则以空字符串标识 // TODO: 如果过期的话默认值为-10000？ let res = `$&#123;opt.encode(key)&#125;=$&#123;encoded&#125; ($&#123;opt.expires&#125; ? (;expires=$&#123;expires(expired ? (-10000) : opt.expires)&#125;) : '') ;path=$&#123;opt.path&#125; ($&#123;opt.domain&#125; ? (;domain=$&#123;opt.domain&#125;) : '' ($&#123;opt.secure&#125; ? ;secure : '')`; // 如果opt中有测试方法 if (opt.test) &#123; opt.test(res); &#125; // 保存cookie document.cookie = res; // TODO: 待理解。获取属性值，对其编码，并获取? let read = (cookies(opt.encode(key))) || ''; // TODO: 待理解。当当前值存在，且未过期，且过期时间大于0，且 ? if (val &amp;&amp; !expired &amp;&amp; opt.expires &gt; 0 &amp;&amp; (JSON.stringify(read) !== JSON.stringify(val))) &#123; // 查看浏览器是否开启了cookies,布尔值 if (navigator.cookieEnabled) &#123; // 如果存在回调函数 if (opt.fallback) &#123; opt.fallback(data, opt); &#125; else &#123; opt.error(`Cookie too large at $&#123;val.length&#125; characters`); &#125; &#125; else &#123; opt.error(`Cookies not enabled`); &#125; &#125; &#125; // 这个cookies // cookies(&#123; token : 14&#125;)(&#123; token: '14' &#125;) // const token = cookies(&#123; token: '14' &#125;)('token') // token === '14' return cookies;&#125;// TODO: 需更熟悉// 如果在webpack中配置output的libraryTarget设置为umd,就会在打包时自动添加这段// 然后就可以通过多个方式引入(AMD, commonjs, global)// [具体配置](https://webpack.github.io/docs/configuration.html#output-librarytarget)// 或者可以直接加载模块末尾(webpackUniversalModuleDefinition(root) =&gt; &#123; // CMD写法: common.js 的 module.exports 暴露 if (typeof exports === 'object' &amp;&amp; typeof module === 'object') &#123; module.exports = cookies; &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD规范的define写法 define('cookies', [] , cookies); &#125; else if (typeof exports === 'object') &#123; // ES6写法 export出cookies exports['cookies'] = cookies; &#125; else &#123; // 全局配置 this['cookies'](global.cookies) root['cookies'] = cookies; &#125;&#125;)(this); 参考: 1. 源码分析之：cookies.js 2. cookies.js","link":"/jo.github.io/2016/12/19/transform-cookies-into-es6/"},{"title":"理解JavaScript中的类","text":"整理了部分类的知识点。类的定义，如何实现一个类，类有哪些特点，等等。基于ES3, ES5. 理解JavaScript中的类 类的作用：让每个对象都共享某些属性。 类的实现：基于JavaScript的原型继承机制。 类的特性：动态可继承(编程哲学——鸭式辩型)。 类的核心：原型对象。所有类的实例都会从同一个原型对象中继承。属性 类的定义：通常使用构造函数: 调用构造函数会自动创建一个新对象，构造函数只需初始化这个新对象的状态，而新对象的原型正是构造函数的prototype 意味着同一个构造函数创建的所有对象都继承自一个相同的对象,因此他们都是同一个类的成员 构造函数可看做是类的’外在表现’ 为方便标识，字符串相关部分使用了ES6的模板字符串。 编程约定：构造函数(类名)首字母大写:构造函数就是用来构造新对象的，必须通过关键字new调用，开发者可以通过命名约定来判断是否是构造函数。 12345678910111213141516/** * [Girl 定义一个拥有几个属性的妹子类] * @param &#123;[String]&#125; pretty [可爱属性，以字符串标识] * @param &#123;[Number]&#125; sexualLow [性感属性，以数字标识] * @param &#123;[Number]&#125; sexualHigh [性感属性，以数字标识] */function Girl(pretty, sexualLow, sexualHigh) &#123; // 类型检查 if (isNaN(sexualHigh) || isNaN(sexualLow)) &#123; throw new TypeError(); &#125; this.pretty = pretty; this.sexualLow = sexualLow; this.sexualHigh = sexualHigh;&#125; 在原型对象上定义类方法。 该prototype是每个JavaScript函数都自动拥有的,它本身的值就是一个对象，这个对象包含一个唯一一个不可枚举的属性constructor。 constructor的值是一个函数对象。 12345678910111213141516171819202122232425262728293031/** * [foreach 传入方法处理每个属性] * @param &#123;[type]&#125; f [description] * @return &#123;[type]&#125; [description] */Girl.prototype.foreach = function(f) &#123; f.call(this, this.pretty, this.sexualLow, this.sexualHigh);&#125;;/** * [include 是否在Girl的性感区间内(判断妹子是否性感)] * @param &#123;[type]&#125; sexual [description] * @return &#123;[type]&#125; [description] */Girl.prototype.include = function(sexual) &#123; return sexual &gt; this.sexualLow &amp;&amp; sexual &lt; this.sexualHigh;&#125;/** * [toString 查看这个妹子类的平均水平] * @return &#123;[type]&#125; [description] */Girl.prototype.toString = function() &#123; console.info(`This girl: $&#123;(this.sexualLow + this.sexualHigh) / 2&#125;$&#123;this.pretty&#125;`);&#125;;// 声明一个妹子类的实例var lisa = new Girl('B', 32, 36);lisa.include(34); // 查看该妹子是否在区间内lisa.foreach(console.warn); // 打印出该妹子实例的各个属性lisa.toString(); // 查看该妹子平均指标 12345678var p = Girl.prototype; // 定义一个原型对象var c = p.constructor; // 该原型对象的构造函数c === Girl; // true Girl.prototype.constructor === Girl 原型对象的构造函数指向其本身// 对实例对象来说，它的构造函数就是它的类lisa.constructor === Girl; // truelisa.__proto__ === Girl.prototype; // __proto__指向构造函数的原型对象lisa instanceof Girl // true 继承自Girl类 构造函数对象：用于生成类的函数，为JavaScript的类定义了名字。 原型对象：类的唯一标识————原型对象的属性被所有实例所继承。如果某个属性是函数的话，就会作为类的实例的方法来使用。 实例对象：类的实例，每一个都是独立的对象。在该实例上添加属性是不会影响其他实例的，但在原型对象上添加方法会影响所有实例。 定义在实例上的非函数属性，实际上是实例字段。 下面定义一个函数，分三步定义一个类。 我们将定义类的步骤封装成一个函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 需要提前声明一个函数/** * [extend 合并对象属性，复制p中对象属性到o中] * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function extend(o, p) &#123; for (prop in p) &#123; // 并不会覆盖对象中原有属性 if (o[prop] === void 0) &#123; o[prop] = p[prop]; &#125; &#125; return o;&#125;/** * [defineClass 定义类的函数] * @param &#123;[type]&#125; constructor [构造函数] * @param &#123;[type]&#125; method [在原型对象上添加属性，可继承] * @param &#123;[type]&#125; static [直接在类上添加属性， 不可继承] * @return &#123;[type]&#125; [返回构造函数] */function defineClass(constructor, method, static) &#123; if (method) &#123; extend(constructor.prototype, method); &#125; if (static) &#123; // static 在严格模式下是保留字，之后请谨慎使用 extend(constructor, static); &#125; return constructor;&#125;// 调用该方法生成另一个类var Girl2 = defineClass( function(pretty, sexualLow, sexualHigh) &#123; if (isNaN(sexualLow) || isNaN(sexualHigh)) &#123; throw new TypeError(); &#125; this.pretty = pretty; this.sexualLow = sexualLow; this.sexualHigh = sexualHigh; &#125;, &#123; foreach: function(f) &#123; f.call(this, this.pretty, this.sexualLow, this.sexualHigh); &#125;, include: function(sexual) &#123; return sexual &gt; this.sexualLow &amp;&amp; sexual &lt; this.sexualHigh; &#125;, toString: function() &#123; console.info(`This girl: $&#123;(this.sexualLow + this.sexualHigh) / 2&#125;$&#123;this.pretty&#125;`); &#125; &#125;, // 随机生成一个性感的妹子 &#123; random: function() &#123; var min = new Date().getMinutes(); var type = (min % 3) === 0 ? 'A': (min % 3) === 1 ? 'B' : 'C'; return `$&#123;Math.ceil(Math.random() * 10) + 30&#125;$&#123;type&#125;`; &#125; &#125;)// 生成一个Girl2的实例var monika = new Girl2('D', 34, 38);monika.foreach(console.info); // D 34 38monika.include(31); // falsemonika.include(35); // truemonika.toString(); // [object Object] 因extend不会覆盖原方法，所以这里仍然是Object.prototype.toString自带方法, 如果要去掉，将extend中的if条件判断去除即可monika.random(); // 报错 Uncaught TypeError: monika.random is not a function(...) 因为monika实例未继承类自身的方法Girl2.random(); // 随机生成 例如：'36C' 毕竟不是灵魂画手，大概便是这样…… ​","link":"/jo.github.io/2016/12/12/understanding-class-in-javascript-part1/"},{"title":"理解 react-router 中的 history","text":"对 react-router 的分析，目前准备主要集中在三点：a. history 的分析。b. react-router 原理分析。c. react-router 内部匹配原理。这篇文章准备着重理解 history.推荐：★★★☆ 索引 引子 history核心 走进createBrowserHistory history在react-router中 小结 坑 参考 引子 一段显而易见出现在各大 react v16+ 项目中的代码是这样的: 1234567891011import React, &#123;Component&#125; from 'react'import &#123; render &#125; from 'react-dom'import AppRouter from './routes/'import &#123; createBrowserHistory &#125; from 'history'const history = createBrowserHistory()const App = () =&gt; ( &lt;AppRouter history=&#123;history&#125; /&gt;)render(&lt;App/&gt;, document.body.querySelector('#app')) 在 react v16+ 版本里，通常 react-router 也升级到了 4 以上。 而 react-router v4+ 通常是配合 history 使用的。 下面就先从 history 开始，让我们一步一步走近 react-router 的神秘世界。 history核心 history源码 history v4.6+ 在内部主要导出了三个方法: createBrowserHistory, createHashHistory, createMemoryHistory. 它们分别有着自己的作用: createBrowserHistory 是为现代主流且支持 HTML5 history 浏览器提供的 API. createHashHistory 是为不支持 history 功能的浏览器提供的 API. createMemoryHistory 则是为没有 DOM 环境例如 node 或 React-Native 或测试提供的 API. 我们就先从最接地气的 createBrowserHistory 也就是我们上文中使用的方法开始看起。 走进createBrowserHistory 话不多说，直接走进createBrowserHistory源码 1234/** * Creates a history object that uses the HTML5 history API including * pushState, replaceState, and the popstate event. */ 在方法开始的注释里，它说明了是基于 H5 的 history 创建对象，对象内包括了一些常用的方法譬如 pushState,replaceState,popstate 等 history 对象 那么它具体返回了什么内容呢，下面就是它目前所有的方法和属性: 1234567891011121314const globalHistory = window.history;const history = &#123; length: globalHistory.length, // (number) The number of entries in the history stack action: \"POP\", // (string) The current action (`PUSH`, `REPLACE`, or `POP`) location: initialLocation, // (object) The current location. May have the following properties. createHref, push, // (function) Pushes a new entry onto the history stack replace, // (function) Replaces the current entry on the history stack go, // (function) Moves the pointer in the history stack by `n` entries goBack, // (function) Equivalent to `go(-1)` goForward, // (function) Equivalent to `go(1)` block, // (function) Prevents navigation listen&#125; globalHistory.length 显而易见是当前存的历史栈的数量。 createHref 根据根路径创建新路径，在根路径上添加原地址所带的 search, pathname, path 参数, 推测作用是将路径简化。 location 当前的 location, 可能含有以下几个属性。 path - (string) 当前 url 的路径 path. search - (string) 当前 url 的查询参数 query string. hash - (string) 当前 url 的哈希值 hash. state - - (object) 存储栈的内容。仅存在浏览器历史和内存历史中。 block 阻止浏览器的默认导航。用于在用户离开页面前弹窗提示用户相应内容。the history docs 其中，go/goBack/goForward 是对原生 history.go 的简单封装。 剩下的方法相对复杂些，因此在介绍 push, replace 等方法之前，先来了解下 transitionManager. 因为下面的很多实现，都用到了这个对象所提供的方法。 transitionManager 方法 首先看下该对象返回了哪些方法： 123456const transitionManager = &#123; setPrompt, confirmTransitionTo, appendListener, notifyListeners&#125; 在后续 popstate 相关方法中，它就应用了 appendListener 和与之有关的 notifyListeners 方法，我们就先从这些方法看起。 它们的设计体现了常见的订阅-发布模式，前者负责实现订阅事件逻辑，后者负责最终发布逻辑。 1234567891011121314151617181920212223242526let listeners = [];/** * [description 订阅事件] * @param &#123;Function&#125; fn [description] * @return &#123;Function&#125; [description] */const appendListener = fn =&gt; &#123; let isActive = true; // 订阅事件，做了函数柯里化处理，它实际上相当于运行了 `fn.apply(this, ...args)` const listener = (...args) =&gt; &#123; if (isActive) fn(...args); &#125;; // 将监听函数一一保存 listeners.push(listener); return () =&gt; &#123; isActive = false; listeners = listeners.filter(item =&gt; item !== listener); &#125;;&#125;;/** * [发布逻辑] * @param &#123;[type]&#125; ..args [description] */const notifyListeners = (..args) =&gt; &#123; listeners.forEach(listener =&gt; listener(..args))&#125; 介绍了上面两个方法的定义，先别急。后续再介绍它们的具体应用。 然后来看看另一个使用的较多的方法 confirmTransitionTo. 123456789101112131415161718192021222324const confirmTransitionTo = ( location, action, getUserConfirmation, callback) =&gt; &#123; if (prompt != null) &#123; const result = typeof prompt === \"function\" ? prompt(location, action) : prompt; if (typeof result === \"string\") &#123; if (typeof getUserConfirmation === \"function\") &#123; getUserConfirmation(result, callback); &#125; else &#123; callback(true); &#125; &#125; else &#123; // Return false from a transition hook to cancel the transition. // 如果已经在执行，则暂时停止执行 callback(result !== false); &#125; &#125; else &#123; callback(true); &#125;&#125;; 实际上执行的就是从外部传进来的 callback 方法，只是多了几层判断来做校验，而且传入了布尔值来控制是否需要真的执行回调函数。 transitionManager 调用 再然后我们来看看上述方法appendListener, notifyListeners 的具体应用。前者体现在了 popstate 事件的订阅中。 那么就先简单谈谈 popstate 事件。 当做出浏览器动作时，会触发 popstate 事件, 也就是说，popstate 本身并不是像 pushState 或 replaceState 一样是 history 的方法。 不能使用 history.popState 这样的方式来调用。 而且，直接调用 history.pushState 或 history.replaceState 不会触发 popstate 事件。 在事件监听方法 listen 中涉及了 popstate 的使用，在源码中可以看到以下两个方法 listen 和 checkDOMListeners. 它们就是上述订阅事件的具体调用方。 12345678910111213141516171819202122232425262728293031323334353637// 首先自然是初始化const transitionManager = createTransitionManager();const PopStateEvent = \"popstate\";const HashChangeEvent = \"hashchange\";// 当 URL 的片段标识符更改时，将触发 hashchange 事件（跟在 # 后面的部分，包括 # 符号）// https://developer.mozilla.org/zh-CN/docs/Web/Events/hashchange// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onhashchangeconst checkDOMListeners = delta =&gt; &#123; listenerCount += delta; if (listenerCount === 1) &#123; // 其实也是最常见最简单的订阅事件 window.addEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange); &#125; else if (listenerCount === 0) &#123; window.removeEventListener(PopStateEvent, handlePopState); if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange); &#125;&#125;;/** * [订阅事件的具体调用方] * @param &#123;Function&#125; listener [description] * @return &#123;Function&#125; [description] */const listen = listener =&gt; &#123; // 返回一个解绑函数 const unlisten = transitionManager.appendListener(listener); checkDOMListeners(1); // 返回的函数负责取消 return () =&gt; &#123; checkDOMListeners(-1); unlisten(); &#125;;&#125;; 简言之，调用 listen 就是给 window 绑定了相应方法，再次调用之前 listen 返回的函数则是取消。 然后来看看发布事件的具体调用方。 1234567// 在该方法中最终发布const setState = nextState =&gt; &#123; Object.assign(history, nextState); history.length = globalHistory.length; // 执行所有的监听函数 transitionManager.notifyListeners(history.location, history.action);&#125;; 下面的方法则应用了 confirmTransitionTo. push, replace 是原生方法的扩展，它们都用到了上述方法，都负责实现跳转，因此内部有较多逻辑相同。 后面会以 push 为例, 它其实就是对原生的 history.pushState 的强化。 这里先从原生的 history.pushState 开始了解。 history.pushState 接收三个参数，第一个为状态对象，第二个为标题，第三个为 Url. 状态对象：一个可序列化的对象，且序列化后小于 640k. 否则该方法会抛出异常。（暂时不知这对象可以拿来做什么用，或许 react-router 用来标识页面的变化，以此渲染组件） 标题(目前被忽略)：给页面添加标题。目前使用空字符串作为参数是安全的，未来则是不安全的。Firefox 目前还未实现它。 URL(可选)：新的历史 URL 记录。直接调用并不会加载它，但在其他情况下，重新打开浏览器或者刷新时会加载新页面。 一个正常的调用是 history.pushState({ foo: &#39;bar&#39;}, &#39;page1&#39;, &#39;bar.html&#39;). 调用后浏览器的 url 会立即更新，但页面并不会重新加载。例如 www.google.com 变更为 www.google.com/bar.html. 但页面不会刷新。 注意，此时并不会调用 popstate 事件。只有在上述操作后，访问了其他页面，然后点击返回，或者调用 history.go(-1)/history.back() 时，popstate 会被触发。 让我们在代码中更直观的看吧。 12345678910111213141516// 定义一个 popstate 事件window.onpopstate = function(event) &#123; console.info(event.state)&#125;let page1 = &#123; page: 'page1' &#125;let page2 = &#123; page: 'page2' &#125;history.pushState(page1, 'page1', 'page1.html')// 页面地址由 www.google.com =&gt; www.google.com/page1.html// 但不会刷新或重新渲染history.pushState(page2, 'page2', 'page2.html')// 页面地址由 www.google.com/page2.html =&gt; www.google.com/page2.html// 但不会刷新或重新渲染// 此时执行history.back() // history.go(-1)// 会触发 popstate 事件, 打印出 page1 对象// &#123; page: 'page1' &#125; 介绍完 pushState 后，看看 history 中是怎样实现它的。 12345678910111213141516171819202122232425262728const push = (path, state) =&gt; &#123; const action = \"PUSH\"; const location = createLocation(path, state, createKey(), history.location); // 过渡方法的应用 transitionManager.confirmTransitionTo( location, action, getUserConfirmation, ok =&gt; &#123; // 布尔值，用于判断是否需要执行 if (!ok) return; const href = createHref(location); const &#123; key, state &#125; = location; // 在支持 history 的地方则使用 history.pushState 方法实现 if (canUseHistory) &#123; globalHistory.pushState(&#123; key, state &#125;, null, href); if (forceRefresh) &#123; window.location.href = href &#125; else &#123; // 如果是非强制刷新时，会更新状态，后续在 react-router 中起到重要作用 setState(&#123; action, location &#125;) &#125; &#125; else &#123; window.location.href = href; &#125; &#125; );&#125;; pushState 和 push 方法讲完，replaceState 和 replace 也就很好理解了。 replaceState 只是把推进栈的方式改为替换栈的行为。它接收的参数与 pushState 完全相同。只是调用后方法执行的效果不同。 补：本来如果仅仅是介绍当前的 history. 我之前以为找到 pushState 这个核心就已经足够了。但当我继续深入，探究 react-router 原理的时候，才发现这里遗漏了重要的一点。那就是 setState 方法。 那么这个方法具体做了什么呢。在上文中已经做了简单介绍，这里再重申一遍：就是将当前 state 存入 history, 同时发布事件，也就是调用之前订阅时的保存的所有方法。参数则是 history.location, history.action. 或许现在，可能我们对它的重要性没有那么深的理解，当你再结合后一篇分析 react-router 的文章。就知道它起的作用了。 history在react-router中 这篇文章快完成的时候，我才发现 react-router 仓库里是有 history 的介绍的。此时我一脸茫然。这里面内容虽然不多，却非常值得参考。这里做部分翻译和理解，当作对上文的补充。 原地址 history is mutable 在原文档中，说明了 history 对象是可变的。因此建议在 react-router 中获取 location 时可以使用 Route 的 props 的方式来替代 history.location 的方式。这样的方式会确保你的流程处于 React 的生命周期中。例如： 1234567891011class Comp extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; // 正确的打开方式 const locationChanged = nextProps.location !== this.props.location // 错误的打开方式，因为 history 是可变的，所以这里总是不等的 // will *always* be false because history is mutable. const locationChanged = nextProps.history.location !== this.props.history.location &#125;&#125;&lt;Route component=&#123;Comp&#125;/&gt; 更多内容请查看the history documentation. 小结 一句话形容 history 这个库。它是一个对 HTML5 原生 history 的拓展，它对外输出三个方法，用以在支持原生 api 的环境和不兼容的环境，还有 node 环境中调用。而该方法返回的就是一个增强的 history api. 写这篇文章的时候，第一次有感受到技术栈拓展的无穷。从最初想分析 react-router，到发现它依赖的主要的库 history. 再进行细化，到 history 主要提供的对象方法。里面涉及的发布订阅设计模式 ，思路，以及具体的实现使用了柯里化方式。一步一步探究下去可以发现很多有趣的地方。似乎又唤起往日热情。 下一篇文章将会继续介绍 react-router. 坑 下面两个方法返回的内容和 createBrowserHistory 基本一致，只是具体的实现有部分差别。有时间补上。 createHashHistory createMemoryHistory 参考react-router 的实现原理react-router 源代码学习笔记 Javascript设计模式之发布-订阅模式","link":"/jo.github.io/2018/07/29/understanding-history-in-react-router/"},{"title":"浅谈 react-router 实现原理","text":"从上篇文章可以知道，react-router 本质上，利用了 history api 的 pushState, replaceState 方法来控制路由地址，然后使用 popstate, hashchange 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。推荐：★★★★ 索引 引子 组件 Link Router Router Route Switch withRouter react-router与react-router-dom 小结 遗留的坑 参考 引子 如上所说，其实在 history 与 react-router 之间，核心就差了视图如何变化的逻辑部分。 在了解到内部原理之前，我理解的流程图是这样的。 接下来我们来慢慢找出这剩余的部分。然后来看看和最初的印象有什么不同。 注意：这里的所有代码均基于 react-router 的 v4+ 版本。 组件 我最初的想法是查看调用栈来观察路由和视图的变化关系。于是写了一个组件，点击事件调用 replaceState 方法来手动更新浏览器地址，但是却发现，不会有什么变化。其实这符合预期，这个方法本身就只会更新地址，而不会更新页面，不会让页面重新加载。 因此，让我们还是从组件入手。 Link Link 是 react-router-dom 提供的一个组件。用来实现路由间的切换。react-router-dom 和 react-router 的关系后文会说。 那为什么 Link 就可以轻松做到跳转呢。让我们一步步来看 Link 里都有什么。 打印出 Link，简化后，主要是以下的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * The public API for rendering a history-aware &lt;a&gt;. */class Link extends React.Component &#123; static defaultProps = &#123; replace: false &#125; static contextTypes = &#123; router: PropTypes.shape(&#123; history: PropTypes.shape(&#123; push: PropTypes.func.isRequired, replace: PropTypes.func.isRequired, createHref: PropTypes.func.isRequired &#125;).isRequired &#125;).isRequired &#125; handleClick = (event) =&gt; &#123; if (this.props.onClick) this.props.onClick(event) if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore right clicks !this.props.target &amp;&amp; // let browser handle \"target=_blank\" etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) &#123; event.preventDefault() const &#123; history &#125; = this.context.router const &#123; replace, to &#125; = this.props if (replace) &#123; history.replace(to) &#125; else &#123; history.push(to) &#125; &#125; &#125; render() &#123; const &#123; replace, to, innerRef, ...props &#125; = this.props // eslint-disable-line no-unused-vars const href = this.context.router.history.createHref( typeof to === 'string' ? &#123; pathname: to &#125; : to ) return &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; href=&#123;href&#125; ref=&#123;innerRef&#125;/&gt; &#125;&#125; 可以很明确的看到，Link 标签本质上返回的是 a 标签。只是对 onClick 方法做了处理。 而在 click 方法里，最主要的处理就是禁用默认事件，也就是阻止 a 标签默认的跳转 href 的行为。避免直接跳转页面。然后使用 history 的 push(pushState) 和 replace(replaceState) 方法进行跳转。 push 方法里除了核心的 pushState 逻辑，还有另一个操作 setState. 详情可见 在它的逻辑里，它调用了之前注册的方法。后文会提到。 这里的 history 就是上篇文章分析的 history，只不过在 react-router 库里，它被当成 props 的部分，由最上层往下传递。至于为何这样做，是可以更好的管理 history, 和在组件里进行 diff 比对从而去做其他处理。 然后观察传入给 a 的参数 to. 它接受 String 或者 Object. 通常我们会以 String 的形式传入。但最终它会被包装成类似 { pathname: to } 这样的格式。 其实这个组件本质上做的事情，和我们在引子里理解的内容类似。基于 history 的操作，那么接收方是如何去根据变化而渲染组件的呢。来看看其他的重要组件。 Link 文档 Router Router 是 react-router 里最常用的组件之一，它接收 history 和 children 两个参数。 这个组件属于较底层的组件，实际应用的时候可能会使用基于它扩展后的组件，来应对不同场景下的需求。例如在官方文档里，列举了以下几个具体的组件。 &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; BrowserRouter 是在现代浏览器里使用较多的组件，它在支持 HTML5 的 history API 的地方可以使用。通过独立的包 react-router-dom 提供。做的事情类似，只是使用方式略有不同，这里不再赘述。 这里是具体的文档 通常情况下，Router 作为父组件，包裹着 Route 和 Switch 等组件。 观察它的源码。它本质上也是 React 组件。在渲染的时候，注册监听了事件。下文细说。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * The public API for putting history on context. */class Router extends React.Component &#123; static propTypes = &#123; history: PropTypes.object.isRequired, children: PropTypes.node &#125; static contextTypes = &#123; router: PropTypes.object &#125; static childContextTypes = &#123; router: PropTypes.object.isRequired &#125; getChildContext() &#123; return &#123; router: &#123; ...this.context.router, history: this.props.history, route: &#123; location: this.props.history.location, match: this.state.match &#125; &#125; &#125; &#125; state = &#123; match: this.computeMatch(this.props.history.location.pathname) &#125; computeMatch(pathname) &#123; return &#123; path: '/', url: '/', params: &#123;&#125;, isExact: pathname === '/' &#125; &#125; componentWillMount() &#123; const &#123; children, history &#125; = this.props // Do this here so we can setState when a &lt;Redirect&gt; changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a &lt;StaticRouter&gt;. this.unlisten = history.listen(() =&gt; &#123; this.setState(&#123; match: this.computeMatch(history.location.pathname) &#125;) &#125;) &#125; componentWillUnmount() &#123; this.unlisten() &#125; render() &#123; const &#123; children &#125; = this.props return children ? React.Children.only(children) : null &#125;&#125;export default Router 在静态 props 里可以看到，history 是必须的。印证了我们的常规用法。生成 history 后再传入组件内。&lt;Router history={history}&gt; 然后在生命周期 componentWillMount 里，使用 history.listen 注册了 setState 事件。当路由变化时，会自动触发 history 内的 setState 事件，进而触发当前传入的更新 state 的事件。原理就是上文的 Link 的内部逻辑，和之前分析的 history 的 push 方法里的逻辑和事件订阅发布逻辑。 然后它返回一个解绑函数。在组件卸载 componentWillUnmount 时调用 unlisten。 这就解释了，为什么 Link 里，点击后的事件，会导致当前 Router 的 state 的变化，进而改变 context.router 里的内容。然后将此传递给子组件 Route. context.router 的简单介绍 Route 首先了解下基本的用法。Route 组件是允许传入几种不同类型的值的。 文档 component: 直接将组件传入。当路由匹配的时候才会渲染，将 props 作为参数传入，然后创建元素。 &lt;Route path=&#39;/&#39; exact component={Main}/&gt; 创建方式：React.createElement(props) render: 返回一个函数，可以直接是包装后的组件，或者直接是元素。直接调用。 &lt;Route path=&#39;/home&#39; render={() =&gt; &lt;Home/&gt;} /&gt; 创建方式：render(props) children: 一个函数，和 render 类似。但它在任何情况下，只要传入值就会渲染。它接收的 props 和其他方式相同，除了在不匹配的情况下，match 的值为 null 这点不同。它的业务场景，可能是用于一些固定显示在页面的组件，然后通过 match 的值来控制样式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import matchPath from './matchPath'/** * The public API for matching a single path and rendering. */class Route extends React.Component &#123; static contextTypes = &#123; router: PropTypes.shape(&#123; history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object &#125;) &#125; getChildContext() &#123; return &#123; router: &#123; ...this.context.router, route: &#123; location: this.props.location || this.context.router.route.location, match: this.state.match &#125; &#125; &#125; &#125; state = &#123; match: this.computeMatch(this.props, this.context.router) &#125; computeMatch(&#123; computedMatch, location, path, strict, exact, sensitive &#125;, router) &#123; if (computedMatch) return computedMatch // &lt;Switch&gt; already computed the match for us const &#123; route &#125; = router const pathname = (location || route.location).pathname return path ? matchPath(pathname, &#123; path, strict, exact, sensitive &#125;) : route.match &#125; componentWillReceiveProps(nextProps, nextContext) &#123; this.setState(&#123; match: this.computeMatch(nextProps, nextContext.router) &#125;) &#125; render() &#123; const &#123; match &#125; = this.state const &#123; children, component, render &#125; = this.props const &#123; history, route, staticContext &#125; = this.context.router const location = this.props.location || route.location const props = &#123; match, location, history, staticContext &#125; return ( component ? ( // component prop gets first priority, only called if there's a match match ? React.createElement(component, props) : null ) : render ? ( // render prop is next, only called if there's a match match ? render(props) : null ) : children ? ( // children come last, always called typeof children === 'function' ? ( children(props) ) : !isEmptyChildren(children) ? ( React.Children.only(children) ) : ( null ) ) : ( null ) ) &#125;&#125;export default Route 在 Route 组件里，首先我们看到 render 里，由组件的内容类型来决定渲染是 component 或 render 或 children. 然后由 this.state.match 这个字段决定了当前的元素是否渲染。 接着在上述源码里，this.state.macth 字段是在 componentWillReceiveProps 和初始化里可以看到。而这个变量，由一个比较重要的函数 computeMatch 返回。它是用来对比当前路由是否匹配，依此来决定渲染组件或者不渲染。它的具体的值下文会讲到。 computeMatch 接收 nextProps 和 context.router 作为参数。首先判断是否处于 Switch 组件中，如果在其中，则直接走 Switch 安排的逻辑，它有着自己的一套计算匹配逻辑。否则，则继续判断。 接下来的核心判断，是获取 pathname, 通过 props.location || context.router.route.pathname 获取。然后将其作为参数，传入另一个重要方法 matchPath 中，做计算匹配的逻辑。 当然，有一些参数作为辅助判断，例如 exact sensitive strict等。 matchPath 是外部引入的，独立的一个文件包装的方法。可以直接看源码。 matchPath源码和文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import pathToRegexp from 'path-to-regexp'const patternCache = &#123;&#125;const cacheLimit = 10000let cacheCount = 0const compilePath = (pattern, options) =&gt; &#123; const cacheKey = `$&#123;options.end&#125;$&#123;options.strict&#125;$&#123;options.sensitive&#125;` const cache = patternCache[cacheKey] || (patternCache[cacheKey] = &#123;&#125;) if (cache[pattern]) return cache[pattern] const keys = [] const re = pathToRegexp(pattern, keys, options) const compiledPattern = &#123; re, keys &#125; if (cacheCount &lt; cacheLimit) &#123; cache[pattern] = compiledPattern cacheCount++ &#125; return compiledPattern&#125;/** * Public API for matching a URL pathname to a path pattern. */const matchPath = (pathname, options = &#123;&#125;) =&gt; &#123; if (typeof options === 'string') options = &#123; path: options &#125; const &#123; path = '/', exact = false, strict = false, sensitive = false &#125; = options const &#123; re, keys &#125; = compilePath(path, &#123; end: exact, strict, sensitive &#125;) const match = re.exec(pathname) if (!match) return null const [ url, ...values ] = match const isExact = pathname === url if (exact &amp;&amp; !isExact) return null return &#123; path, // the path pattern used to match url: path === '/' &amp;&amp; url === '' ? '/' : url, // the matched portion of the URL isExact, // whether or not we matched exactly params: keys.reduce((memo, key, index) =&gt; &#123; memo[key.name] = values[index] return memo &#125;, &#123;&#125;) &#125;&#125;export default matchPath matchPath 通过返回一个对象，来确定路由是否匹配。(官方文档有关于这个对象的介绍match)如果匹配，则返回一个包含 path, url, isExact, params 等属性的对象。否则，则返回 null. 判断的主要逻辑是通过正则。 引入了外部的独立的库 path-to-regexp 来将地址转化成正则。 compilePath 方法里： const re = pathToRegexp(pattern, keys, options) const { re, keys } = compilePath(path, { end: exact, strict, sensitive }) const match = re.exec(pathname) 这里的返回对象，最终在 Route 组件的 render 中起到了决定性的作用。每一个 Route 都会根据这个 match 对象来判断，符合则渲染，不符合则返回 null. 可以看到，除了上述常规判断以外，加了一层缓存逻辑。cache[pattern] 保存了上次的记录。而且属性名也很奇怪，类似 truefalsefalse 的形式。这里暂未理解。 Switch 观察 Switch 的源码可以发现，它本质上也是调用了 matchPath 来判断匹配结果。 这里是文档 1234567891011121314151617181920212223242526272829303132333435import matchPath from './matchPath'/** * The public API for rendering the first &lt;Route&gt; that matches. */class Switch extends React.Component &#123; static contextTypes = &#123; router: PropTypes.shape(&#123; route: PropTypes.object.isRequired &#125;).isRequired &#125; render() &#123; const &#123; route &#125; = this.context.router const &#123; children &#125; = this.props const location = this.props.location || route.location let match, child React.Children.forEach(children, element =&gt; &#123; if (!React.isValidElement(element)) return const &#123; path: pathProp, exact, strict, sensitive, from &#125; = element.props const path = pathProp || from if (match == null) &#123; child = element match = path ? matchPath(location.pathname, &#123; path, exact, strict, sensitive &#125;) : route.match &#125; &#125;) return match ? React.cloneElement(child, &#123; location, computedMatch: match &#125;) : null &#125;&#125;export default Switch withRouter withRouter 是一个高阶组件。个人理解，它比较像是 react-redux 的 Provider 组件。它将原生的组件传入，然后通过 Route 包装，沿用 props 当前的组件，返回这个包装后的组件。 12345678910111213141516171819202122232425import hoistStatics from 'hoist-non-react-statics'import Route from './Route'/*** A public higher-order component to access the imperative API*/const withRouter = (Component) =&gt; &#123; const C = (props) =&gt; &#123; const &#123; wrappedComponentRef, ...remainingProps &#125; = props return ( &lt;Route render=&#123;routeComponentProps =&gt; ( &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125;/&gt; )&#125;/&gt; ) &#125; C.displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)` C.WrappedComponent = Component C.propTypes = &#123; wrappedComponentRef: PropTypes.func &#125; return hoistStatics(C, Component)&#125;export default withRouter 目前在项目中我还没有用到它，等用到的时候，再来补充下具体的使用场景。 这里是文档 react-router与react-router-dom 好了，现在来补充这两个库的不同。 react-router 是一个底层的库，任何其他的基于 React 的路由库都基于它。但是在实际应用中，我们可能要对不同的场景做一些细分，以便更好地使用它们。 于是，就有了为现代浏览器提供的 react-router-dom. 观察代码可以发现，它的核心组件，例如 Route、Switch、withRouter 都是从 react-router 直接引入的。 除此之外，自然还有在 React-Native 中使用的 react-router-native, 以及结合 redux 使用的 react-router-redux 等等。 小结 在了解完这么多组件的内容和原理后，相信我们对于 react-router 的实现，有了一定的清晰的思路了。我们会发现，和最初理解的不一样。其实就是自己的理解在一开始是不完善的，甚至有些误解。这个时候，让我们再把流程图再重新梳理，画一遍。下面是简略的更新逻辑过程。 下面是一张调用栈的图，或许可以更直观地展示调用了哪些方法调用以及他们的执行顺序。 遗漏的坑 到此，相关的主要的逻辑就解释完毕了。 以下是遗留的几个待完成的 TODO. 可能会马上补上也可能需要点时间，但最终，我会补上的。 react-router 或 history 在 node 中的应用。 path-to-regexp 的原理及为何使用缓存。 popstate 和 hashchange 最后到底在哪些地方进行了调用和应用。 参考[译]简明React Router v4教程前端路由实现及 react-router v4 源码分析","link":"/jo.github.io/2019/01/03/understanding-react-router/"},{"title":"webpack实用插件安利之webpack-dashboard","text":"在github上explore的时候偶然发现这款插件，非常火爆，推出没多久就收货了几千stars。我在踩了几个坑后成功引入到公司的项目里。 webpack-dashboard是什么 它是webpack的一个面板，显示webpack在编译时的各种配置和提示信息。 在wd(webpack-dashboard这里简称为wd)引入之前，我们的命令行是这样显示的。 而使用了wd之后，就有了封面的效果。显示上不仅酷炫了很多，各种配置信息，文件大小，占用空间，语法检查也一目了然。 它的使用也非常简单，虽然我在引入时踩了一个不大不小的坑。在这里我要引以为戒。 以我的webpack.config.js为例，这是未加wd之前的js。 12345678910111213141516171819202122var webpack = require('webpack');var path = require('path');var root_path = path.resolve(__dirname);var build_path = path.resolve(root_path, 'build');module.exports = &#123; entry: &#123; 'page/homepage/index': './src/page/homepage/index.js' &#125;, output:&#123; path: build_path, filename: '[name].js' &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: 'style!css' &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;, &#123; test: /\\.less$/, loader: 'style!css!less', exclude: /node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader')&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192&amp;name=img/[name].[ext]' &#125;, &#123; test: /\\.js$/, loaders: ['babel?presets[]=es2015'], exclude: /node_modules/ &#125; ] &#125;&#125;; 我运行webpack-dev-server --inline --devtool eval来进行webpack-dev-server的实时编译。 得到的效果如下，即和第二张图类似。 (请自动忽略那些低级报错) 虽然有log,但这些列表琳琅满目，让人无所适从。密密麻麻的给人里压迫感，使人窒息。 下面来试试wd。 webpack-dashboard使用 install : 在项目目录下npm install webpack-dashboard --save-dev 这里主要说明的是配合webback-dev-server使用的方式。 首先，引入dashboard和插件。 123var Dashboard = require('webpack-dashboard');var DashboardPlugin = require('webpack-dashboard/plugin');var dashboard = new Dashboard(); 其次，在配置部分加入实例化的插件。 1new DashboardPlugin(dashboard, setData); 然后，更新webpack-dev-server的配置。 123456new devServer&#123; publicPath: setting.output.publicPath, // 输出路径 inline: true, port: 2333, // 端口设置 quite: true // 必要参数&#125; 最后，运行命令就可以看见炫酷的效果了。 12345package.json里配置\"scripts\": &#123; \"start\": \"webpack-dev-server\"&#125;再运行`npm start`即可。 ​ Q&amp;A 补充下我运行时发现的一些问题 。 首次运行时有报错,如下。 找了很久，才意识到这是语法错误。它使用了ES6规范。而我当前的node版本是0.10.30,对ES6的支持很差。当我切换到0.12.x的时候，编译就成功了。最终我选择了0.12.10。 npm start时quiet配置会不生效，导致出现的dashboard面板上有重复的log信息。解决办法是运行时添加参数--quiet 最后再来看看配置文件和效果图。 12345678910111213141516171819202122232425262728293031323334353637383940414243var webpack = require('webpack');var path = require('path');var root_path = path.resolve(__dirname);var build_path = path.resolve(root_path, 'build');// dashboardvar Dashboard = require('webpack-dashboard');var DashboardPlugin = require('webpack-dashboard/plugin');var dashboard = new Dashboard();module.exports = &#123; entry: &#123; 'page/homepage/index': './src/page/homepage/index.js' &#125;, output:&#123; path: build_path, filename: '[name].js' &#125;, // webpack-dev-server devServer: &#123; inline: true, port: 2333, // quite: true // 拼写错误 quiet: true // Add quiet option for webpack dashboard &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: 'style!css' &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;, &#123; test: /\\.less$/, loader: 'style!css!less', exclude: /node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader')&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192&amp;name=img/[name].[ext]' &#125;, &#123; test: /\\.js$/, loaders: ['babel?presets[]=es2015'], exclude: /node_modules/ &#125; ] &#125;, plugins: [ new DashboardPlugin(dashboard.setData) ] &#125;;package.json... \"scripts\": &#123; \"start\": \"webpack-dev-server --quiet --content-base src/\", &#125;... Draft for Now赏","link":"/jo.github.io/2016/09/23/webpack-plugin-webpack-dashboard/"},{"title":"webpack小试牛刀","text":"近段时间公司要做一个h5的小项目。一开始我不知道从哪儿下手。在一位前辈的指导下，我用了webpack来打包整理项目。经过不断的入坑尝试之后终于搭建起了一个小项目，虽然还有部分小坑，不过至少跑起来还可以，这里做一个简单总结。 webpack是近期比较火的一款模块加载器兼打包工具，能把各种资源，包括图片，js，样式等都作为模块来处理。官网点这里 优势： 资源管理功能强大 以commonJS的形式来书写脚本，也兼容AMD/CMD 模块化思想。可生成公共模块或者按需加载 能替代部分gulp/grunt的工作 支持开发过程中实时打包 插件机制完善，扩展性强 安装： npm install webpack -g 或者一般把依赖写入package.json 依次运行npm init npm install webpack --save-dev 目录结构 1234567891011121314151617buildnode_modulessrc-page -home -home.html -home.less -index.js -img-img-common-index.js-index.html-all.lesspackage.jsonwebpack.config.jsreadme.md src下是开发文件，用于开发环境 page下的是各个模块，每个模块内有自己的js、img、html、less img存放公用的图片 common存放公用的js build下是src的文件编译好的文件，用于生产环境 项目设计思路 这是个比较简单的项目，没有使用像angularjs，react这样的框架，只用了jQuery，最初的构想就是简单，上手快 基于现在流行的模块化思想，将所有模块放在src下的page里，每个文件夹即一个模块，也就是一个页面 一个common存放公用的方法和配置文件等 index.html是入口页面，all.less是共用的样式，每个页面(模块里)都自己独立的css样式，只是先在每个样式文件里先引入all.less 配置： 通常项目下会配置一个webpack.config.js的文件，作用类似gulp中的gulpfile.js ，这是默认配置文件，当然也可以修改，这是我的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var webpack = require('webpack');var fs = require('fs');var fse = require('fs-extra'); //引入nodejs相关fse.copySync('./src', './build');var dirnames = &#123;&#125;;var dirs = fs.readdirSync('./src/page');// 判断是否是生产环境，不是的话则是开发环境，判断缘由是调试时的入口和要上线时是不一样的var isProduction = function() &#123; return process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'development';&#125;;// 监听所有js文件变化dirs.forEach(function(ele, index)&#123; var dir = './src/page/' + ele; var status = fs.statSync(dir); dirnames['page/index'] = ['./src/page/index.js']; if (status.isDirectory())&#123; dirnames['page/' + ele + '/index'] = []; dirnames['page/' + ele + '/index'].push(dir + '/index.js'); &#125; return dirnames;&#125;);// 修复低版本node编译时报错的问题var Promise = require('es6-promise').Promise;require('es6-promise').polyfill();// 将内部样式改为外部样式的插件，暂时不用// var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");var path = require('path')module.exports = &#123; entry: dirnames, output:&#123; path: path.resolve(__dirname + '/build'), filename: '[name].js' &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: 'style!css', exclude:/node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;, &#123; test: /\\.less$/, loader: 'style!css!less', exclude:/node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader')&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192', exclude:/node_modules/ &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude:/node_modules/ &#125;, &#123; test: /\\.json$/, loader: 'json-loader', exclude:/node_modules/ &#125; ] &#125;, resolve: &#123; // 自动扩展文件后缀名，在文件中可以直接require模块而不写后缀名 extensions: ['', '.js', '.json'], // 模块别名定义，方便直接引入文件 alias: &#123; // page: 'src/page', page: path.resolve(__dirname, 'src/page'), feed: path.resolve(__dirname, 'src/common/feed'), config: path.resolve(_dirname, 'src/common/config') &#125; &#125;, plugins: [ new webpack.DefinePlugin(&#123; 'process.env' : &#123; 'NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'dev') &#125; &#125;), new webpack.optimize.CommonsChunkPlugin('vendors.js) ], externals: &#123; 'jquery': 'jQuery' // 将jQuery赋值为jquery &#125;&#125;; 这个项目最初的考虑是利用模块化思想，将每个页面都分割成一个个模块，然后每个模块有着自己独立的js和img还有样式文件 entry：入口可以是一个或多个资源合并而成。接受数组和对象，这里以对象的形式放入。然后这里因为加入了实时刷新的webpack-dev-server插件，所以加了生产环境还是线上环境的判断.webpack-dev-server下文详细述说 chunk:被entry所依赖的额外的代码块，也可以包含一个或多个文件 webpack的入口文件是多个的。这里引用了nodejs的方法，利用nodejs可以操控文件的优势，先复制不需要编译的文件，节约编译时间。然后找出所有index.js来编译并存放在各自的文件夹下。这里要说明是一开始的思路可能没有考虑全面，用复制文件的方式来写会导致html无法随编译刷新，用html-webpack-plugin也无济于事，日后再解决 ——已解决，看最下。 123456789101112131415161718192021var dirnames = &#123;&#125;;var dirs = fs.readdirSync('./src/page');// 监听所有js文件变化dirs.forEach(function(ele, index)&#123; var dir = './src/page/' + ele; var status = fs.statSync(dir); dirnames['page/index'] = ['./src/page/index.js']; if (status.isDirectory())&#123; dirnames['page/' + ele + '/index'] = []; dirnames['page/' + ele + '/index'].push(dir + '/index.js'); &#125; return dirnames;&#125;);// 修复低版本node编译时报错的问题var Promise = require('es6-promise').Promise;require('es6-promise').polyfill();var path = require('path')module.exports = &#123; entry: dirnames, ......&#125; output: 指输出到哪个目录下，我的项目里就是每个模块对应有着自己的index.js文件，path指的是生成文件的存放目录，filename文件赋值[name].js，会生成相应的文件名，最终存放在build/下 1234output:&#123; path: path.resolve(__dirname + '/build'), filename: '[name].js'&#125; loaders: 这是webpack比较重要的一部分，模块加载器，因为是小项目，在这里我使用的插件并不多，css文件用style-loader和css-loader来处理，less用less-loader来处理，图片用url-loader来处理，目前还支持es6，有babel-loader支持。其中-loader可以省略 所有加载器还是通过npm来下载。例如url-loader，通过npm install url-loader --save-dev下载，它会根据需要将样式中引用的图片转化为base64编码 再如less-loader,它会从右向左寻找文件并进行编译，最终将生成的css放在页面的style里 其中exclude参数表示需要排除的查找目录,include是包含的查找目录，让webpack只编译包含的目录或排除掉部分目录，可以大大加快它的编译速度 123456789module: &#123; loaders: [ &#123; test: /\\.css$/, loader: 'style!css', exclude:/node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader')&#125;, &#123; test: /\\.less$/, loader: 'style!css!less', exclude:/node_modules/ &#125;, // ExtractTextPlugin.extract('style-loader', 'css-loader!less-loader')&#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192', exclude:/node_modules/ &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude:/node_modules/ &#125;, &#123; test: /\\.json$/, loader: 'json-loader', exclude:/node_modules/ &#125; ] &#125; resolve则看注释即可 definePlugin插件，用于判断是生产环境还是线上环境，在部署时或者切换环境时非常有用 12345new webpack.DefinePlugin(&#123; 'process.env' : &#123; 'NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'dev') &#125;&#125;) providePlugin: 通常情况下我们都需要先require相关资源，并赋值给变量才可以使用，比如要在js顶部引入var $ = require(&#39;jquery&#39;)才可以使用$,而在每个页面都这样操作很繁琐。于是可以利用该插件一次定义，处处使用。无须再在页面顶部引入。 123456new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery', '_': 'lodash'&#125;) alias:别名(请求重定向)。定义别名可以方便文件快速查找并加快编译速度。文件查找的时间大大缩减。之前我是这么写的 123456var feed = require('../../common/feed/index'); // 一个存放公用方法的文件,每个页面都写长长的这么一句然而现在是这样var feed = require('feed/index');或者它会去找该文件夹下面的index.js，所以可以更简单var feed = require('feed');不只是书写方便了，而且webpack的编译也更快了 commonsChunk:将公共模块提取出来,利用浏览器缓存机制提高页面加载效率。避免每个文件都引用一次，影响加载速度 1new webpack.optimize.CommonsChunkPlugin('vendors.js) uglifyjs:将生产环境中的js代码进行压缩和混淆,缩小文件加快请求速度 1webpack.optimize.UglifyJsPlugin(&#123;minimize: true&#125;) externals:为避免第三方库或框架被合成或打包成公共模块浪费资源。可以采用cdn引入的方式。这就需要进行一些设置 首先在页面的html里引入cdn上的文件 1&lt;script src=\"https://code.jquery.com/jquery-1.11.1.min.js\" integrity=\"sha256-VAvG3sHdS5LqTT+5A/aeq/bZGa/Uj04xKxY8KM/w9EE=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 然后在webpack.config.js里设置 123externals: &#123; 'jquery': 'jQuery' // 将jQuery赋值为jquery&#125; 运行 webpack 可以直接运行webpack执行一次性编译，建议运行时加上以下参数 --display-error-details 方便查看出错时的报错信息 --progess --color 输出呈彩色，进度条显示编译进度 -p 生产环境压缩代码 HTML页面引入 直接在html里加入 &lt;script type=&#39;text/javascript&#39; src=&#39;index.js&#39;&gt;即可 index.js HTML中不引入样式，是因为在这里就引入了。在页面顶部加上require(&#39;../[name].less&#39;) [name]指代当前less的文件名，我的做法是在每个less里引入一个公用的all.less,然后不同页面的js里引入各自的less，webpack会自动编译less并放在页面的style里 其实还尝试过使用ExtractTextPlugin.extract(&#39;style-loader&#39;, &#39;css-loader&#39;)} 插件，将页面顶部的样式改为外部文件引入，但因为开始时设计的偏差，改动起来比较麻烦，最后作罢 这是个小项目，只引入了jquery和自己的公用的一个库 reqiure(&#39;feed&#39;) 通过process.env.NODE_ENV的值判断开发环境的接口，是引用测试的接口还是线上的接口，它的值不同时会引用不同的js文件 所以最终每个index.js的顶部会有这么几行 12345require('./style.less');var feed = require('feed');var url = require('config/env/' + process.env.NODE_ENV);// 执行该页面的逻辑代码...... 如何自动刷新 使用webpack-dev-server webpack-dev-server是一个静态轻量的express资源服务器，只用于开发环境 它的作用就是把编译后的静态文件全部保存在内存里，而不会写到文件目录内 安装:npm install webpack-dev-server --save-dev 这里采用了双服务器模式，一个后端服务器和一个资源服务器 运行 NODE_ENV=local webpack-dev-server --inline --hot --devtool --content-base build/ 得到的entry应当是这样的 12345678entry: &#123; 'page/index': [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/dev-server', './src/page/index.js' ] &#125; NODE_ENV 作为环境变量，决定启用使用测试接口或是线上接口 –hot 选项的工作其实就是把webpack/hot/dev-server加到了entry中，如果成功了，运行命令后的控制台里会有以下信息 12[HMR] Waiting for update signal from WDS...[WDS] Hot Module Replacement enabled. 采用 –inline 模式，它的工作其实就是把webpack-dev-server/client?http://localhost:8080加到entry中 –content-base 把build/下的内容作为静态资源服务 –devtool eval 配置devtool的值为eval，用于查看编译后的源代码，eval 不支持生产环境查看源代码，但编译速度快，另一个常用的值是source-map，支持生产环境，但相对慢 打开 localhost:8080/webpack-dev-server/page/index.html查看 package.json 配置1234script: &#123; \"dev\": \"rm -rf build &amp;&amp; NODE_ENV=local webpack-dev-server --inline --hot --devtool eval --progress --colors --content-base build/\", \"web\": \"NODE_ENV=development webpack --progress --colors --display-error-details\",&#125; 运行npm run dev 开发环境下 npm run web 测试环境下 目前遗留问题 hot热加载未生效 html文件更改无法刷新同步到页面 该问题已解决。出现问题的原因是加载在页面上的是编译好的build下面的文件，但html支持的监听刷新是开发文件，所以只要更改运行脚本即可——将build改为src，如下： &quot;dev&quot;: &quot;rm -rf build &amp;&amp; NODE_ENV=local webpack-dev-server --inline --hot --devtool eval --progress --colors --content-base src/&quot; 多页面项目没有很好的方案去构建自动化 小结 这是自己的第一个独立项目，绝大部分工作都是自己完成的，前辈指导了一部分，后来就全部自己做了。当然还是并不太成熟，遗留几个问题目前找不到解决办法。webpack给我的体会是编译速度非常快，或许也和现在项目中的依赖比较少有关。不管怎样，这个项目目前还会维护下去，会不定期更新，解决遗留问题。","link":"/jo.github.io/2016/07/03/webpack-trytry/"},{"title":"微信内置浏览器兼容性问题汇总","text":"本文列举了个人在微信公众号里开发时所遇到的浏览器兼容性问题。不定期更新。 1.ios内置微信浏览器不支持active伪类。 解决办法：添加触摸事件： 1document.body.addEventListener('touchstart',function()&#123;&#125;) 2.百度地图api在微信内不生效，应当是微信做了屏蔽工作 3.ios端微信浏览器会给input框加上自带的样式，例如圆角和内阴影。是因为-webkit-appearance这个属性的影响 appearance CSS规范*解决办法：给input添加以下样式 12345input &#123; appearance: none; -webkit-appearance: none; /* safari */ -moz-appearance: none;&#125; 4.ios端微信浏览器，包括ios上所有使用Safari内核的浏览器，都会有该问题—— 直接在window, document, body下绑定click事件，点击body不会触发 几个解决办法 使用touch事件，但在弹出层上会有点透问题 避免bug触发：不要委托事件在body结点上。可以指定任何除了上述元素外的父元素，给该元素下的元素绑定事件。 已触发情况：safari对事件的解析比较特殊，事件有响应过，则会一直冒泡（捕获）到根节点，对于大规模触发的情况，只要在body元素的所有子元素绑定一个空事件，如： 1$('body &gt; *').on('click', function() &#123;&#125;); 5.ios系统下的浏览器，会自动识别疑似电话号码的数字，将其添加自动拨号功能： 18878898922会被自动修改为&lt;a href=&quot;tel:18878898922&quot;&gt;&lt;/a&gt;,就有了自动拨号功能。 但有时是不需要这个鸡肋功能的，解决办法是在页面顶部添加一行&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;禁用该功能。 format-detection决定启用或禁用该功能 6.微信分享的缩略图 微信中分享网页时会有缩略图，该缩略图默认是网页中的第一张图片，无论显不显示 但是图片大小小于400px * 400px 时，或者直接将图片隐藏会导致无法显示 所以较好的解决方案是在标签 img 外面加父元素 div ,给 div 设置: 1&lt;div style=\"margin: 0 auto;width: 0;height: 0; overflow: hidden\"&gt;&lt;/div&gt; 而图片无需处理，最终可写成如下: 123&lt;div style=\"margin: 0 aut0; width: 0; height: 0; overflow: hidden;\"&gt; &lt;img src=\"./images/pic.png\"/&gt;&lt;/div&gt;","link":"/jo.github.io/2016/11/01/wechat-compatible-problems/"},{"title":"Jasin Yip 计蒜客前端知乎 Live 笔记","text":"一次知乎 Live 听讲的笔记记录。 1. 如何成为高效率的工程师 减少重复工作：学会使用git alias，熟练使用命令行；熟练工具，武装自己。 时间管理：日程表安排——倒三角安排工作，周一满，周二缺一小时，周三减2个小时。 2. 有效的沟通方式 减少面对面交流，使用工具，邮件等。 一次说明一件事，完整的一件事。 3. 正确的提问方式 反面教材： 不直接了当——最好一次说清来意，表名问题。 方向问题，问前程——信息量少，难以说清。 减少他人理解问题的成本, 业务代码写成demo.例如去 jsbin、jsfiddle 等网站写 demo. 付费提问。 4. 计算机基础和方法论 计算机基础: 算法，操作系统，计算机网络，内存的使用…(内存泄漏)。 算法(解决问题的思路): 递归问题——文件树。 方法论：设计模式，编程范式。 设计模式：单例模式。 编程范式：OOP面向对象编程，面向过程，函数式编程。 函数式编程：pure function(思维转变), 可维护， 可扩展，可测试，闭包提高了函数的内聚性,不依赖外部条件，更容进行单元测试。 《大话设计模式》(C#)。 5. 前端的多样化的技术 学框架是理解一种思想，理解解决问题的思路: react 的组件化思想, angular的双向数据绑定。 6. 如何写优雅的代码 命名规范，制定团队规范， 参考大厂的规范，向大厂学习。 7. 公司代码不完美 部分代码与业务相关。 查看是否有发挥空间，是否可以改进，以自己的能力去推动改进，和上级沟通表达，锻炼表达能力，提高技术能力。 8. 代码质量差 引入一些检查lint: pre-commit、aslant? 、csslint、facebook-flow typescript. 任何的代码都可以 code review. 9. 提升个人影响力 影响力就是话语权(权利)（职位职级）, 决定框架，决定选型。 影响力来自能力，时刻准备着，当机会出现时把握住。推销自己的机会，让大厂关注自己的机会。 《程序员的自我营销》。 10. 前端工程师接触的其他领域 计算机基础原理是必要的。 增加技术的广度。 学习编程语言传达的思想。 11. 框架技术选型 考虑学习成本。 对各种框架的优缺点有所了解。 12. 初学者的建议 注重基础知识。 成长：一年之内多写业务，累积经验。 刷题：算法题之类，基础题。 《JavaScript设计模式与开发实践》。 13. 提升英语 可以参与掘金翻译计划。 多看英语类的技术文章，强迫自己去接触英语，感受英语的氛围。","link":"/jo.github.io/2017/02/05/zhihulive-Jasin-Yip/"},{"title":"前端 vczero 三年从前端小工到架构分享","text":"知乎 live：三年从前端小工到架构分享的笔记及感悟 0-3 年工程师发展，快速成长概览 技能：js，css——追求新技术。 能力：编程能力，实现一个功能的能力，抽象能力。 技能—&gt;思考—&gt;能力。 提高认知，提升格局，拓展眼界。 避免狭隘认知。理解片面——在没有深入了解一个框架时就妄加评判。 在巩固基础的同时拓展眼界。 财富积累：资源调度和资本运作（例如买房）。 内容 起步阶段： 踏实看完基础书籍。 深入理解基础语法。(练习，不依靠文档独立完成) 心情浮躁时完成 demo 来提升成就感。 记录，思考。建立一套良好的笔记系统。 注重方法论，长时间无法实现一个任务或功能时注意学会变通。 书籍推荐：《DOM 编程艺术》《JS高级程序设计》《CSS权威指南》 注重原生语法，底层知识。 了解服务端的开发模式。横向拓展知识。 学习算法与数据结构。 学习打包工具的底层原理。 快速成长： 找一个导师，向导师学习工作方式，思考方式，思维方式。 培养职业素养。邮件发送，抄送格式。建立一个工作群组，要分清楚需要邀请哪些人。跨部门协作时能要提高协调资源的能力。 技术发散和聚合。跨界、横向、广度。扩展技术边界，横向发现。 安排的工作专注完成，至少完成百分之百。如果在技术上难以突破，在其他方面加强，例如文档完善，邮件发送。 感恩。圈子很小。建立良好的人际关系。 个人的成长与团队的成长是密不可分的。个人的价值在团队中才能充分发挥体现。能力越大，责任越大，承担的事越多。 技术管理和前端架构 前端架构：技术选型到运维，整个技术体系。负责整个项目的可扩展性，可维护性。 技术 or 管理： 三五年后的发展，选择技术方向的在国内有一定瓶颈。小型公司内难做，没有这一职位。 选择管理方向的不能脱离代码。建立较好的人际关系，具有一定的产品思维。 提升技术影响力 公司内影响力。 社区内影响力。 提问时要有诚意，问完整的问题，提供完善的开发环境。问问题时带上自己的思考，引起大牛的注意。 个体的差异化，给自己贴上一些标签，给人留下印象。 在 github 上管理的代码是完善的，不是纯测试用的。有产品思维，当做产品来管理。每个项目都是完善的产品。 加入圈子的时候表现自己的诚意，放出自己的深层思考。 将碎片化的知识整理成系统化的知识。 个人总结 个人而言，觉得这次 live 并不太适合自己。虽然自己处在 0-3 年这个区间内，但提到的不太适用或者是属于已知的。 这次的 live 相对比较空，难以具象化。个人感觉大部分说的是要做什么，不要做什么，而不是要具体做什么，具体不做什么。或许自己听的也不够清楚，总之不适用自己。 Q&amp;A 环节的体验，和前两次 live 的差不多，对个体而言干货较少。那些问题其实问其他人也会有相似的回答，只是处在迷茫阶段的提问者难以看清。这里对自己而言有价值的部分不多，有部分自己确实已经意识到了，而在实践上可以更下一些功夫。 其实每次听 live，技术上的收获是不多的。较多的是扩展一些眼界，开拓思路的地方。看看在技术上有一定成就的人是怎么做分享，怎么在技术这条路上越走越好的，他们的成功经历是否可以给自己一些启示。虽然这次分享的标题写着三年的发展，但其实在这三年的第 0 年，也就是作者毕业的那年，基础已经超过绝大多数人了，这是在毕业前就已经准备了的。所以三年后能做到架构师这一步，不是这三年的积累成果，而是五年甚至更多年积累的成果。分享者提到，在大学阶段，每周有固定的时间用于写代码和思考。只这一点，已经拉开了差距。现在当我处在工作一年多、毕业近两年的阶段，其实落后了很多。但重要的是，时刻提醒自己这一点，然后让这点鞭挞自己不断前进。 于我而言，另一个听 live 的好处是提高自己对技术的积极性。近段时间因为适应新工作，对技术方面的热情有所下降。通过 live 和大牛近距离接触，可以唤起自己的积极性。尽管因为听讲被分成了片段式效果没有那么好，但至少记录下了部分内容，在这里做一个简单的总结和回顾。整理依旧比较碎片化，成了分享里的反例，部分内容加上了些自己的想法和理解。但整体我觉得没有再更进一步整理的必要，如果后续再想到，再对上面的一些内容加些其他的感悟和思考。 不管怎样，感谢这些在技术上有一定地位的人拿出他们的时间来做分享。也许这些分析并不对每个人都适用，但总有一部分是能给予初入前端的人一些帮助的。谢谢他们。","link":"/jo.github.io/2017/04/01/zhihulive-vczero/"},{"title":"小爝前端自我提升知乎 Live 笔记","text":"记录一次知乎 Live 的笔记，加上部分自己的理解。 1. 初级前端起步 制定小目标。 通过目标制定计划。 寻找实现目标所需的资源。 和比自己水平高一两个level的人交流，直接和大牛交流也许会有障碍，水平相差较多，水平高的人习以为常的东西，新手也许并不难理解，造成沟通低效。 写技术日记(技术博客)。 鼓励意识、荣誉感——去社区里回答问题。 2. 在成熟公司中成长 成熟公司：内部有大牛，体系完善，体量大，多人开发，协同管理机制完整。 始终关注新技术的内容。 在阿里：勤奋——花时间去阅读，写代码。下班之余，晚9点至12点，早起4点至8点。 如何高效阅读英文文档：上手指南 =&gt; API大类 =&gt; 插件整体概览 =&gt; 了解框架的功能——解决的问题和不能解决的问题 =&gt; 定位相应的插件，查看具体插件的示例代码。 不能让自己太舒服，克服惰性；习惯开发节奏；了解公司框架结构；熟悉公司业务。 公司内高级前端的要求：熟悉工程化，组件化，模块化开发；有创新，创新的内容可以影响业务线；可以为公司业务带来收益；可以提供讲座；有一定的带人经验，是合格甚至优秀的导师。 在新浪： 待过多个部门，在新浪博客，手机新浪网等部门，有实现自己的打包工具供内部使用。 找到公司痛点，解决痛点，带领大家来解决痛点，是提升自己的一种好的方式。 对待问题和知识点刨根揪底、精益求精的态度。 3. 团队与个人，谁在起进步作用 相辅相成。 成为技术 leader，有担当，主动接手复杂的项目，解决疑难杂症，解决其他人解决不了的问题。 团队不代表个人，当自己离开团队的时候同样有自己的能力。 有自己的方向，技术栈，不断进步。 4. 没有参与过0-1的前端项目怎么办 不断创新，开发新的插件，新的系统，新的工具。 有自己的个人项目。 参加黑客马拉松。 有一定产品思维。 5. 前端人员对后端需要掌握到什么程度 了解：可以使用后端语言做动态网站，完成基本的增删改查、数据库的安装、服务器的配置。 进阶：使用 nodejs 等开发静态服务器；可以开发 web 应用，开发 web 框架开发；解决并发问题；了解服务器；了解 shell. MVC MVP MVVM 6. 前端技术如何做到精益求精 找到学习的平衡点，避免过度设计。在已有的水平上一步一步、脚踏实地发展。 提高自己的眼界，去看经典，学习经典，感受好的代码，营造一个好的代码氛围。 每天解决一个小问题，当天解决。积少成多，慢慢积累。 7. 未来的前端工程师应该如何发展，怎么看待不断更新的框架和各种技术概念 关注本质。新技术是否是能解决当前公司的痛点，解决某个场景的问题。大而全、可以解决所有问题的框架一般活不久。 发展趋势是客户端化。很多思想(MVVM)是客户端引入到前端中的。 移动端迭代非常快。保持和移动端设备规范的一致性。 未来的几种可能：浏览器内置组件，解析编译的代码。浏览器不更新，热更新。增量更新。 关注 web 条件，硬件变化。 混合式开发：React-Native.适当学习客户端，后端。 Q&amp;A高效自学 js 看书：《JavaScript 语言精粹》《DOM 编程艺术》。 查看网站的部分功能，思考如何实现同样的功能。 如果可以实现，在脑海里理清思路过一遍。不能实现，则找出实现的方法，熟悉并理解。 清理客户端缓存方法 在 js 等文件后加时间戳。 更改 js 文件名字。 如何快速上手大型项目 找到大型项目的文件入口。 找到每个页面对应的 js。 package.json. readme.md. test(单元测试，测试用例). src(开发目录). dist(编译目录). 制定小目标 学会使用一些抓包工具, 例如 fiddler(windows), charles(mac). 如何实现自己不会的动效 查看别人的源码，找到引用的开源插件。 学习使用该开源插件，或是学习源码。","link":"/jo.github.io/2017/02/05/zhihulive-xiaojue/"}],"tags":[{"name":"ES2015","slug":"ES2015","link":"/jo.github.io/tags/ES2015/"},{"name":"HTTP","slug":"HTTP","link":"/jo.github.io/tags/HTTP/"},{"name":"Angular","slug":"Angular","link":"/jo.github.io/tags/Angular/"},{"name":"JavaScript","slug":"JavaScript","link":"/jo.github.io/tags/JavaScript/"},{"name":"chrome","slug":"chrome","link":"/jo.github.io/tags/chrome/"},{"name":"CSS3","slug":"CSS3","link":"/jo.github.io/tags/CSS3/"},{"name":"eslint","slug":"eslint","link":"/jo.github.io/tags/eslint/"},{"name":"wepay","slug":"wepay","link":"/jo.github.io/tags/wepay/"},{"name":"git","slug":"git","link":"/jo.github.io/tags/git/"},{"name":"css","slug":"css","link":"/jo.github.io/tags/css/"},{"name":"WebGl","slug":"WebGl","link":"/jo.github.io/tags/WebGl/"},{"name":"Parcel","slug":"Parcel","link":"/jo.github.io/tags/Parcel/"},{"name":"Shell","slug":"Shell","link":"/jo.github.io/tags/Shell/"},{"name":"Unit-Testing","slug":"Unit-Testing","link":"/jo.github.io/tags/Unit-Testing/"},{"name":"sublime","slug":"sublime","link":"/jo.github.io/tags/sublime/"},{"name":"Git","slug":"Git","link":"/jo.github.io/tags/Git/"},{"name":"nginx","slug":"nginx","link":"/jo.github.io/tags/nginx/"},{"name":"interview","slug":"interview","link":"/jo.github.io/tags/interview/"},{"name":"React","slug":"React","link":"/jo.github.io/tags/React/"},{"name":"DOM","slug":"DOM","link":"/jo.github.io/tags/DOM/"},{"name":"compatibility","slug":"compatibility","link":"/jo.github.io/tags/compatibility/"},{"name":"webpack","slug":"webpack","link":"/jo.github.io/tags/webpack/"},{"name":"WebGL","slug":"WebGL","link":"/jo.github.io/tags/WebGL/"},{"name":"React-Router","slug":"React-Router","link":"/jo.github.io/tags/React-Router/"},{"name":"兼容性","slug":"兼容性","link":"/jo.github.io/tags/兼容性/"},{"name":"zhihu live","slug":"zhihu-live","link":"/jo.github.io/tags/zhihu-live/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/jo.github.io/categories/JavaScript/"},{"name":"HTTP","slug":"HTTP","link":"/jo.github.io/categories/HTTP/"},{"name":"Library","slug":"Library","link":"/jo.github.io/categories/Library/"},{"name":"Browser","slug":"Browser","link":"/jo.github.io/categories/Browser/"},{"name":"CSS","slug":"CSS","link":"/jo.github.io/categories/CSS/"},{"name":"Wechat","slug":"Wechat","link":"/jo.github.io/categories/Wechat/"},{"name":"Git","slug":"Git","link":"/jo.github.io/categories/Git/"},{"name":"threejs","slug":"threejs","link":"/jo.github.io/categories/threejs/"},{"name":"Tools","slug":"Tools","link":"/jo.github.io/categories/Tools/"},{"name":"Shell","slug":"Shell","link":"/jo.github.io/categories/Shell/"},{"name":"Unit-Testing","slug":"Unit-Testing","link":"/jo.github.io/categories/Unit-Testing/"},{"name":"Front-end","slug":"Front-end","link":"/jo.github.io/categories/Front-end/"},{"name":"Server","slug":"Server","link":"/jo.github.io/categories/Server/"},{"name":"Interview","slug":"Interview","link":"/jo.github.io/categories/Interview/"},{"name":"React","slug":"React","link":"/jo.github.io/categories/React/"},{"name":"DOM","slug":"DOM","link":"/jo.github.io/categories/DOM/"},{"name":"macos","slug":"macos","link":"/jo.github.io/categories/macos/"},{"name":"Zhihu Live","slug":"Zhihu-Live","link":"/jo.github.io/categories/Zhihu-Live/"}]}