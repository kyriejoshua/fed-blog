<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>浅谈 react-router 实现原理 - Deadpool Front-end</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="前端 前端痴汉 前端博客 前端分享 技术 技术成长 成长之路">





    <meta name="description" content="从上篇文章可以知道，react-router 本质上，利用了 history api 的 pushState, replaceState 方法来控制路由地址，然后使用 popstate, hashchange 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。推荐：★★★★">
<meta name="keywords" content="React-Router">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈 react-router 实现原理">
<meta property="og:url" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/index.html">
<meta property="og:site_name" content="Deadpool Front-end">
<meta property="og:description" content="从上篇文章可以知道，react-router 本质上，利用了 history api 的 pushState, replaceState 方法来控制路由地址，然后使用 popstate, hashchange 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。推荐：★★★★">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/unphoto.jpg">
<meta property="og:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/react-router.png">
<meta property="og:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/react-router-road.png">
<meta property="og:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/react-router-stack.png">
<meta property="og:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/reward.jpeg">
<meta property="og:updated_time" content="2019-06-25T11:05:34.940Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈 react-router 实现原理">
<meta name="twitter:description" content="从上篇文章可以知道，react-router 本质上，利用了 history api 的 pushState, replaceState 方法来控制路由地址，然后使用 popstate, hashchange 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。推荐：★★★★">
<meta name="twitter:image" content="http://kyriejoshua.github.io/2019/01/03/understanding-react-router/unphoto.jpg">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">Archives</a>
            
            <a class="navbar-item " href="/categories">Categories</a>
            
            <a class="navbar-item " href="/tags">Tags</a>
            
            <a class="navbar-item " href="/books">Books</a>
            
            <a class="navbar-item " href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            浅谈 react-router 实现原理
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2019-01-03T13:59:22.000Z" itemprop="datePublished">1月 3 2019</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/React/">React</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            26 分钟 读完 (约 3846 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <hr>

<p><img src="/2019/01/03/understanding-react-router/unphoto.jpg" alt></p>
<p>从<a href="/2018/07/29/understanding-history-in-react-router">上篇文章</a>可以知道，<code>react-router</code> 本质上，利用了 <code>history api</code> 的 <code>pushState</code>, <code>replaceState</code> 方法来控制路由地址，然后使用 <code>popstate</code>, <code>hashchange</code> 事件来监听变化，从而做出相应的视图变化。这篇文章要讲的，就是视图变化的逻辑这部分。<br>推荐：★★★★</p>
<a id="more"></a>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li><a href="#引子">引子</a></li>
<li><a href="#组件">组件</a><ul>
<li><a href="#Link">Link</a></li>
<li><a href="#Router">Router</a></li>
<li><a href="#Router">Router</a></li>
<li><a href="#Route">Route</a></li>
<li><a href="#Switch">Switch</a></li>
<li><a href="#withRouter">withRouter</a></li>
</ul>
</li>
<li><a href="#react-router与react-router-dom">react-router与react-router-dom</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#遗留的坑">遗留的坑</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><ul>
<li>如上所说，其实在 <code>history</code> 与 <code>react-router</code> 之间，核心就差了视图如何变化的逻辑部分。</li>
<li>在了解到内部原理之前，我理解的流程图是这样的。</li>
</ul>
<img src="/2019/01/03/understanding-react-router/react-router.png">

<ul>
<li>接下来我们来慢慢找出这剩余的部分。然后来看看和最初的印象有什么不同。</li>
<li>注意：这里的所有代码均基于 <a href="https://github.com/ReactTraining/react-router/tree/v4.2.2" target="_blank" rel="noopener"><code>react-router</code></a> 的 v4+ 版本。</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>我最初的想法是查看调用栈来观察路由和视图的变化关系。于是写了一个组件，点击事件调用 <code>replaceState</code> 方法来手动更新浏览器地址，但是却发现，不会有什么变化。其实这符合预期，这个方法本身就只会更新地址，而不会更新页面，不会让页面重新加载。</li>
<li>因此，让我们还是从组件入手。</li>
</ul>
<h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router-dom/modules/Link.js" target="_blank" rel="noopener">Link</a></h4><ul>
<li><p><code>Link</code> 是 <code>react-router-dom</code> 提供的一个组件。用来实现路由间的切换。<code>react-router-dom</code> 和 <code>react-router</code> 的关系后文会说。</p>
</li>
<li><p>那为什么 <code>Link</code> 就可以轻松做到跳转呢。让我们一步步来看 <code>Link</code> 里都有什么。</p>
</li>
<li><p>打印出 <code>Link</code>，简化后，主要是以下的部分。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The public API for rendering a history-aware &lt;a&gt;.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Link</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> defaultProps = &#123;</span><br><span class="line">    replace: <span class="hljs-literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.shape(&#123;</span><br><span class="line">        push: PropTypes.func.isRequired,</span><br><span class="line">        replace: PropTypes.func.isRequired,</span><br><span class="line">        createHref: PropTypes.func.isRequired</span><br><span class="line">      &#125;).isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.onClick)</span><br><span class="line">      <span class="hljs-keyword">this</span>.props.onClick(event)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (</span><br><span class="line">      !event.defaultPrevented &amp;&amp; <span class="hljs-comment">// onClick prevented default</span></span><br><span class="line">      event.button === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-comment">// ignore right clicks</span></span><br><span class="line">      !<span class="hljs-keyword">this</span>.props.target &amp;&amp; <span class="hljs-comment">// let browser handle "target=_blank" etc.</span></span><br><span class="line">      !isModifiedEvent(event) <span class="hljs-comment">// ignore clicks with modifier keys</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">const</span> &#123; history &#125; = <span class="hljs-keyword">this</span>.context.router</span><br><span class="line">      <span class="hljs-keyword">const</span> &#123; replace, to &#125; = <span class="hljs-keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (replace) &#123;</span><br><span class="line">        history.replace(to)</span><br><span class="line">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        history.push(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; replace, to, innerRef, ...props &#125; = <span class="hljs-keyword">this</span>.props <span class="hljs-comment">// eslint-disable-line no-unused-vars</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> href = <span class="hljs-keyword">this</span>.context.router.history.createHref(</span><br><span class="line">      <span class="hljs-keyword">typeof</span> to === <span class="hljs-string">'string'</span> ? &#123; <span class="hljs-attr">pathname</span>: to &#125; : to</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#123;href&#125;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;innerRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  &#125;</span></span><br><span class="line"><span class="hljs-xml">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以很明确的看到，<code>Link</code> 标签本质上返回的是 <code>a</code> 标签。只是对 <code>onClick</code> 方法做了处理。</p>
</li>
<li><p>而在 <code>click</code> 方法里，最主要的处理就是<strong>禁用默认事件</strong>，也就是阻止 <code>a</code> 标签默认的跳转 <code>href</code> 的行为。避免直接跳转页面。然后使用 <code>history</code> 的 <code>push</code>(<code>pushState</code>) 和 <code>replace</code>(<code>replaceState</code>) 方法进行跳转。</p>
</li>
<li><p><code>push</code> 方法里除了核心的 <code>pushState</code> 逻辑，还有另一个操作 <code>setState</code>. <a href="https://github.com/ReactTraining/history/blob/v4.6.0/modules/createBrowserHistory.js" target="_blank" rel="noopener">详情可见</a> 在它的逻辑里，它调用了之前注册的方法。后文会提到。</p>
</li>
<li><p>这里的 <code>history</code> 就是上篇文章分析的 <code>history</code>，只不过在 <code>react-router</code> 库里，它被当成 <code>props</code> 的部分，由最上层往下传递。至于为何这样做，是可以更好的管理 <code>history</code>, 和在组件里进行 <code>diff</code> 比对从而去做其他处理。</p>
</li>
<li><p>然后观察传入给 <code>a</code> 的参数 <code>to</code>. 它接受 <code>String</code> 或者 <code>Object</code>. 通常我们会以 <code>String</code> 的形式传入。但最终它会被包装成类似 <code>{ pathname: to }</code> 这样的格式。</p>
</li>
<li><p>其实这个组件本质上做的事情，和我们在引子里理解的内容类似。基于 <code>history</code> 的操作，那么接收方是如何去根据变化而渲染组件的呢。来看看其他的重要组件。</p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router-dom/docs/api/Link.md?1546863412144" target="_blank" rel="noopener"><strong>Link 文档</strong></a></p>
</li>
</ul>
<!-- 打印下 link 方法里的东西 -->

<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/modules/Router.js" target="_blank" rel="noopener">Router</a></h4><ul>
<li><p><code>Router</code> 是 <code>react-router</code> 里最常用的组件之一，它接收 <code>history</code> 和 <code>children</code> 两个参数。</p>
</li>
<li><p>这个组件属于较底层的组件，实际应用的时候可能会使用基于它扩展后的组件，来应对不同场景下的需求。例如在官方文档里，列举了以下几个具体的组件。</p>
<ul>
<li><a href="../../../react-router-dom/docs/api/BrowserRouter.md"><code>&lt;BrowserRouter&gt;</code></a></li>
<li><a href="../../../react-router-dom/docs/api/HashRouter.md"><code>&lt;HashRouter&gt;</code></a></li>
<li><a href="./MemoryRouter.md"><code>&lt;MemoryRouter&gt;</code></a></li>
<li><a href="../../../react-router-native/docs/api/NativeRouter.md"><code>&lt;NativeRouter&gt;</code></a></li>
<li><a href="./StaticRouter.md"><code>&lt;StaticRouter&gt;</code></a></li>
<li><code>BrowserRouter</code> 是在现代浏览器里使用较多的组件，它在支持 <code>HTML5</code> 的 <code>history API</code> 的地方使用。通过独立的包 <code>react-router-dom</code> 提供。其余组件做的事情类似，只是使用方式略有不同，这里不再赘述。</li>
<li><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/Router.md" target="_blank" rel="noopener"><strong>这里是具体的文档</strong></a><br><span></span></li>
</ul>
</li>
<li><p>通常情况下，<code>Router</code> 作为父组件，包裹着 <code>Route</code> 和 <code>Switch</code> 等组件。</p>
</li>
<li><p>观察它的源码。它本质上也是 <code>React</code> 组件。在渲染的时候，注册监听了事件。下文细说。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The public API for putting history on context.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> propTypes = &#123;</span><br><span class="line">    history: PropTypes.object.isRequired,</span><br><span class="line">    children: PropTypes.node</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    router: PropTypes.object.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        ...this.context.router,</span><br><span class="line">        history: <span class="hljs-keyword">this</span>.props.history,</span><br><span class="line">        route: &#123;</span><br><span class="line">          location: <span class="hljs-keyword">this</span>.props.history.location,</span><br><span class="line">          match: <span class="hljs-keyword">this</span>.state.match</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    match: <span class="hljs-keyword">this</span>.computeMatch(<span class="hljs-keyword">this</span>.props.history.location.pathname)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  computeMatch(pathname) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      path: <span class="hljs-string">'/'</span>,</span><br><span class="line">      url: <span class="hljs-string">'/'</span>,</span><br><span class="line">      params: &#123;&#125;,</span><br><span class="line">      isExact: pathname === <span class="hljs-string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; children, history &#125; = <span class="hljs-keyword">this</span>.props</span><br><span class="line">    <span class="hljs-comment">// Do this here so we can setState when a &lt;Redirect&gt; changes the</span></span><br><span class="line">    <span class="hljs-comment">// location in componentWillMount. This happens e.g. when doing</span></span><br><span class="line">    <span class="hljs-comment">// server rendering using a &lt;StaticRouter&gt;.</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.unlisten = history.listen(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">        match: <span class="hljs-keyword">this</span>.computeMatch(history.location.pathname)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.unlisten()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; children &#125; = <span class="hljs-keyword">this</span>.props</span><br><span class="line">    <span class="hljs-keyword">return</span> children ? React.Children.only(children) : <span class="hljs-literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Router</span><br></pre></td></tr></table></figure>
</li>
<li><p>在静态 <code>props</code> 里可以看到，<code>history</code> 是必须的。印证了我们的常规用法。生成 <code>history</code> 后再传入组件内。<code>&lt;Router history={history}&gt;</code></p>
</li>
<li><p>然后在生命周期 <code>componentWillMount</code> 里，使用 <code>history.listen</code> 注册了 <code>setState</code> 事件。当路由变化时，会自动触发 <code>history</code> 内的 <code>setState</code> 事件，进而触发当前传入的更新 <code>state</code> 的事件。原理就是上文的 <code>Link</code> 的内部逻辑，加上之前分析的 <code>history</code> 的 <code>push</code> 方法里的逻辑和事件订阅发布逻辑。</p>
<ul>
<li>注意这里，使用箭头函数保证 <code>this</code> 的指向仍是 <code>Router</code>.</li>
</ul>
</li>
<li><p>然后它返回一个解绑函数。在组件卸载 <code>componentWillUnmount</code> 时调用 <code>unlisten</code>。</p>
</li>
<li><p>这就解释了，为什么 <code>Link</code> 里，点击后的事件，会导致当前 <code>Router</code> 的 <code>state</code> 的变化，进而改变 <code>context.router</code> 里的内容。然后将此传递给子组件 <code>Route</code>.</p>
</li>
<li><p><em>到这里，这就是动作变化引起视图变化的核心逻辑了。接下来是，视图如何根据传入的值匹配应当显示的组件。</em></p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/context.router.md" target="_blank" rel="noopener"><strong>context.router 的简单介绍</strong></a></p>
</li>
</ul>
<h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/modules/Route.js" target="_blank" rel="noopener">Route</a></h4><ul>
<li><p>首先了解下基本的用法。<code>Route</code> 组件是允许传入几种不同类型的值的。</p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/Route.md" target="_blank" rel="noopener"><strong>文档</strong></a></p>
</li>
<li><p><strong><code>component</code></strong>: 直接将组件传入。当路由匹配的时候才会渲染，将 <code>props</code> 作为参数传入，然后创建元素。</p>
<ul>
<li><code>&lt;Route path=&#39;/&#39; exact component={Main}/&gt;</code></li>
<li>创建方式：<code>React.createElement(props)</code></li>
</ul>
</li>
</ul>
<p><span></span></p>
<ul>
<li><strong><code>render</code></strong>: 返回一个函数，可以直接是包装后的组件，或者直接是元素。直接调用。<ul>
<li><code>&lt;Route path=&#39;/home&#39; render={() =&gt; &lt;Home/&gt;} /&gt;</code></li>
<li>创建方式：<code>render(props)</code></li>
</ul>
</li>
</ul>
<p><span></span></p>
<ul>
<li><p><strong><code>children</code></strong>: 一个函数，和 <code>render</code> 类似。但它在任何情况下，只要传入值就会渲染。它接收的 <code>props</code> 和其他方式相同，除了在不匹配的情况下，<code>match</code> 的值为 <code>null</code> 这点不同。它的业务场景，可能是用于一些固定显示在页面的组件，然后通过 <code>match</code> 的值来控制样式。</p>
</li>
<li><p>以下是简化的 <code>Route</code> 源码。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> matchPath <span class="hljs-keyword">from</span> <span class="hljs-string">'./matchPath'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The public API for matching a single path and rendering.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Route</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      history: PropTypes.object.isRequired,</span><br><span class="line">      route: PropTypes.object.isRequired,</span><br><span class="line">      staticContext: PropTypes.object</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      router: &#123;</span><br><span class="line">        ...this.context.router,</span><br><span class="line">        route: &#123;</span><br><span class="line">          location: <span class="hljs-keyword">this</span>.props.location || <span class="hljs-keyword">this</span>.context.router.route.location,</span><br><span class="line">          match: <span class="hljs-keyword">this</span>.state.match</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    match: <span class="hljs-keyword">this</span>.computeMatch(<span class="hljs-keyword">this</span>.props, <span class="hljs-keyword">this</span>.context.router)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  computeMatch(&#123; computedMatch, location, path, strict, exact, sensitive &#125;, router) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (computedMatch)</span><br><span class="line">      <span class="hljs-keyword">return</span> computedMatch <span class="hljs-comment">// &lt;Switch&gt; already computed the match for us</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; route &#125; = router</span><br><span class="line">    <span class="hljs-keyword">const</span> pathname = (location || route.location).pathname</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> path ? matchPath(pathname, &#123; path, strict, exact, sensitive &#125;) : route.match</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">      match: <span class="hljs-keyword">this</span>.computeMatch(nextProps, nextContext.router)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; match &#125; = <span class="hljs-keyword">this</span>.state</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; children, component, render &#125; = <span class="hljs-keyword">this</span>.props</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; history, route, staticContext &#125; = <span class="hljs-keyword">this</span>.context.router</span><br><span class="line">    <span class="hljs-keyword">const</span> location = <span class="hljs-keyword">this</span>.props.location || route.location</span><br><span class="line">    <span class="hljs-keyword">const</span> props = &#123; match, location, history, staticContext &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      component ? ( <span class="hljs-comment">// component prop gets first priority, only called if there's a match</span></span><br><span class="line">        match ? React.createElement(component, props) : <span class="hljs-literal">null</span></span><br><span class="line">      ) : render ? ( <span class="hljs-comment">// render prop is next, only called if there's a match</span></span><br><span class="line">        match ? render(props) : <span class="hljs-literal">null</span></span><br><span class="line">      ) : children ? ( <span class="hljs-comment">// children come last, always called</span></span><br><span class="line">        <span class="hljs-keyword">typeof</span> children === <span class="hljs-string">'function'</span> ? (</span><br><span class="line">          children(props)</span><br><span class="line">        ) : !isEmptyChildren(children) ? (</span><br><span class="line">          React.Children.only(children)</span><br><span class="line">        ) : (</span><br><span class="line">          <span class="hljs-literal">null</span></span><br><span class="line">        )</span><br><span class="line">      ) : (</span><br><span class="line">        <span class="hljs-literal">null</span></span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Route</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Route</code> 组件里，首先我们看到 <code>render</code> 里，由组件的内容类型来决定渲染是 <code>component</code> 或 <code>render</code> 或 <code>children</code>. 然后由 <code>this.state.match</code> 这个字段决定了当前的元素是否渲染。</p>
</li>
<li><p>接着在上述源码里，<code>this.state.macth</code> 字段是在 <code>componentWillReceiveProps</code> 和初始化里可以看到。而这个变量，由一个比较重要的函数 <code>computeMatch</code> 返回。它是用来对比当前路由是否匹配，依此来决定渲染组件或者不渲染。它的具体的值下文会讲到。</p>
</li>
<li><p><code>computeMatch</code> 接收 <code>nextProps</code> 和 <code>context.router</code> 作为参数。首先判断是否处于 <code>Switch</code> 组件中，如果在其中，则直接走 <code>Switch</code> 安排的逻辑，它有着自己的一套计算匹配逻辑。否则，则继续判断。</p>
</li>
<li><p>接下来的核心判断，是获取 <code>pathname</code>, 通过 <code>props.location</code> || <code>context.router.route.pathname</code> 获取。然后将其作为参数，传入另一个重要方法 <code>matchPath</code> 中，做计算匹配的逻辑。</p>
</li>
<li><p>当然，有一些参数作为辅助判断，例如 <code>exact</code> <code>sensitive</code> <code>strict</code>等。</p>
</li>
<li><p><code>matchPath</code> 是外部引入的，独立的一个文件包装的方法。可以直接看源码。</p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/modules/matchPath.js" target="_blank" rel="noopener"><strong><code>matchPath</code>源码</strong></a>和<a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/matchPath.md" target="_blank" rel="noopener"><strong>文档</strong></a></p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pathToRegexp <span class="hljs-keyword">from</span> <span class="hljs-string">'path-to-regexp'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> patternCache = &#123;&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> cacheLimit = <span class="hljs-number">10000</span></span><br><span class="line"><span class="hljs-keyword">let</span> cacheCount = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> compilePath = <span class="hljs-function">(<span class="hljs-params">pattern, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-string">`<span class="hljs-subst">$&#123;options.end&#125;</span><span class="hljs-subst">$&#123;options.strict&#125;</span><span class="hljs-subst">$&#123;options.sensitive&#125;</span>`</span></span><br><span class="line">  <span class="hljs-keyword">const</span> cache = patternCache[cacheKey] || (patternCache[cacheKey] = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (cache[pattern])</span><br><span class="line">    <span class="hljs-keyword">return</span> cache[pattern]</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> keys = []</span><br><span class="line">  <span class="hljs-keyword">const</span> re = pathToRegexp(pattern, keys, options)</span><br><span class="line">  <span class="hljs-keyword">const</span> compiledPattern = &#123; re, keys &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (cacheCount &lt; cacheLimit) &#123;</span><br><span class="line">    cache[pattern] = compiledPattern</span><br><span class="line">    cacheCount++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> compiledPattern</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Public API for matching a URL pathname to a path pattern.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> matchPath = <span class="hljs-function">(<span class="hljs-params">pathname, options = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'string'</span>)</span><br><span class="line">    options = &#123; <span class="hljs-attr">path</span>: options &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> &#123; path = <span class="hljs-string">'/'</span>, exact = <span class="hljs-literal">false</span>, strict = <span class="hljs-literal">false</span>, sensitive = <span class="hljs-literal">false</span> &#125; = options</span><br><span class="line">  <span class="hljs-keyword">const</span> &#123; re, keys &#125; = compilePath(path, &#123; <span class="hljs-attr">end</span>: exact, strict, sensitive &#125;)</span><br><span class="line">  <span class="hljs-keyword">const</span> match = re.exec(pathname)</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!match)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> [ url, ...values ] = match</span><br><span class="line">  <span class="hljs-keyword">const</span> isExact = pathname === url</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (exact &amp;&amp; !isExact)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    path, <span class="hljs-comment">// the path pattern used to match</span></span><br><span class="line">    url: path === <span class="hljs-string">'/'</span> &amp;&amp; url === <span class="hljs-string">''</span> ? <span class="hljs-string">'/'</span> : url, <span class="hljs-comment">// the matched portion of the URL</span></span><br><span class="line">    isExact, <span class="hljs-comment">// whether or not we matched exactly</span></span><br><span class="line">    params: keys.reduce(<span class="hljs-function">(<span class="hljs-params">memo, key, index</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[key.name] = values[index]</span><br><span class="line">      <span class="hljs-keyword">return</span> memo</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> matchPath</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>matchPath</code> 通过返回一个对象，来确定路由是否匹配。(官方文档有关于这个对象的介绍<a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/match.md" target="_blank" rel="noopener"><strong>match</strong></a>)如果匹配，则返回一个包含 <code>path</code>, <code>url</code>, <code>isExact</code>, <code>params</code> 等属性的对象。否则，则返回 <code>null</code>.</p>
</li>
<li><p><strong>判断的主要逻辑是通过正则。</strong></p>
</li>
<li><p>引入了外部的独立的库 <a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener"><strong><code>path-to-regexp</code></strong></a> 来将地址转化成正则。</p>
<ul>
<li><code>compilePath</code> 方法里： <code>const re = pathToRegexp(pattern, keys, options)</code></li>
<li><code>const { re, keys } = compilePath(path, { end: exact, strict, sensitive })</code></li>
<li><code>const match = re.exec(pathname)</code></li>
<li><strong>这里的返回对象，最终在 <code>Route</code> 组件的 <code>render</code> 中起到了决定性的作用。每一个 <code>Route</code> 都会根据这个 <code>match</code> 对象来判断，符合则渲染，不符合则返回 <code>null</code>.</strong></li>
</ul>
</li>
</ul>
<p><span></span></p>
<ul>
<li>可以看到，除了上述常规判断以外，加了一层缓存逻辑。<code>cache[pattern]</code> 保存了上次的记录。而且属性名也很奇怪，类似 <code>truefalsefalse</code> 的形式。这里暂未理解。</li>
</ul>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/modules/Switch.js?1546508592999" target="_blank" rel="noopener">Switch</a></h4><ul>
<li><p>观察 <code>Switch</code> 的源码可以发现，它本质上也是调用了 <code>matchPath</code> 来判断匹配结果。</p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/Switch.md?1546863502437" target="_blank" rel="noopener"><strong>这里是文档</strong></a></p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> matchPath <span class="hljs-keyword">from</span> <span class="hljs-string">'./matchPath'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The public API for rendering the first &lt;Route&gt; that matches.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Switch</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> contextTypes = &#123;</span><br><span class="line">    router: PropTypes.shape(&#123;</span><br><span class="line">      route: PropTypes.object.isRequired</span><br><span class="line">    &#125;).isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; route &#125; = <span class="hljs-keyword">this</span>.context.router</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; children &#125; = <span class="hljs-keyword">this</span>.props</span><br><span class="line">    <span class="hljs-keyword">const</span> location = <span class="hljs-keyword">this</span>.props.location || route.location</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">let</span> match, child</span><br><span class="line">    React.Children.forEach(children, element =&gt; &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (!React.isValidElement(element)) <span class="hljs-keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">path</span>: pathProp, exact, strict, sensitive, <span class="hljs-keyword">from</span> &#125; = element.props</span><br><span class="line">      <span class="hljs-keyword">const</span> path = pathProp || <span class="hljs-keyword">from</span></span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        child = element</span><br><span class="line">        match = path ? matchPath(location.pathname, &#123; path, exact, strict, sensitive &#125;) : route.match</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> match ? React.cloneElement(child, &#123; location, <span class="hljs-attr">computedMatch</span>: match &#125;) : <span class="hljs-literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Switch</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/modules/withRouter.js?1546862447071" target="_blank" rel="noopener">withRouter</a></h3><ul>
<li><p><code>withRouter</code> 是一个高阶组件。个人理解，它比较像是 <code>react-redux</code> 的 <code>Provider</code> 组件。它将原生的组件传入，然后通过 <code>Route</code> 包装，沿用 <code>props</code> 当前的组件，返回这个包装后的组件。</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> hoistStatics <span class="hljs-keyword">from</span> <span class="hljs-string">'hoist-non-react-statics'</span></span><br><span class="line"><span class="hljs-keyword">import</span> Route <span class="hljs-keyword">from</span> <span class="hljs-string">'./Route'</span></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* A public higher-order component to access the imperative API</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">const</span> withRouter = <span class="hljs-function">(<span class="hljs-params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> C = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; wrappedComponentRef, ...remainingProps &#125; = props</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;Route render=&#123;routeComponentProps =&gt; (</span><br><span class="line">        &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125;/&gt;</span><br><span class="line">      )&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  C.displayName = <span class="hljs-string">`withRouter(<span class="hljs-subst">$&#123;Component.displayName || Component.name&#125;</span>)`</span></span><br><span class="line">  C.WrappedComponent = Component</span><br><span class="line">  C.propTypes = &#123;</span><br><span class="line">    wrappedComponentRef: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> hoistStatics(C, Component)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withRouter</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前在项目中我还没有用到它，等用到的时候，再来补充下具体的使用场景。</p>
</li>
<li><p><a href="https://github.com/ReactTraining/react-router/blob/v4.2.2/packages/react-router/docs/api/withRouter.md?1546862742594" target="_blank" rel="noopener"><strong>这里是文档</strong></a></p>
</li>
</ul>
<h4 id="react-router与react-router-dom"><a href="#react-router与react-router-dom" class="headerlink" title="react-router与react-router-dom"></a><code>react-router</code>与<code>react-router-dom</code></h4><ul>
<li>好了，现在来补充这两个库的不同。</li>
<li><code>react-router</code> 是一个底层的库，任何其他的基于 <code>React</code> 的路由库都基于它。但是在实际应用中，我们可能要对不同的场景做一些细分，以便更好地使用它们。</li>
<li>于是，就有了为现代浏览器提供的 <code>react-router-dom</code>. 观察代码可以发现，它的核心组件，例如 <code>Route</code>、<code>Switch</code>、<code>withRouter</code> 都是从 <code>react-router</code> 直接引入的。</li>
<li>除此之外，自然还有在 <code>React-Native</code> 中使用的 <code>react-router-native</code>, 以及结合 <code>redux</code> 使用的 <code>react-router-redux</code> 等等。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在了解完这么多组件的内容和原理后，相信我们对于 <code>react-router</code> 的实现，有了一定的清晰思路了。我们会发现，最终总结的和最初理解的不一样。其实就是自己的理解在一开始是不完善的，甚至有些误解。这个时候，让我们再把流程图再重新梳理，画一遍。下面是简略的更新逻辑过程。</li>
</ul>
<img src="/2019/01/03/understanding-react-router/react-router-road.png">

<ul>
<li>下面是一张调用栈的图，或许可以更直观地展示调用了哪些方法调用以及他们的执行顺序。</li>
</ul>
<img src="/2019/01/03/understanding-react-router/react-router-stack.png">

<h3 id="遗漏的坑"><a href="#遗漏的坑" class="headerlink" title="遗漏的坑"></a>遗漏的坑</h3><ul>
<li>到此，相关的主要逻辑就解释完毕了。</li>
<li>以下是遗留的几个待完成的 TODO. 可能会马上补上也可能需要点时间，但最终，我会补上的。</li>
<li><code>react-router</code> 或 <code>history</code> 在 <code>node</code> 中的应用。</li>
<li><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener"><strong><code>path-to-regexp</code></strong></a> 的原理及为何使用缓存。</li>
<li><code>popstate</code> 和 <code>hashchange</code> 最后到底在哪些地方进行了调用和应用。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://juejin.im/post/5a7e9ee7f265da4e7832949c" target="_blank" rel="noopener">[译]简明React Router v4教程</a><br><a href="https://github.com/fi3ework/blog/issues/21" target="_blank" rel="noopener">前端路由实现及 react-router v4 源码分析</a></p>
</blockquote>

<hr>
<img src="/2019/01/03/understanding-react-router/reward.jpeg" title="Thanks">

<!-- 1h + 1h + 0.8h + 1h + 1h + 0.8h + 0.6h + 0.2h + 0.5h-->
<!-- 6.4h -->

        <!-- 引入打赏图片即显示打赏功能 -->
        
            <div class="page-reward">
  <a href="javascript:;" class="page-reward-btn tooltip-top">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">赏</span>
    <span class="tooltip-content">
      <span class="tooltip-text">
        <span class="tooltip-inner">
          <div class="reward-box">
          </div>
        </span>
      </span>
    </span>
  </div>
  </a>
</div>

        
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/React-Router/">#React-Router</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev">
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2018/11/23/the-compatibility-issues-in-macos-mojave/">升级 MacOs Mojave 后的兼容问题解决</a>
            
        </span>
    </div>
    
    <script>
    // 打赏相关逻辑
    var img = document.body.querySelector('img[title="Thanks"]');
    if (img && img.style) {
        var reward = document.body.querySelector('.page-reward-btn');
        img.className += ' reward-qrcode';
        var className = img.getAttribute('class');
        img.style.display = 'none';
        img.style.width = '200px';
        reward.addEventListener('click', function () {
            if (img.style.display === 'none' || className === 'pay-hide') {
                $('img.reward-qrcode').fadeIn('slow');
            } else {
                $('img.reward-qrcode').fadeOut();
            }
        })
    }
    </script>
</article>




<div class="comments">
    <h3 class="title is-4">评论</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'http://kyriejoshua.github.io/2019/01/03/understanding-react-router/';
        this.page.identifier = '2019/01/03/understanding-react-router/';
        
        this.language = 'zh';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'deadpool-frontend' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>


    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 朱征原&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <!-- 纯 css3 实现 🎲 -->
<div id="dice" class="dice" title="🎲 点我就消失">
  <div class="dice-content">
    <!-- 1 -->
    <div class="dice-face dice-pos-top">
      <span class="dice-point"></span>
    </div>
    <!-- 2 -->
    <div class="dice-face dice-pos-left flex flex-column jc-sa">
      <div class="flex jc-fs">
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-fe">
        <span class="dice-point"></span>
      </div>
    </div>
    <!-- 3 -->
    <div class="dice-face dice-pos-front flex flex-column jc-sa">
      <div class="flex jc-fs">
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-c">
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-fe">
        <span class="dice-point"></span>
      </div>
    </div>
    <!-- 4 -->
    <div class="dice-face dice-pos-back flex flex-column jc-sa">
      <div class="flex jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
    </div>
    <!-- 5 -->
    <div class="dice-face dice-pos-right flex flex-column jc-sa">
      <div class="flex jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-c">
        <span class="dice-point"></span>
      </div>
      <div class="flex jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
    </div>
    <!-- 6 -->
    <div class="dice-face dice-pos-bottom">
      <div class="flex flex-column jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
      <div class="flex flex-column jc-sa">
        <span class="dice-point"></span>
        <span class="dice-point"></span>
        <span class="dice-point"></span>
      </div>
    </div>
  </div>
</div>

    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>
